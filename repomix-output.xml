This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/pom.xml
backend/README.md
backend/src/main/java/com/collabris/CollabrisApplication.java
backend/src/main/java/com/collabris/config/AdminUserInitializer.java
backend/src/main/java/com/collabris/config/DataInitializer.java
backend/src/main/java/com/collabris/config/SwaggerConfig.java
backend/src/main/java/com/collabris/config/WebSecurityConfig.java
backend/src/main/java/com/collabris/config/WebSocketConfig.java
backend/src/main/java/com/collabris/controller/AuthController.java
backend/src/main/java/com/collabris/controller/ChatController.java
backend/src/main/java/com/collabris/controller/DashboardController.java
backend/src/main/java/com/collabris/controller/ProjectController.java
backend/src/main/java/com/collabris/controller/TeamController.java
backend/src/main/java/com/collabris/controller/UserController.java
backend/src/main/java/com/collabris/dto/request/AdminUserUpdateRequest.java
backend/src/main/java/com/collabris/dto/request/ChatMessageRequest.java
backend/src/main/java/com/collabris/dto/request/ChatRoomRequest.java
backend/src/main/java/com/collabris/dto/request/ForgotPasswordRequest.java
backend/src/main/java/com/collabris/dto/request/LoginRequest.java
backend/src/main/java/com/collabris/dto/request/ProjectRequest.java
backend/src/main/java/com/collabris/dto/request/ResetPasswordConfirmRequest.java
backend/src/main/java/com/collabris/dto/request/ResetPasswordRequest.java
backend/src/main/java/com/collabris/dto/request/SignupRequest.java
backend/src/main/java/com/collabris/dto/request/TeamRequest.java
backend/src/main/java/com/collabris/dto/request/VerifyEmailRequest.java
backend/src/main/java/com/collabris/dto/request/VerifyResetCodeRequest.java
backend/src/main/java/com/collabris/dto/response/ChatMessageResponse.java
backend/src/main/java/com/collabris/dto/response/JwtResponse.java
backend/src/main/java/com/collabris/dto/response/MessageResponse.java
backend/src/main/java/com/collabris/dto/response/ProjectResponse.java
backend/src/main/java/com/collabris/dto/response/TeamResponse.java
backend/src/main/java/com/collabris/dto/response/UserResponse.java
backend/src/main/java/com/collabris/entity/ChatMessage.java
backend/src/main/java/com/collabris/entity/ChatRoom.java
backend/src/main/java/com/collabris/entity/Project.java
backend/src/main/java/com/collabris/entity/Role.java
backend/src/main/java/com/collabris/entity/Team.java
backend/src/main/java/com/collabris/entity/User.java
backend/src/main/java/com/collabris/entity/VerificationToken.java
backend/src/main/java/com/collabris/exception/GlobalExceptionHandler.java
backend/src/main/java/com/collabris/repository/ChatMessageRepository.java
backend/src/main/java/com/collabris/repository/ChatRoomRepository.java
backend/src/main/java/com/collabris/repository/ProjectRepository.java
backend/src/main/java/com/collabris/repository/RoleRepository.java
backend/src/main/java/com/collabris/repository/TeamRepository.java
backend/src/main/java/com/collabris/repository/UserRepository.java
backend/src/main/java/com/collabris/repository/VerificationTokenRepository.java
backend/src/main/java/com/collabris/security/jwt/AuthEntryPointJwt.java
backend/src/main/java/com/collabris/security/jwt/AuthTokenFilter.java
backend/src/main/java/com/collabris/security/jwt/JwtUtils.java
backend/src/main/java/com/collabris/security/services/UserDetailsServiceImpl.java
backend/src/main/java/com/collabris/security/services/UserPrinciple.java
backend/src/main/java/com/collabris/service/ChatService.java
backend/src/main/java/com/collabris/service/EmailService.java
backend/src/main/java/com/collabris/service/ProjectService.java
backend/src/main/java/com/collabris/service/TeamService.java
backend/src/main/java/com/collabris/service/TokenService.java
backend/src/main/java/com/collabris/service/UserService.java
backend/src/main/resources/application.properties
backend/src/main/resources/templates/email-verification.html
backend/src/main/resources/templates/password-reset.html
backend/src/test/java/com/collabris/CollabrisApplicationTests.java
backend/src/test/java/com/collabris/controller/AuthControllerTest.java
backend/src/test/resources/application-test.properties
frontend/eslint.config.js
frontend/index.html
frontend/package.json
frontend/postcss.config.js
frontend/src/App.tsx
frontend/src/components/Admin/UserModal.jsx
frontend/src/components/Admin/UserTable.jsx
frontend/src/components/Auth/ProtectedRoute.tsx
frontend/src/components/Common/LoadingSpinner.tsx
frontend/src/components/Common/StatsCard.jsx
frontend/src/components/Layout/Layout.tsx
frontend/src/components/Layout/Navbar.jsx
frontend/src/components/Layout/NavigationItem.tsx
frontend/src/config/environment.ts
frontend/src/hooks/useTheme.ts
frontend/src/hooks/useWebSocket.ts
frontend/src/index.css
frontend/src/main.tsx
frontend/src/pages/Auth/ForgotPassword.tsx
frontend/src/pages/Auth/Login.tsx
frontend/src/pages/Auth/Register.tsx
frontend/src/pages/Auth/ResetPassword.tsx
frontend/src/pages/Auth/VerifyEmail.tsx
frontend/src/pages/Dashboard.tsx
frontend/src/pages/Dashboard/AdminDashboard.jsx
frontend/src/pages/Dashboard/Dashboard.jsx
frontend/src/pages/Dashboard/ManagerDashboard.jsx
frontend/src/pages/Dashboard/MemberDashboard.jsx
frontend/src/pages/Landing/Landing.tsx
frontend/src/pages/Profile/Profile.jsx
frontend/src/pages/Projects/ProjectDetailPage.jsx
frontend/src/pages/Projects/ProjectModal.jsx
frontend/src/pages/Projects/ProjectsPage.jsx
frontend/src/pages/Settings/Settings.jsx
frontend/src/pages/Teams/TeamDetailPage.jsx
frontend/src/pages/Teams/TeamModal.jsx
frontend/src/pages/Teams/TeamsPage.jsx
frontend/src/services/apiClient.ts
frontend/src/services/authService.ts
frontend/src/services/chatService.ts
frontend/src/services/dashboardService.ts
frontend/src/services/projectService.ts
frontend/src/services/teamService.ts
frontend/src/services/userService.ts
frontend/src/store/slices/authSlice.ts
frontend/src/store/slices/dashboardSlice.ts
frontend/src/store/slices/themeSlice.ts
frontend/src/store/slices/uiSlice.ts
frontend/src/store/slices/userSlice.ts
frontend/src/store/store.ts
frontend/src/theme/customStyles.css
frontend/src/theme/theme.ts
frontend/src/types/index.ts
frontend/src/vite-env.d.ts
frontend/tailwind.config.js
frontend/vite.config.ts
index.html
multi-commit.ps1
package.json
postcss.config.js
README.md
src/App.tsx
src/index.css
src/main.tsx
src/vite-env.d.ts
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Java / Maven
target/
*.class
*.jar

# IDE
.vscode/
.idea/
*.iml

# Node / frontend
node_modules/
dist/
build/

# Logs, OS
*.log
.DS_Store

# Secrets, environment
.env
*.key
*.pem
uploads/    # don't commit uploaded files
/.mvn/wrapper/maven-wrapper.jar

# other
/.gradle/
</file>

<file path="backend/pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.collabris</groupId>
    <artifactId>collabris-backend</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>collabris-backend</name>
    <description>Collabris Collaboration App Backend</description>
    <properties>
        <java.version>17</java.version>
    </properties>
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- MODIFICATION: Explicitly add the Tomcat starter to resolve version conflicts -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-websocket</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.3</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.3</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.3</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Swagger/OpenAPI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.2.0</version>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
</file>

<file path="backend/README.md">
# Collabris Backend

A comprehensive Spring Boot backend for the Collabris collaboration application.

## Features

- **Authentication & Authorization**: JWT-based authentication with role-based access control
- **User Management**: Complete user registration, login, and profile management
- **Team Management**: Create and manage teams with member assignments
- **Project Management**: Project creation, assignment, and tracking
- **Real-time Chat**: WebSocket-based messaging system with STOMP protocol
- **API Documentation**: Swagger/OpenAPI 3.0 documentation
- **Database**: PostgreSQL with JPA/Hibernate
- **Security**: Spring Security with JWT tokens
- **Testing**: Unit and integration tests

## Technology Stack

- **Framework**: Spring Boot 3.2.0
- **Security**: Spring Security with JWT
- **Database**: PostgreSQL with JPA/Hibernate
- **WebSocket**: STOMP over WebSocket for real-time messaging
- **Documentation**: Swagger/OpenAPI 3.0
- **Testing**: JUnit 5, Spring Boot Test
- **Build Tool**: Maven

## Prerequisites

- Java 17 or higher
- PostgreSQL 12 or higher
- Maven 3.6 or higher

## Database Setup

1. Create PostgreSQL database:
```sql
CREATE DATABASE collabris_db;
CREATE USER collabris_user WITH PASSWORD 'collabris_pass';
GRANT ALL PRIVILEGES ON DATABASE collabris_db TO collabris_user;
```

2. The application will automatically create tables on startup using Hibernate DDL.

## Configuration

The application is configured via `application.properties`. Key configurations:

- **Database**: PostgreSQL connection settings
- **JWT**: Secret key and expiration time
- **CORS**: Allowed origins for frontend
- **File Upload**: Maximum file sizes
- **Email**: SMTP configuration for notifications

## Running the Application

1. Clone the repository
2. Navigate to the backend directory
3. Run the application:

```bash
mvn spring-boot:run
```

The application will start on `http://localhost:8080`

## API Documentation

Once the application is running, access the Swagger UI at:
- **Swagger UI**: http://localhost:8080/swagger-ui.html
- **API Docs**: http://localhost:8080/v3/api-docs

## API Endpoints

### Authentication
- `POST /api/auth/signup` - Register new user
- `POST /api/auth/signin` - User login

### User Management
- `GET /api/users` - Get all users (Admin only)
- `GET /api/users/{id}` - Get user by ID
- `PUT /api/users/{id}` - Update user
- `DELETE /api/users/{id}` - Delete user (Admin only)

### Team Management
- `GET /api/teams` - Get all teams
- `POST /api/teams` - Create team
- `PUT /api/teams/{id}` - Update team
- `DELETE /api/teams/{id}` - Delete team
- `POST /api/teams/{teamId}/members/{userId}` - Add member to team

### Project Management
- `GET /api/projects` - Get all projects
- `POST /api/projects` - Create project
- `PUT /api/projects/{id}` - Update project
- `DELETE /api/projects/{id}` - Delete project
- `POST /api/projects/{projectId}/members/{userId}` - Add member to project

### Chat System
- `GET /api/chat/rooms` - Get all chat rooms
- `POST /api/chat/rooms` - Create chat room
- `GET /api/chat/rooms/{roomId}/messages` - Get messages
- `POST /api/chat/messages` - Send message

### WebSocket Endpoints
- `/ws` - WebSocket connection endpoint
- `/app/chat.sendMessage` - Send message via WebSocket
- `/topic/chat/{roomId}` - Subscribe to room messages

## Security

The application uses JWT tokens for authentication. Include the token in the Authorization header:

```
Authorization: Bearer <your-jwt-token>
```

### Roles
- **ADMIN**: Full system access
- **MANAGER**: Team and project management
- **MEMBER**: Basic user access

## Testing

Run tests with:

```bash
mvn test
```

The test suite includes:
- Unit tests for services and controllers
- Integration tests for API endpoints
- Security tests for authentication and authorization

## Database Schema

The application creates the following main entities:
- **Users**: User accounts with authentication
- **Roles**: User roles for access control
- **Teams**: User groups for collaboration
- **Projects**: Work projects with team assignments
- **ChatRooms**: Communication channels
- **ChatMessages**: Individual messages

## WebSocket Configuration

Real-time messaging is implemented using STOMP over WebSocket:
- **Connection**: `/ws` endpoint with SockJS fallback
- **Message Broker**: Simple broker for `/topic` and `/queue`
- **Application Prefix**: `/app` for client messages

## Error Handling

Global exception handling provides consistent error responses:
- Validation errors with field-specific messages
- Authentication and authorization errors
- Custom business logic exceptions
- Generic error handling for unexpected issues

## Development

### Adding New Features

1. Create entity classes in `com.collabris.entity`
2. Add repository interfaces in `com.collabris.repository`
3. Implement service classes in `com.collabris.service`
4. Create controller classes in `com.collabris.controller`
5. Add DTOs in `com.collabris.dto`
6. Write tests in `src/test/java`

### Code Structure

```
src/main/java/com/collabris/
├── config/          # Configuration classes
├── controller/      # REST controllers
├── dto/            # Data Transfer Objects
├── entity/         # JPA entities
├── exception/      # Exception handling
├── repository/     # Data repositories
├── security/       # Security configuration
└── service/        # Business logic services
```

## Production Deployment

For production deployment:

1. Update `application.properties` with production database settings
2. Change JWT secret to a secure random value
3. Configure proper CORS origins
4. Set up SSL/TLS certificates
5. Configure logging levels
6. Set up monitoring and health checks

## Contributing

1. Follow Spring Boot best practices
2. Write comprehensive tests
3. Document API changes in Swagger annotations
4. Follow the existing code structure and naming conventions
5. Ensure security considerations are addressed

## License

This project is licensed under the Apache License 2.0.
</file>

<file path="backend/src/main/java/com/collabris/CollabrisApplication.java">
package com.collabris;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CollabrisApplication {
    public static void main(String[] args) {
        SpringApplication.run(CollabrisApplication.class, args);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/config/DataInitializer.java">
package com.collabris.config;

import com.collabris.entity.Role;
import com.collabris.repository.RoleRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;

@Component
@Order(1)
public class DataInitializer implements CommandLineRunner {

    @Autowired
    private RoleRepository roleRepository;

    @Override
    public void run(String... args) {
        if (roleRepository.count() == 0) {
            roleRepository.saveAll(List.of(
                new Role(Role.ERole.ADMIN),
                new Role(Role.ERole.MANAGER),
                new Role(Role.ERole.MEMBER)
            ));
        }
    }
}
</file>

<file path="backend/src/main/java/com/collabris/config/SwaggerConfig.java">
package com.collabris.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .components(new Components()
                        .addSecuritySchemes("bearerAuth",
                                new SecurityScheme()
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")))
                .info(new Info()
                        .title("Collabris API")
                        .version("1.0.0")
                        .description("Collaboration App REST API Documentation")
                        .license(new License()
                                .name("Apache 2.0")
                                .url("http://springdoc.org")));
    }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/ChatRoomRequest.java">
package com.collabris.dto.request;

import com.collabris.entity.ChatRoom;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class ChatRoomRequest {
    @NotBlank
    @Size(max = 100)
    private String name;

    @Size(max = 500)
    private String description;

    private ChatRoom.RoomType type;
    private Long projectId;

    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public ChatRoom.RoomType getType() { return type; }
    public void setType(ChatRoom.RoomType type) { this.type = type; }

    public Long getProjectId() { return projectId; }
    public void setProjectId(Long projectId) { this.projectId = projectId; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/ForgotPasswordRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public class ForgotPasswordRequest {
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email address")
    private String email;

    public ForgotPasswordRequest() {}

    public ForgotPasswordRequest(String email) { this.email = email; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/LoginRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;

public class LoginRequest {
    @NotBlank
    private String username;

    @NotBlank
    private String password;

    // Getters and Setters
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/ResetPasswordConfirmRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;

public class ResetPasswordConfirmRequest {

    @NotBlank(message = "Token is required")
    private String token;

    @NotBlank(message = "New password is required")
    private String newPassword;

    public String getToken() {
        return token;
    }

    public void setToken(String token) {
        this.token = token;
    }

    public String getNewPassword() {
        return newPassword;
    }

    public void setNewPassword(String newPassword) {
        this.newPassword = newPassword;
    }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/ResetPasswordRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class ResetPasswordRequest {

    @NotBlank(message = "Email is required")
    private String email;

    @NotBlank(message = "Verification code is required")
    @Size(min = 6, max = 6, message = "Verification code must be exactly 6 characters")
    private String code;

    @NotBlank(message = "New password is required")
    private String newPassword;

    public ResetPasswordRequest() {}

    public ResetPasswordRequest(String email, String code, String newPassword) {
        this.email = email;
        this.code = code;
        this.newPassword = newPassword;
    }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }

    public String getNewPassword() { return newPassword; }
    public void setNewPassword(String newPassword) { this.newPassword = newPassword; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/SignupRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.Set;

public class SignupRequest {
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 20, message = "Username must be between 3 and 20 characters")
    private String username;

    @NotBlank(message = "Email is required")
    @Size(max = 50, message = "Email cannot be longer than 50 characters")
    @Email(message = "Email should be valid")
    private String email;

    private Set<String> role;

    @NotBlank(message = "Password is required")
    @Size(min = 6, max = 40, message = "Password must be between 6 and 40 characters")
    private String password;

    @NotBlank(message = "First name is required")
    private String firstName;

    @NotBlank(message = "Last name is required")
    private String lastName;

    // Getters and Setters
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }

    public Set<String> getRole() { return this.role; }
    public void setRole(Set<String> role) { this.role = role; }

    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }

    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/TeamRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.Set;

public class TeamRequest {
    @NotBlank
    @Size(max = 100)
    private String name;

    @Size(max = 500)
    private String description;

    private Set<Long> memberIds;

    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Set<Long> getMemberIds() { return memberIds; }
    public void setMemberIds(Set<Long> memberIds) { this.memberIds = memberIds; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/VerifyEmailRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class VerifyEmailRequest {
    
    @NotBlank(message = "Verification code is required")
    @Size(min = 6, max = 6, message = "Verification code must be exactly 6 characters")
    @Pattern(regexp = "^[A-Z0-9]{6}$", message = "Verification code must contain only uppercase letters and numbers")
    private String code;
    
    public VerifyEmailRequest() {}
    
    public VerifyEmailRequest(String code) {
        this.code = code;
    }
    
    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/VerifyResetCodeRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class VerifyResetCodeRequest {

    @NotBlank(message = "Email is required")
    private String email;

    @NotBlank(message = "Verification code is required")
    @Size(min = 6, max = 6, message = "Verification code must be exactly 6 characters")
    @Pattern(regexp = "^[A-Z0-9]{6}$", message = "Verification code must contain only uppercase letters and numbers")
    private String code;

    public VerifyResetCodeRequest() {}
    public VerifyResetCodeRequest(String email, String code) {
        this.email = email;
        this.code = code;
    }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/response/JwtResponse.java">
// File Path: backend/src/main/java/com/collabris/dto/response/JwtResponse.java
package com.collabris.dto.response;

import com.collabris.entity.User;
import java.util.List;
import java.util.stream.Collectors;

public class JwtResponse {
    private String token;
    private String type = "Bearer";
    private UserResponse user; // FIX: Changed to include the full UserResponse object

    public JwtResponse(String accessToken, User user) {
        this.token = accessToken;
        this.user = new UserResponse(user); // Construct the UserResponse from the User entity
    }

    // Getters and Setters
    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    public UserResponse getUser() { return user; }
    public void setUser(UserResponse user) { this.user = user; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/response/MessageResponse.java">
package com.collabris.dto.response;

public class MessageResponse {
    private String message;

    public MessageResponse(String message) {
        this.message = message;
    }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/response/TeamResponse.java">
package com.collabris.dto.response;

import com.collabris.entity.Team;

import java.time.LocalDateTime;
import java.util.Set;
import java.util.stream.Collectors;

public class TeamResponse {
    private Long id;
    private String name;
    private String description;
    private UserResponse owner;
    private Set<UserResponse> members;
    private LocalDateTime createdAt;

    public TeamResponse(Team team) {
        this.id = team.getId();
        this.name = team.getName();
        this.description = team.getDescription();
        this.owner = new UserResponse(team.getOwner());
        this.members = team.getMembers().stream()
                .map(UserResponse::new)
                .collect(Collectors.toSet());
        this.createdAt = team.getCreatedAt();
    }

    // Getters for all fields
    public Long getId() { return id; }
    public String getName() { return name; }
    public String getDescription() { return description; }
    public UserResponse getOwner() { return owner; }
    public Set<UserResponse> getMembers() { return members; }
    public LocalDateTime getCreatedAt() { return createdAt; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/response/UserResponse.java">
package com.collabris.dto.response;

import com.collabris.entity.User;
import java.time.LocalDateTime;
import java.util.Set;
import java.util.stream.Collectors;

public class UserResponse {
    private Long id;
    private String username;
    private String email;
    private String firstName;
    private String lastName;
    private String profilePicture;
    private boolean enabled;
    private Set<String> roles;
    private LocalDateTime createdAt;

    public UserResponse(User user) {
        this.id = user.getId();
        this.username = user.getUsername();
        this.email = user.getEmail();
        this.firstName = user.getFirstName();
        this.lastName = user.getLastName();
        this.profilePicture = user.getProfilePicture();
        this.enabled = user.isEnabled();
        // FIX: This now sends clean role names like "ADMIN" to the frontend.
        this.roles = user.getRoles().stream()
                .map(role -> role.getName().name())
                .collect(Collectors.toSet());
        this.createdAt = user.getCreatedAt();
    }
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    public String getProfilePicture() { return profilePicture; }
    public void setProfilePicture(String profilePicture) { this.profilePicture = profilePicture; }
    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
    public Set<String> getRoles() { return roles; }
    public void setRoles(Set<String> roles) { this.roles = roles; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/ChatRoom.java">
package com.collabris.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "chat_rooms")
public class ChatRoom {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(max = 100)
    private String name;

    @Size(max = 500)
    private String description;

    @Enumerated(EnumType.STRING)
    private RoomType type = RoomType.GROUP;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "project_id")
    private Project project;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "created_by")
    private User createdBy;

    @OneToMany(mappedBy = "chatRoom", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private Set<ChatMessage> messages = new HashSet<>();

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public ChatRoom() {}

    public ChatRoom(String name, String description, RoomType type, Project project, User createdBy) {
        this.name = name;
        this.description = description;
        this.type = type;
        this.project = project;
        this.createdBy = createdBy;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public RoomType getType() { return type; }
    public void setType(RoomType type) { this.type = type; }

    public Project getProject() { return project; }
    public void setProject(Project project) { this.project = project; }

    public User getCreatedBy() { return createdBy; }
    public void setCreatedBy(User createdBy) { this.createdBy = createdBy; }

    public Set<ChatMessage> getMessages() { return messages; }
    public void setMessages(Set<ChatMessage> messages) { this.messages = messages; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }

    public enum RoomType {
        DIRECT, GROUP, PROJECT
    }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/Role.java">
// File Path: backend/src/main/java/com/collabris/entity/Role.java
package com.collabris.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(length = 50, unique = true, nullable = false)
    private ERole name;

    public Role() {}

    public Role(ERole name) {
        this.name = name;
    }

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public ERole getName() { return name; }
    public void setName(ERole name) { this.name = name; }

    public enum ERole {
        // FIX: Clean enum names. This is the final and correct version.
        ADMIN,
        MANAGER,
        MEMBER
    }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/VerificationToken.java">
// backend/src/main/java/com/collabris/entity/VerificationToken.java
package com.collabris.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "verification_tokens")
public class VerificationToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // --- MODIFICATION: Changed fetch type to EAGER to fix session errors ---
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "code", nullable = false, length = 6)
    private String code;

    @Enumerated(EnumType.STRING)
    @Column(name = "token_type", nullable = false)
    private TokenType tokenType;

    @Column(name = "expires_at", nullable = false)
    private LocalDateTime expiresAt;

    @Column(name = "used_at")
    private LocalDateTime usedAt;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    public enum TokenType {
        EMAIL_VERIFICATION,
        PASSWORD_RESET
    }

    public VerificationToken() {}

    public VerificationToken(User user, String code, TokenType tokenType) {
        this.user = user;
        this.code = code;
        this.tokenType = tokenType;
        this.createdAt = LocalDateTime.now();
        this.expiresAt = LocalDateTime.now().plusMinutes(10); // 10-minute expiry for security
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public User getUser() { return user; }
    public void setUser(User user) { this.user = user; }
    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
    public TokenType getTokenType() { return tokenType; }
    public void setTokenType(TokenType tokenType) { this.tokenType = tokenType; }
    public LocalDateTime getExpiresAt() { return expiresAt; }
    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }
    public LocalDateTime getUsedAt() { return usedAt; }
    public void setUsedAt(LocalDateTime usedAt) { this.usedAt = usedAt; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiresAt);
    }

    public boolean isUsed() {
        return usedAt != null;
    }

    public void markAsUsed() {
        this.usedAt = LocalDateTime.now();
    }
}
</file>

<file path="backend/src/main/java/com/collabris/exception/GlobalExceptionHandler.java">
package com.collabris.exception;

import com.collabris.dto.response.MessageResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(UsernameNotFoundException.class)
    public ResponseEntity<MessageResponse> handleUsernameNotFoundException(UsernameNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(new MessageResponse(ex.getMessage()));
    }

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<MessageResponse> handleRuntimeException(RuntimeException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new MessageResponse(ex.getMessage()));
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<MessageResponse> handleAccessDeniedException(AccessDeniedException ex) {
        return ResponseEntity.status(HttpStatus.FORBIDDEN)
                .body(new MessageResponse("Access denied: " + ex.getMessage()));
    }

    // --- NEW METHOD ADDED TO HANDLE VALIDATION ERRORS ---
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        // You might want to return a more structured response, e.g.,
        // a map of field names to error messages. For simplicity, we'll join them.
        String errorMessage = errors.values().stream().collect(Collectors.joining(", "));
        
        // For a better frontend experience, let's return the map of errors.
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errors);
    }
    // ---------------------------------------------------

    @ExceptionHandler(Exception.class)
    public ResponseEntity<MessageResponse> handleGenericException(Exception ex) {
        // Log the exception for debugging purposes
        // logger.error("An unexpected error occurred", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new MessageResponse("An unexpected error occurred: " + ex.getMessage()));
    }
}
</file>

<file path="backend/src/main/java/com/collabris/repository/ChatRoomRepository.java">
package com.collabris.repository;

import com.collabris.entity.ChatRoom;
import com.collabris.entity.Project;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ChatRoomRepository extends JpaRepository<ChatRoom, Long> {
    List<ChatRoom> findByProject(Project project);
    List<ChatRoom> findByProjectId(Long projectId);
    List<ChatRoom> findByType(ChatRoom.RoomType type);
}
</file>

<file path="backend/src/main/java/com/collabris/repository/ProjectRepository.java">
package com.collabris.repository;

import com.collabris.entity.Project;
import com.collabris.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProjectRepository extends JpaRepository<Project, Long> {
    List<Project> findByOwner(User owner);
    
    @Query("SELECT p FROM Project p JOIN p.members m WHERE m.id = :userId")
    List<Project> findByMemberId(@Param("userId") Long userId);
    
    @Query("SELECT p FROM Project p WHERE p.team.id = :teamId")
    List<Project> findByTeamId(@Param("teamId") Long teamId);
    
    @Query("SELECT p FROM Project p WHERE p.name LIKE %:search% OR p.description LIKE %:search%")
    List<Project> findBySearchTerm(@Param("search") String search);
}
</file>

<file path="backend/src/main/java/com/collabris/repository/RoleRepository.java">
package com.collabris.repository;

import com.collabris.entity.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(Role.ERole name);
}
</file>

<file path="backend/src/main/java/com/collabris/repository/TeamRepository.java">
package com.collabris.repository;

import com.collabris.entity.Team;
import com.collabris.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface TeamRepository extends JpaRepository<Team, Long> {
    List<Team> findByOwner(User owner);
    
    @Query("SELECT t FROM Team t JOIN t.members m WHERE m.id = :userId")
    List<Team> findByMemberId(@Param("userId") Long userId);
    
    @Query("SELECT t FROM Team t WHERE t.name LIKE %:search% OR t.description LIKE %:search%")
    List<Team> findBySearchTerm(@Param("search") String search);
}
</file>

<file path="backend/src/main/java/com/collabris/repository/VerificationTokenRepository.java">
package com.collabris.repository;

import com.collabris.entity.VerificationToken;
import com.collabris.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface VerificationTokenRepository extends JpaRepository<VerificationToken, Long> {
    
    Optional<VerificationToken> findByCodeAndTokenType(String code, VerificationToken.TokenType tokenType);
    
    Optional<VerificationToken> findByUserAndTokenTypeAndUsedAtIsNull(User user, VerificationToken.TokenType tokenType);
    
    List<VerificationToken> findByUserAndTokenType(User user, VerificationToken.TokenType tokenType);
    
    @Query("SELECT t FROM VerificationToken t WHERE t.user.email = :email AND t.tokenType = :tokenType AND t.usedAt IS NULL ORDER BY t.createdAt DESC")
    Optional<VerificationToken> findLatestUnusedTokenByEmailAndType(@Param("email") String email, @Param("tokenType") VerificationToken.TokenType tokenType);
    
    @Query("SELECT t FROM VerificationToken t WHERE t.user.username = :username AND t.tokenType = :tokenType AND t.usedAt IS NULL ORDER BY t.createdAt DESC")
    Optional<VerificationToken> findLatestUnusedTokenByUsernameAndType(@Param("username") String username, @Param("tokenType") VerificationToken.TokenType tokenType);
    
    @Modifying
    @Query("DELETE FROM VerificationToken t WHERE t.expiresAt < :now")
    void deleteExpiredTokens(@Param("now") LocalDateTime now);
    
    @Modifying
    @Query("DELETE FROM VerificationToken t WHERE t.user = :user AND t.tokenType = :tokenType")
    void deleteByUserAndTokenType(@Param("user") User user, @Param("tokenType") VerificationToken.TokenType tokenType);
}
</file>

<file path="backend/src/main/java/com/collabris/security/jwt/AuthEntryPointJwt.java">
package com.collabris.security.jwt;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component
public class AuthEntryPointJwt implements AuthenticationEntryPoint {

    private static final Logger logger = LoggerFactory.getLogger(AuthEntryPointJwt.class);

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        logger.error("Unauthorized error: {}", authException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        final Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());

        final ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), body);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/security/jwt/AuthTokenFilter.java">
package com.collabris.security.jwt;

import com.collabris.security.services.UserDetailsServiceImpl;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

public class AuthTokenFilter extends OncePerRequestFilter {
    @Autowired
    private JwtUtils jwtUtils;

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    private static final Logger logger = LoggerFactory.getLogger(AuthTokenFilter.class);

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = parseJwt(request);
            if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
                String username = jwtUtils.getUserNameFromJwtToken(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(userDetails,
                                null,
                                userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            logger.error("Cannot set user authentication: {}", e);
        }

        filterChain.doFilter(request, response);
    }

    private String parseJwt(HttpServletRequest request) {
        String headerAuth = request.getHeader("Authorization");

        if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
            return headerAuth.substring(7);
        }

        return null;
    }
}
</file>

<file path="backend/src/main/java/com/collabris/security/jwt/JwtUtils.java">
package com.collabris.security.jwt;

import com.collabris.security.services.UserPrinciple;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;   // ← crypto stays here; Jakarta EE has no jakarta.crypto

import java.util.Date;

@Component
public class JwtUtils {

    private static final Logger logger = LoggerFactory.getLogger(JwtUtils.class);

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${jwt.expiration}")
    private int jwtExpirationMs;

    /**
     * Build a SecretKey for signing/verification.
     */
    private SecretKey key() {
        // Base64 decode the secret then build HMAC-SHA key
        return Keys.hmacShaKeyFor(Decoders.BASE64.decode(jwtSecret));
    }

    /**
     * Generate a JWT token for the authenticated user.
     */
    public String generateJwtToken(Authentication authentication) {
        UserPrinciple userPrincipal = (UserPrinciple) authentication.getPrincipal();

        return Jwts.builder()
                .subject(userPrincipal.getUsername())
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + jwtExpirationMs))
                .signWith(key(), SignatureAlgorithm.HS256)
                .compact();
    }

    /**
     * Extract username from token.
     */
    public String getUserNameFromJwtToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(key())
                .build()
                .parseSignedClaims(token)
                .getPayload();
        return claims.getSubject();
    }

    /**
     * Validate JWT token.
     */
    public boolean validateJwtToken(String authToken) {
        try {
            Jwts.parser()
                    .verifyWith(key())
                    .build()
                    .parseSignedClaims(authToken);
            return true;
        } catch (MalformedJwtException e) {
            logger.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            logger.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            logger.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            logger.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }
}
</file>

<file path="backend/src/main/java/com/collabris/security/services/UserDetailsServiceImpl.java">
package com.collabris.security.services;

import com.collabris.entity.User;
import com.collabris.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    UserRepository userRepository;

    @Override
    @Transactional
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found: " + username));

        return UserPrinciple.build(user);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/security/services/UserPrinciple.java">
package com.collabris.security.services;

import com.collabris.entity.User;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class UserPrinciple implements UserDetails {
    private static final long serialVersionUID = 1L;

    private Long id;
    private String username;
    private String email;
    @JsonIgnore
    private String password;
    private boolean enabled;
    private Collection<? extends GrantedAuthority> authorities;

    public UserPrinciple(Long id, String username, String email, String password, boolean enabled,
                         Collection<? extends GrantedAuthority> authorities) {
        this.id = id;
        this.username = username;
        this.email = email;
        this.password = password;
        this.enabled = enabled;
        this.authorities = authorities;
    }

    public static UserPrinciple build(User user) {
        List<GrantedAuthority> authorities = user.getRoles().stream()
                .map(role -> {
                    // THE ABSOLUTE FIX:
                    // Get the clean role name (e.g., "ADMIN" or "ROLE_ADMIN" -> "ADMIN")
                    String roleName = role.getName().name().replace("ROLE_", "");
                    // Return the authority with the "ROLE_" prefix, ensuring no duplicates.
                    return new SimpleGrantedAuthority("ROLE_" + roleName);
                })
                .collect(Collectors.toList());

        return new UserPrinciple(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getPassword(),
                user.isEnabled(),
                authorities);
    }

    // --- ALL GETTERS AND OTHER METHODS REMAIN THE SAME ---
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() { return authorities; }
    public Long getId() { return id; }
    public String getEmail() { return email; }
    @Override
    public String getPassword() { return password; }
    @Override
    public String getUsername() { return username; }
    @Override
    public boolean isAccountNonExpired() { return true; }
    @Override
    public boolean isAccountNonLocked() { return true; }
    @Override
    public boolean isCredentialsNonExpired() { return true; }
    @Override
    public boolean isEnabled() { return this.enabled; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserPrinciple user = (UserPrinciple) o;
        return Objects.equals(id, user.id);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/service/EmailService.java">
package com.collabris.service;

import jakarta.mail.MessagingException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ClassPathResource;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;

import jakarta.mail.internet.MimeMessage;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.time.format.DateTimeFormatter;
import java.util.Map;

@Service
public class EmailService {
    private static final Logger log = LoggerFactory.getLogger(EmailService.class);

    private final JavaMailSender mailSender;

    @Value("${app.mail.from:no-reply@collabris.local}")
    private String fromAddress;

    @Value("${app.mail.enabled:false}")
    private boolean mailEnabled;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void sendEmail(String to, String subject, String templatePath, Map<String, String> variables) {
        String body = renderTemplate(templatePath, variables);
        if (!mailEnabled) {
            log.info("[MAIL DISABLED] To: {} Subject: {} Body: {}", to, subject, body);
            return;
        }
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, MimeMessageHelper.MULTIPART_MODE_MIXED_RELATED, StandardCharsets.UTF_8.name());
            helper.setFrom(fromAddress);
            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(body, true);
            mailSender.send(message);
        } catch (MessagingException e) {
            log.error("Failed to send email to {}", to, e);
        }
    }

    private String renderTemplate(String templatePath, Map<String, String> variables) {
        try {
            ClassPathResource resource = new ClassPathResource(templatePath);
            String content = Files.readString(resource.getFile().toPath(), StandardCharsets.UTF_8);
            for (Map.Entry<String, String> entry : variables.entrySet()) {
                content = content.replace("{{" + entry.getKey() + "}}", entry.getValue());
            }
            return content;
        } catch (IOException e) {
            // Fallback simple template
            StringBuilder sb = new StringBuilder();
            for (Map.Entry<String, String> entry : variables.entrySet()) {
                sb.append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
            }
            return sb.toString();
        }
    }
}
</file>

<file path="backend/src/main/java/com/collabris/service/TokenService.java">
package com.collabris.service;

import com.collabris.entity.User;
import com.collabris.entity.VerificationToken;
import com.collabris.repository.VerificationTokenRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.Optional;

@Service
public class TokenService {
    
    @Autowired
    private VerificationTokenRepository tokenRepository;
    
    private static final String CHARACTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    private static final int TOKEN_LENGTH = 6;
    private final SecureRandom random = new SecureRandom();
    
    @Transactional
    public VerificationToken createVerificationToken(User user, VerificationToken.TokenType tokenType) {
        // Delete any existing unused tokens for this user and type
        tokenRepository.deleteByUserAndTokenType(user, tokenType);
        
        // Generate a new 6-character alphanumeric code
        String code = generateRandomCode();
        
        // Create and save the new token
        VerificationToken token = new VerificationToken(user, code, tokenType);
        return tokenRepository.save(token);
    }
    
    @Transactional
    public boolean verifyToken(String code, VerificationToken.TokenType tokenType) {
        Optional<VerificationToken> tokenOpt = tokenRepository.findByCodeAndTokenType(code, tokenType);
        
        if (tokenOpt.isEmpty()) {
            return false;
        }
        
        VerificationToken token = tokenOpt.get();
        
        // Check if token is expired or already used
        if (token.isExpired() || token.isUsed()) {
            return false;
        }
        
        // Mark token as used
        token.markAsUsed();
        tokenRepository.save(token);
        
        return true;
    }
    
    @Transactional(readOnly = true)
    public Optional<VerificationToken> findValidToken(String code, VerificationToken.TokenType tokenType) {
        Optional<VerificationToken> tokenOpt = tokenRepository.findByCodeAndTokenType(code, tokenType);
        
        if (tokenOpt.isEmpty()) {
            return Optional.empty();
        }
        
        VerificationToken token = tokenOpt.get();
        
        // Return only if token is valid (not expired and not used)
        if (!token.isExpired() && !token.isUsed()) {
            return Optional.of(token);
        }
        
        return Optional.empty();
    }
    
    @Transactional(readOnly = true)
    public Optional<VerificationToken> findLatestTokenByEmail(String email, VerificationToken.TokenType tokenType) {
        return tokenRepository.findLatestUnusedTokenByEmailAndType(email, tokenType);
    }
    
    @Transactional(readOnly = true)
    public Optional<VerificationToken> findLatestTokenByUsername(String username, VerificationToken.TokenType tokenType) {
        return tokenRepository.findLatestUnusedTokenByUsernameAndType(username, tokenType);
    }
    
    @Transactional
    public void consumeToken(VerificationToken token) {
        token.markAsUsed();
        tokenRepository.save(token);
    }
    
    private String generateRandomCode() {
        StringBuilder code = new StringBuilder(TOKEN_LENGTH);
        for (int i = 0; i < TOKEN_LENGTH; i++) {
            code.append(CHARACTERS.charAt(random.nextInt(CHARACTERS.length())));
        }
        return code.toString();
    }
    
    // Scheduled method to clean up expired tokens (runs every hour)
    @Scheduled(fixedRate = 3600000) // 1 hour in milliseconds
    @Transactional
    public void cleanupExpiredTokens() {
        tokenRepository.deleteExpiredTokens(LocalDateTime.now());
    }
    
    @Transactional(readOnly = true)
    public boolean hasValidToken(User user, VerificationToken.TokenType tokenType) {
        Optional<VerificationToken> token = tokenRepository.findByUserAndTokenTypeAndUsedAtIsNull(user, tokenType);
        return token.isPresent() && !token.get().isExpired();
    }
}
</file>

<file path="backend/src/main/resources/templates/email-verification.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Verification - Collabris</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        .container {
            max-width: 600px;
            margin: 40px auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: 600;
        }
        .content {
            padding: 40px 30px;
            text-align: center;
        }
        .verification-code {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            border: 2px dashed #6b7280;
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
            font-size: 32px;
            font-weight: bold;
            letter-spacing: 4px;
            color: #1f2937;
            font-family: 'Courier New', monospace;
        }
        .message {
            line-height: 1.6;
            color: #4b5563;
            margin-bottom: 30px;
        }
        .footer {
            background: #f9fafb;
            padding: 20px;
            text-align: center;
            font-size: 14px;
            color: #6b7280;
            border-top: 1px solid #e5e7eb;
        }
        .warning {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            color: #92400e;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1> Welcome to Collabris!</h1>
        </div>
        
        <div class="content">
            <p class="message">
                Hi <strong>{{firstName}}</strong>,<br><br>
                Thank you for joining Collabris! To complete your account setup, please verify your email address using the verification code below:
            </p>
            
            <div class="verification-code">
                {{verificationCode}}
            </div>
            
            <div class="warning">
                ⏰ This verification code will expire in <strong>10 minutes</strong> for security reasons.
            </div>
            
            <p class="message">
                Simply enter this code on the verification page to activate your account and start collaborating with your team!
            </p>
            
            <p class="message">
                If you didn't create an account with Collabris, please ignore this email.
            </p>
        </div>
        
        <div class="footer">
            <p>© 2024 Collabris. All rights reserved.</p>
            <p>This is an automated message, please do not reply to this email.</p>
        </div>
    </div>
</body>
</html>
</file>

<file path="backend/src/main/resources/templates/password-reset.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Password Reset - Collabris</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        .container {
            max-width: 600px;
            margin: 40px auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: 600;
        }
        .content {
            padding: 40px 30px;
            text-align: center;
        }
        .verification-code {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            border: 2px dashed #6b7280;
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
            font-size: 32px;
            font-weight: bold;
            letter-spacing: 4px;
            color: #1f2937;
            font-family: 'Courier New', monospace;
        }
        .message {
            line-height: 1.6;
            color: #4b5563;
            margin-bottom: 30px;
        }
        .footer {
            background: #f9fafb;
            padding: 20px;
            text-align: center;
            font-size: 14px;
            color: #6b7280;
            border-top: 1px solid #e5e7eb;
        }
        .warning {
            background: #fee2e2;
            border: 1px solid #dc2626;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            color: #991b1b;
            font-size: 14px;
        }
        .security-notice {
            background: #eff6ff;
            border: 1px solid #3b82f6;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            color: #1d4ed8;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔐 Password Reset</h1>
        </div>
        
        <div class="content">
            <p class="message">
                Hi <strong>{{firstName}}</strong>,<br><br>
                We received a request to reset your password for your Collabris account. Use the verification code below to proceed with resetting your password:
            </p>
            
            <div class="verification-code">
                {{verificationCode}}
            </div>
            
            <div class="warning">
                ⏰ This verification code will expire in <strong>10 minutes</strong> for security reasons.
            </div>
            
            <div class="security-notice">
                🔒 For your security, this code can only be used once. After entering the code, you'll be able to set a new password.
            </div>
            
            <p class="message">
                If you didn't request a password reset, please ignore this email. Your password will remain unchanged.
            </p>
        </div>
        
        <div class="footer">
            <p>© 2024 Collabris. All rights reserved.</p>
            <p>This is an automated message, please do not reply to this email.</p>
        </div>
    </div>
</body>
</html>
</file>

<file path="backend/src/test/java/com/collabris/CollabrisApplicationTests.java">
package com.collabris;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;

@SpringBootTest
@TestPropertySource(locations = "classpath:application-test.properties")
class CollabrisApplicationTests {

    @Test
    void contextLoads() {
    }
}
</file>

<file path="backend/src/test/java/com/collabris/controller/AuthControllerTest.java">
// File Path: backend/src/test/java/com/collabris/controller/AuthControllerTest.java
package com.collabris.controller;

import com.collabris.dto.request.LoginRequest;
import com.collabris.dto.request.SignupRequest;
import com.collabris.entity.Role;
import com.collabris.entity.User;
import com.collabris.repository.RoleRepository;
import com.collabris.repository.UserRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;
import java.util.Set;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@AutoConfigureMockMvc
@TestPropertySource(locations = "classpath:application-test.properties")
@Transactional
public class AuthControllerTest {

    @Autowired
    private MockMvc mockMvc;
    @Autowired
    private ObjectMapper objectMapper;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private RoleRepository roleRepository;
    @Autowired
    private PasswordEncoder passwordEncoder;

    @BeforeEach
    void setUp() {
        userRepository.deleteAll();
        roleRepository.deleteAll();
        
        // FIX: Use the clean enum names as defined in Role.java
        roleRepository.save(new Role(Role.ERole.MEMBER));
        roleRepository.save(new Role(Role.ERole.ADMIN));
    }

    @AfterEach
    void tearDown() {
        userRepository.deleteAll();
        roleRepository.deleteAll();
    }

    @Test
    void testSignup() throws Exception {
        SignupRequest signupRequest = new SignupRequest();
        signupRequest.setUsername("testuser");
        signupRequest.setEmail("testuser@example.com");
        signupRequest.setPassword("Password123");
        signupRequest.setFirstName("Test");
        signupRequest.setLastName("User");

        mockMvc.perform(post("/api/auth/signup")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signupRequest)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("User registered successfully! Please verify your email."));
    }

    @Test
    void testLogin() throws Exception {
        User user = new User();
        user.setUsername("loginuser");
        user.setEmail("loginuser@example.com");
        user.setPassword(passwordEncoder.encode("Password123"));
        user.setFirstName("Login");
        user.setLastName("User");
        user.setEnabled(true);

        // FIX: Use the clean enum name to find the role for the test user
        Role memberRole = roleRepository.findByName(Role.ERole.MEMBER)
                .orElseThrow(() -> new RuntimeException("MEMBER Role not found"));
        user.setRoles(Set.of(memberRole));
        userRepository.save(user);

        LoginRequest loginRequest = new LoginRequest();
        loginRequest.setUsername("loginuser");
        loginRequest.setPassword("Password123");

        mockMvc.perform(post("/api/auth/signin")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequest)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.token").exists());
    }
}
</file>

<file path="backend/src/test/resources/application-test.properties">
# -----------------------------
# Test Database Configuration
# -----------------------------
spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# -----------------------------
# JPA/Hibernate Configuration
# -----------------------------
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect
spring.jpa.open-in-view=false

# -----------------------------
# JWT Configuration for Tests
# -----------------------------
jwt.secret=testSecretKeyForJWTTokenGenerationInTestEnvironment123456789
jwt.expiration=86400000

# -----------------------------
# CORS Configuration for Tests
# -----------------------------
cors.allowed-origins=http://localhost:3000,http://localhost:5173

# -----------------------------
# Server Configuration for Tests
# -----------------------------
# Use port 0 so Spring Boot picks a random free port
server.port=0

# -----------------------------
# Swagger/OpenAPI Configuration
# -----------------------------
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method

# -----------------------------
# Jackson Configuration
# -----------------------------
spring.jackson.serialization.fail-on-empty-beans=false

# -----------------------------
# File Upload Configuration
# -----------------------------
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
file.upload-dir=uploads

# -----------------------------
# Email Configuration (disabled for tests)
# -----------------------------
spring.mail.host=
spring.mail.port=
spring.mail.username=
spring.mail.password=
spring.mail.properties.mail.smtp.auth=false
spring.mail.properties.mail.smtp.starttls.enable=false

# -----------------------------
# Logging Configuration
# -----------------------------
logging.level.com.collabris=DEBUG
logging.level.org.springframework.security=DEBUG
</file>

<file path="frontend/eslint.config.js">
import js from '@eslint/js';
import globals from 'globals';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  }
);
</file>

<file path="frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="frontend/src/components/Auth/ProtectedRoute.tsx">
import React, { useEffect } from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { Box, CircularProgress } from '@mui/material';
import { useAppSelector, useAppDispatch } from '../../store/store';
import { selectIsAuthenticated, selectIsLoading, selectUser, getCurrentUser } from '../../store/slices/authSlice';

interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRoles?: string[];
  fallbackPath?: string;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  requiredRoles = [], 
  fallbackPath = '/login' 
}) => {
  const dispatch = useAppDispatch();
  const location = useLocation();
  const isAuthenticated = useAppSelector(selectIsAuthenticated);
  const isLoading = useAppSelector(selectIsLoading);
  const user = useAppSelector(selectUser);

  useEffect(() => {
    if (isAuthenticated && !user) {
      dispatch(getCurrentUser());
    }
  }, [isAuthenticated, user, dispatch]);

  if (isLoading || (isAuthenticated && !user)) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="100vh">
        <CircularProgress />
      </Box>
    );
  }

  if (!isAuthenticated) {
    return <Navigate to={fallbackPath} state={{ from: location }} replace />;
  }

  // Add check for enabled user
  if (user && !user.enabled) {
    return <Navigate to="/verify-email" state={{ from: location, email: user.email }} replace />;
  }
  
  if (requiredRoles.length > 0 && user) {
    const userRoles = user.roles.map(role => role.name);
    const hasRequiredRole = requiredRoles.some(role => userRoles.includes(role as any));
    
    if (!hasRequiredRole) {
      const redirectPath = userRoles.includes('ADMIN') ? '/admin/dashboard' : '/dashboard';
      return <Navigate to={redirectPath} replace />;
    }
  }

  return <>{children}</>;
};

export default ProtectedRoute;
</file>

<file path="frontend/src/components/Common/LoadingSpinner.tsx">
import React from 'react';
import { Box, CircularProgress, Typography } from '@mui/material';

interface LoadingSpinnerProps {
  message?: string;
  size?: number;
}

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ 
  message = 'Loading...', 
  size = 40 
}) => {
  return (
    <Box
      display="flex"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      minHeight="200px"
      className="animate-fade-in"
    >
      <CircularProgress size={size} sx={{ mb: 2 }} />
      <Typography variant="body2" color="text.secondary">
        {message}
      </Typography>
    </Box>
  );
};

export default LoadingSpinner;
</file>

<file path="frontend/src/components/Common/StatsCard.jsx">
import React from 'react';
import { Card, CardContent, Typography, Box, Avatar } from '@mui/material';
import { motion } from 'framer-motion';

const StatsCard = ({ title, value, icon, color = 'primary', trend }) => {
  return (
    <motion.div
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      transition={{ duration: 0.2 }}
    >
      <Card
        sx={{
          height: '100%',
          background: (theme) =>
            `linear-gradient(135deg, ${theme.palette[color].main}15 0%, ${theme.palette[color].main}05 100%)`,
          border: (theme) => `1px solid ${theme.palette[color].main}20`,
        }}
      >
        <CardContent>
          <Box display="flex" alignItems="center" justifyContent="space-between">
            <Box>
              <Typography variant="h4" fontWeight="bold" color={`${color}.main`}>
                {value}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                {title}
              </Typography>
              {trend && (
                <Typography
                  variant="caption"
                  color={trend > 0 ? 'success.main' : 'error.main'}
                  sx={{ mt: 1, display: 'block' }}
                >
                  {trend > 0 ? '+' : ''}{trend}% from last month
                </Typography>
              )}
            </Box>
            <Avatar
              sx={{
                bgcolor: `${color}.main`,
                width: 56,
                height: 56,
              }}
            >
              {icon}
            </Avatar>
          </Box>
        </CardContent>
      </Card>
    </motion.div>
  );
};

export default StatsCard;
</file>

<file path="frontend/src/components/Layout/Navbar.jsx">
import React, { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { useNavigate, Link } from 'react-router-dom';
import {
  AppBar,
  Toolbar,
  Typography,
  Button,
  IconButton,
  Menu,
  MenuItem,
  Avatar,
  Box,
  Switch,
  Tooltip,
} from '@mui/material';
import {
  AccountCircle,
  Settings,
  Logout,
  Dashboard,
  People,
  DarkMode,
  LightMode,
  Menu as MenuIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import { logout } from '../../store/slices/authSlice';
import { toggleDarkMode } from '../../store/slices/themeSlice';

const Navbar = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const { user, isAuthenticated } = useSelector((state) => state.auth);
  const { darkMode } = useSelector((state) => state.theme);
  
  const [anchorEl, setAnchorEl] = useState(null);
  const [mobileMenuAnchor, setMobileMenuAnchor] = useState(null);

  const handleProfileMenuOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  const handleMobileMenuOpen = (event) => {
    setMobileMenuAnchor(event.currentTarget);
  };

  const handleMobileMenuClose = () => {
    setMobileMenuAnchor(null);
  };

  const handleLogout = () => {
    dispatch(logout());
    navigate('/login');
    handleMenuClose();
  };

  const handleThemeToggle = () => {
    dispatch(toggleDarkMode());
  };

  const isAdmin = user?.roles?.includes('ROLE_ADMIN');

  const menuItems = [
    { label: 'Dashboard', path: isAdmin ? '/admin' : '/dashboard', icon: <Dashboard /> },
    ...(isAdmin ? [{ label: 'Users', path: '/admin/users', icon: <People /> }] : []),
    { label: 'Profile', path: '/profile', icon: <AccountCircle /> },
    { label: 'Settings', path: '/settings', icon: <Settings /> },
  ];

  return (
    <AppBar position="sticky" elevation={0} sx={{ backdropFilter: 'blur(10px)' }}>
      <Toolbar>
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.5 }}
        >
          <Typography
            variant="h6"
            component={Link}
            to={isAuthenticated ? (isAdmin ? '/admin' : '/dashboard') : '/'}
            sx={{
              flexGrow: 1,
              textDecoration: 'none',
              color: 'inherit',
              fontWeight: 700,
              background: 'linear-gradient(45deg, #18BC9C, #2C3E50)',
              backgroundClip: 'text',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
            }}
          >
            Collabris
          </Typography>
        </motion.div>

        <Box sx={{ flexGrow: 1 }} />

        {isAuthenticated && (
          <>
            {/* Desktop Menu */}
            <Box sx={{ display: { xs: 'none', md: 'flex' }, alignItems: 'center', gap: 1 }}>
              {menuItems.map((item) => (
                <Button
                  key={item.path}
                  component={Link}
                  to={item.path}
                  startIcon={item.icon}
                  color="inherit"
                  sx={{ mx: 1 }}
                >
                  {item.label}
                </Button>
              ))}
              
              <Tooltip title="Toggle theme">
                <IconButton onClick={handleThemeToggle} color="inherit">
                  {darkMode ? <LightMode /> : <DarkMode />}
                </IconButton>
              </Tooltip>

              <IconButton onClick={handleProfileMenuOpen} color="inherit">
                <Avatar
                  src={user?.profilePicture}
                  alt={user?.username}
                  sx={{ width: 32, height: 32 }}
                >
                  {user?.username?.charAt(0).toUpperCase()}
                </Avatar>
              </IconButton>
            </Box>

            {/* Mobile Menu */}
            <Box sx={{ display: { xs: 'flex', md: 'none' } }}>
              <IconButton onClick={handleMobileMenuOpen} color="inherit">
                <MenuIcon />
              </IconButton>
            </Box>
          </>
        )}

        {!isAuthenticated && (
          <Box sx={{ display: 'flex', gap: 1 }}>
            <Button component={Link} to="/login" color="inherit">
              Login
            </Button>
            <Button component={Link} to="/register" variant="outlined" color="inherit">
              Register
            </Button>
          </Box>
        )}

        {/* Profile Menu */}
        <Menu
          anchorEl={anchorEl}
          open={Boolean(anchorEl)}
          onClose={handleMenuClose}
          transformOrigin={{ horizontal: 'right', vertical: 'top' }}
          anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
        >
          <MenuItem onClick={() => { navigate('/profile'); handleMenuClose(); }}>
            <AccountCircle sx={{ mr: 1 }} />
            Profile
          </MenuItem>
          <MenuItem onClick={() => { navigate('/settings'); handleMenuClose(); }}>
            <Settings sx={{ mr: 1 }} />
            Settings
          </MenuItem>
          <MenuItem onClick={handleLogout}>
            <Logout sx={{ mr: 1 }} />
            Logout
          </MenuItem>
        </Menu>

        {/* Mobile Menu */}
        <Menu
          anchorEl={mobileMenuAnchor}
          open={Boolean(mobileMenuAnchor)}
          onClose={handleMobileMenuClose}
          transformOrigin={{ horizontal: 'right', vertical: 'top' }}
          anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
        >
          {menuItems.map((item) => (
            <MenuItem
              key={item.path}
              onClick={() => {
                navigate(item.path);
                handleMobileMenuClose();
              }}
            >
              {item.icon}
              <Typography sx={{ ml: 1 }}>{item.label}</Typography>
            </MenuItem>
          ))}
          <MenuItem onClick={handleThemeToggle}>
            {darkMode ? <LightMode /> : <DarkMode />}
            <Typography sx={{ ml: 1 }}>
              {darkMode ? 'Light Mode' : 'Dark Mode'}
            </Typography>
          </MenuItem>
          <MenuItem onClick={handleLogout}>
            <Logout />
            <Typography sx={{ ml: 1 }}>Logout</Typography>
          </MenuItem>
        </Menu>
      </Toolbar>
    </AppBar>
  );
};

export default Navbar;
</file>

<file path="frontend/src/components/Layout/NavigationItem.tsx">
import React from 'react';
import {
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  useTheme,
  alpha,
} from '@mui/material';

interface NavigationItemProps {
  text: string;
  icon: React.ReactNode;
  active: boolean;
  onClick: () => void;
}

const NavigationItem: React.FC<NavigationItemProps> = ({
  text,
  icon,
  active,
  onClick,
}) => {
  const theme = useTheme();

  return (
    <ListItem disablePadding sx={{ mb: 0.5 }}>
      <ListItemButton
        onClick={onClick}
        sx={{
          borderRadius: 2,
          py: 1.5,
          px: 2,
          minHeight: 48,
          backgroundColor: active
            ? alpha(theme.palette.primary.main, 0.15)
            : 'transparent',
          border: active 
            ? `1px solid ${alpha(theme.palette.primary.main, 0.3)}`
            : '1px solid transparent',
          color: active 
            ? theme.palette.primary.main
            : theme.palette.text.primary,
          '&:hover': {
            backgroundColor: active
              ? alpha(theme.palette.primary.main, 0.2)
              : alpha(theme.palette.action.hover, 0.08),
            transform: 'translateX(4px)',
            transition: 'all 0.2s ease-in-out',
          },
          '&:before': active ? {
            content: '""',
            position: 'absolute',
            left: 0,
            top: '50%',
            transform: 'translateY(-50%)',
            width: 3,
            height: '60%',
            backgroundColor: theme.palette.primary.main,
            borderRadius: '0 2px 2px 0',
          } : {},
          transition: 'all 0.2s ease-in-out',
        }}
      >
        <ListItemIcon
          sx={{
            minWidth: 40,
            color: 'inherit',
            '& svg': {
              fontSize: '1.25rem',
            },
          }}
        >
          {icon}
        </ListItemIcon>
        <ListItemText
          primary={text}
          sx={{
            '& .MuiListItemText-primary': {
              fontSize: '0.875rem',
              fontWeight: active ? 600 : 500,
              letterSpacing: '0.025em',
            },
          }}
        />
      </ListItemButton>
    </ListItem>
  );
};

export default NavigationItem;
</file>

<file path="frontend/src/config/environment.ts">
export const config = {
  apiBaseUrl: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8080',
  wsBaseUrl: import.meta.env.VITE_WS_BASE_URL || 'http://localhost:8080',
  isDevelopment: import.meta.env.DEV,
  isProduction: import.meta.env.PROD,
};

export const endpoints = {
  // Auth endpoints
  auth: {
    signup: '/api/auth/signup',
    signin: '/api/auth/signin',
  },
  // User endpoints
  users: {
    getAll: '/api/users',
    getById: (id: string | number) => `/api/users/${id}`,
    update: (id: string | number) => `/api/users/${id}`,
    delete: (id: string | number) => `/api/users/${id}`,
    uploadAvatar: (id: string | number) => `/api/users/${id}/avatar`,
  },
  // Team endpoints
  teams: {
    getAll: '/api/teams',
    create: '/api/teams',
    getById: (id: string | number) => `/api/teams/${id}`,
    update: (id: string | number) => `/api/teams/${id}`,
    delete: (id: string | number) => `/api/teams/${id}`,
    addMember: (teamId: string | number, userId: string | number) => `/api/teams/${teamId}/members/${userId}`,
    removeMember: (teamId: string | number, userId: string | number) => `/api/teams/${teamId}/members/${userId}`,
  },
  // Project endpoints
  projects: {
    getAll: '/api/projects',
    create: '/api/projects',
    getById: (id: string | number) => `/api/projects/${id}`,
    update: (id: string | number) => `/api/projects/${id}`,
    delete: (id: string | number) => `/api/projects/${id}`,
    addMember: (projectId: string | number, userId: string | number) => `/api/projects/${projectId}/members/${userId}`,
    removeMember: (projectId: string | number, userId: string | number) => `/api/projects/${projectId}/members/${userId}`,
  },
  // Chat endpoints
  chat: {
    getRooms: '/api/chat/rooms',
    createRoom: '/api/chat/rooms',
    getMessages: (roomId: string | number) => `/api/chat/rooms/${roomId}/messages`,
    sendMessage: '/api/chat/messages',
  },
  // WebSocket endpoints
  websocket: {
    connect: '/ws',
    sendMessage: '/app/chat.sendMessage',
    subscribe: (roomId: string | number) => `/topic/chat/${roomId}`,
  },
} as const;
</file>

<file path="frontend/src/index.css">
/* Import fonts first */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

/* Tailwind layers */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Reset */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Body font */
body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
}
::-webkit-scrollbar-track {
  background: #f1f1f1;
}
::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

/* Animations */
.fade-in {
  animation: fadeIn 0.5s ease-in;
}
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to   { opacity: 1; transform: translateY(0); }
}

.slide-in {
  animation: slideIn 0.3s ease-out;
}
@keyframes slideIn {
  from { transform: translateX(-100%); }
  to   { transform: translateX(0); }
}
</file>

<file path="frontend/src/pages/Auth/ForgotPassword.tsx">
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Typography,
  Alert,
  useTheme,
} from '@mui/material';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { forgotPassword } from '../../services/authService';
import toast from 'react-hot-toast';

const schema = yup.object().shape({
  email: yup.string().email('Invalid email address').required('Email is required'),
});

const ForgotPassword = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const theme = useTheme();
  const navigate = useNavigate();

  const { control, handleSubmit, formState: { errors } } = useForm<{ email: string }>({
    resolver: yupResolver(schema),
  });

  const onSubmit = async (data: { email: string }) => {
    setIsLoading(true);
    setError(null);
    try {
      await forgotPassword(data);
      toast.success('If an account exists, a reset code has been sent to your email.');
      navigate('/reset-password', { state: { email: data.email } });
    } catch (err: any) {
      setError(err.message || 'An unexpected error occurred.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: theme.palette.mode === 'light'
          ? 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
          : 'linear-gradient(135deg, #2D3748 0%, #4A5568 100%)',
      }}
    >
      <Card sx={{ maxWidth: 400, width: '100%', mx: 2, p: 2 }}>
        <CardContent>
          <Typography variant="h5" component="h1" sx={{ fontWeight: 700, textAlign: 'center', mb: 2 }}>
            Forgot Password
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', mb: 3 }}>
            Enter your email and we'll send you a code to reset your password.
          </Typography>

          {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}

          <Box component="form" onSubmit={handleSubmit(onSubmit)}>
            <Controller
              name="email"
              control={control}
              render={({ field }) => (
                <TextField
                  {...field}
                  fullWidth
                  label="Email Address"
                  type="email"
                  error={!!errors.email}
                  helperText={errors.email?.message}
                  sx={{ mb: 2 }}
                />
              )}
            />
            <Button type="submit" fullWidth variant="contained" size="large" disabled={isLoading}>
              {isLoading ? 'Sending...' : 'Send Reset Code'}
            </Button>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
};

export default ForgotPassword;
</file>

<file path="frontend/src/pages/Auth/ResetPassword.tsx">
import React, { useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Typography,
  Alert,
  useTheme,
} from '@mui/material';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { resetPassword } from '../../services/authService';
import toast from 'react-hot-toast';

const schema = yup.object().shape({
  code: yup.string().length(6, 'Code must be 6 characters').required('Verification code is required'),
  newPassword: yup.string().min(6, 'Password must be at least 6 characters').required('New password is required'),
  confirmPassword: yup.string().oneOf([yup.ref('newPassword')], 'Passwords must match').required('Please confirm your password'),
});

const ResetPassword = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const theme = useTheme();
  const navigate = useNavigate();
  const location = useLocation();
  const email = location.state?.email;

  const { control, handleSubmit, formState: { errors } } = useForm({
    resolver: yupResolver(schema),
    defaultValues: { code: '', newPassword: '', confirmPassword: '' }
  });

  const onSubmit = async (data: any) => {
    if (!email) {
      setError("Email not found. Please start the process again.");
      return;
    }
    setIsLoading(true);
    setError(null);
    try {
      await resetPassword({ email, code: data.code, newPassword: data.newPassword });
      toast.success('Password has been reset successfully. Please log in.');
      navigate('/login');
    } catch (err: any) {
      setError(err.message || 'Failed to reset password.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: theme.palette.mode === 'light'
          ? 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
          : 'linear-gradient(135deg, #2D3748 0%, #4A5568 100%)',
      }}
    >
      <Card sx={{ maxWidth: 400, width: '100%', mx: 2, p: 2 }}>
        <CardContent>
          <Typography variant="h5" component="h1" sx={{ fontWeight: 700, textAlign: 'center', mb: 2 }}>
            Reset Your Password
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', mb: 3 }}>
            Enter the code sent to your email and your new password.
          </Typography>

          {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
          {!email && <Alert severity="warning" sx={{ mb: 2 }}>No email provided. Please start from the 'Forgot Password' page.</Alert>}

          <Box component="form" onSubmit={handleSubmit(onSubmit)}>
            <Controller name="code" control={control} render={({ field }) => (
                <TextField {...field} fullWidth label="Reset Code" error={!!errors.code} helperText={errors.code?.message} sx={{ mb: 2 }} />
            )}/>
            <Controller name="newPassword" control={control} render={({ field }) => (
                <TextField {...field} fullWidth type="password" label="New Password" error={!!errors.newPassword} helperText={errors.newPassword?.message} sx={{ mb: 2 }} />
            )}/>
            <Controller name="confirmPassword" control={control} render={({ field }) => (
                <TextField {...field} fullWidth type="password" label="Confirm New Password" error={!!errors.confirmPassword} helperText={errors.confirmPassword?.message} sx={{ mb: 2 }} />
            )}/>
            
            <Button type="submit" fullWidth variant="contained" size="large" disabled={isLoading || !email}>
              {isLoading ? 'Resetting...' : 'Reset Password'}
            </Button>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
};

export default ResetPassword;
</file>

<file path="frontend/src/pages/Auth/VerifyEmail.tsx">
import React, { useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Typography,
  Alert,
  useTheme,
} from '@mui/material';
import { useAppDispatch } from '../../store/store';
import { verifyEmail, resendVerificationEmail } from '../../services/authService';
import { showSuccessNotification, showErrorNotification } from '../../store/slices/uiSlice';
import toast from 'react-hot-toast';

const VerifyEmail: React.FC = () => {
  const [code, setCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [resendLoading, setResendLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const theme = useTheme();
  const navigate = useNavigate();
  const dispatch = useAppDispatch();
  const location = useLocation();
  const email = location.state?.email;

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    if (code.length !== 6) {
      setError('Verification code must be 6 characters long.');
      return;
    }
    setIsLoading(true);
    setError(null);
    try {
      await verifyEmail({ code });
      dispatch(showSuccessNotification('Success!', 'Your email has been verified. Please log in.'));
      navigate('/login');
    } catch (err: any) {
      setError(err.message || 'Verification failed. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleResendCode = async () => {
    if (!email) {
        toast.error("Could not find an email to resend the code to. Please try registering again.");
        return;
    }
    setResendLoading(true);
    try {
        await resendVerificationEmail({ email });
        toast.success("A new verification code has been sent to your email.");
    } catch (err: any) {
        toast.error(err.message || "Failed to resend verification code.");
    } finally {
        setResendLoading(false);
    }
  };

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: theme.palette.mode === 'light'
          ? 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
          : 'linear-gradient(135deg, #2D3748 0%, #4A5568 100%)',
      }}
    >
      <Card sx={{ maxWidth: 400, width: '100%', mx: 2, p: 2 }}>
        <CardContent>
          <Typography variant="h5" component="h1" sx={{ fontWeight: 700, textAlign: 'center', mb: 2 }}>
            Verify Your Email
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', mb: 3 }}>
            A 6-character verification code has been sent to your email address.
          </Typography>

          {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}

          <Box component="form" onSubmit={handleSubmit}>
            <TextField
              fullWidth
              label="Verification Code"
              value={code}
              onChange={(e) => setCode(e.target.value.toUpperCase())}
              inputProps={{ maxLength: 6, style: { textAlign: 'center', letterSpacing: '0.5rem' } }}
              sx={{ mb: 2 }}
            />
            <Button type="submit" fullWidth variant="contained" size="large" disabled={isLoading}>
              {isLoading ? 'Verifying...' : 'Verify Account'}
            </Button>
            <Button fullWidth onClick={handleResendCode} disabled={resendLoading} sx={{ mt: 1 }}>
                {resendLoading ? 'Sending...' : 'Resend Code'}
            </Button>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
};

export default VerifyEmail;
</file>

<file path="frontend/src/pages/Dashboard.tsx">
import React, { useEffect, useState } from 'react';
import {
  Box,
  Grid,
  Card,
  CardContent,
  Typography,
  Avatar,
  LinearProgress,
  Chip,
  IconButton,
  Button,
  Paper,
  List,
  ListItem,
  ListItemAvatar,
  ListItemText,
  ListItemSecondaryAction,
  useTheme,
  alpha,
  Skeleton,
} from '@mui/material';
import {
  TrendingUp as TrendingUpIcon,
  People as PeopleIcon,
  Assignment as ProjectIcon,
  Chat as ChatIcon,
  Add as AddIcon,
  MoreVert as MoreIcon,
  Schedule as ScheduleIcon,
  CheckCircle as CheckIcon,
  Warning as WarningIcon,
  Notifications as NotificationsIcon,
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { motion } from 'framer-motion';
import { useAppSelector } from '../store/store';
import { selectUser } from '../store/slices/authSlice';
import { getUserProjects } from '../services/projectService';
import { getUserTeams } from '../services/teamService';
import { Project, Team } from '../types';

interface DashboardStats {
  totalProjects: number;
  activeTeams: number;
  completedTasks: number;
  pendingTasks: number;
}

interface RecentActivity {
  id: string;
  type: 'project' | 'team' | 'task' | 'message';
  title: string;
  description: string;
  timestamp: string;
  user?: string;
  avatar?: string;
}

// Using imported Project and Team types from '../types'

const Dashboard: React.FC = () => {
  const theme = useTheme();
  const navigate = useNavigate();
  const user = useAppSelector(selectUser);
  
  const [loading, setLoading] = useState(true);
  const [stats, setStats] = useState<DashboardStats>({
    totalProjects: 0,
    activeTeams: 0,
    completedTasks: 0,
    pendingTasks: 0,
  });
  const [recentProjects, setRecentProjects] = useState<Project[]>([]);
  const [recentTeams, setRecentTeams] = useState<Team[]>([]);
  const [recentActivity, setRecentActivity] = useState<RecentActivity[]>([]);

  useEffect(() => {
    const fetchDashboardData = async () => {
      try {
        setLoading(true);
        
        // Fetch user's projects
        const projects = await getUserProjects();
        
        // Fetch user's teams
        const teams = await getUserTeams();
        
        // Calculate stats
        const activeProjects = projects.filter((p: Project) => p.status === 'IN_PROGRESS');
        const completedProjects = projects.filter((p: Project) => p.status === 'COMPLETED');
        
        setStats({
          totalProjects: projects.length,
          activeTeams: teams.length,
          completedTasks: completedProjects.length * 5, // Estimate
          pendingTasks: activeProjects.length * 3, // Estimate
        });
        
        // Set recent data (limit to 6 items each)
        setRecentProjects(projects.slice(0, 6));
        setRecentTeams(teams.slice(0, 6));
        
        // Generate mock recent activity
        const mockActivity: RecentActivity[] = [
          {
            id: '1',
            type: 'project',
            title: 'Project Updated',
            description: `${projects[0]?.name || 'New Project'} progress updated to 75%`,
            timestamp: '2 hours ago',
            user: user?.username || 'User',
            avatar: user?.username?.charAt(0) || 'U',
          },
          {
            id: '2',
            type: 'team',
            title: 'New Team Member',
            description: `Someone joined ${teams[0]?.name || 'your team'}`,
            timestamp: '4 hours ago',
          },
          {
            id: '3',
            type: 'task',
            title: 'Task Completed',
            description: 'Database optimization task completed',
            timestamp: '1 day ago',
            user: user?.username || 'User',
          },
          {
            id: '4',
            type: 'message',
            title: 'New Message',
            description: 'New message in project chat',
            timestamp: '2 days ago',
          },
        ];
        setRecentActivity(mockActivity);
        
      } catch (error) {
        console.error('Failed to fetch dashboard data:', error);
        // Set default mock data on error
        setStats({
          totalProjects: 5,
          activeTeams: 3,
          completedTasks: 12,
          pendingTasks: 8,
        });
      } finally {
        setLoading(false);
      }
    };

    fetchDashboardData();
  }, [user]);

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'IN_PROGRESS':
        return theme.palette.success.main;
      case 'COMPLETED':
        return theme.palette.info.main;
      case 'ON_HOLD':
        return theme.palette.warning.main;
      case 'PLANNING':
        return theme.palette.info.main;
      default:
        return theme.palette.grey[500];
    }
  };

  const getActivityIcon = (type: string) => {
    switch (type) {
      case 'project':
        return <ProjectIcon sx={{ color: theme.palette.primary.main }} />;
      case 'team':
        return <PeopleIcon sx={{ color: theme.palette.success.main }} />;
      case 'task':
        return <CheckIcon sx={{ color: theme.palette.info.main }} />;
      case 'message':
        return <ChatIcon sx={{ color: theme.palette.warning.main }} />;
      default:
        return <NotificationsIcon />;
    }
  };

  const StatCard = ({ title, value, icon, trend, color }: any) => (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <Card
        sx={{
          height: '100%',
          background: `linear-gradient(135deg, ${color}15 0%, ${color}05 100%)`,
          border: `1px solid ${alpha(color, 0.2)}`,
          backdropFilter: 'blur(20px)',
          '&:hover': {
            transform: 'translateY(-4px)',
            boxShadow: `0 8px 25px ${alpha(color, 0.15)}`,
            transition: 'all 0.3s ease-in-out',
          },
        }}
      >
        <CardContent>
          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
            <Avatar
              sx={{
                bgcolor: alpha(color, 0.1),
                color: color,
                mr: 2,
              }}
            >
              {icon}
            </Avatar>
            <Box>
              <Typography variant="h4" sx={{ fontWeight: 700, color: theme.palette.text.primary }}>
                {loading ? <Skeleton width={60} /> : value}
              </Typography>
              <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>
                {title}
              </Typography>
            </Box>
          </Box>
          {trend && (
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <TrendingUpIcon sx={{ color: theme.palette.success.main, mr: 0.5, fontSize: 16 }} />
              <Typography variant="caption" sx={{ color: theme.palette.success.main }}>
                +{trend}% this month
              </Typography>
            </Box>
          )}
        </CardContent>
      </Card>
    </motion.div>
  );

  return (
    <Box sx={{ flexGrow: 1 }}>
      {/* Welcome Section */}
      <motion.div
        initial={{ opacity: 0, x: -20 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ duration: 0.6 }}
      >
        <Box
          sx={{
            mb: 4,
            p: 3,
            background: theme.palette.mode === 'light' 
              ? 'linear-gradient(135deg, rgba(37, 99, 235, 0.1) 0%, rgba(124, 58, 237, 0.1) 100%)'
              : 'linear-gradient(135deg, rgba(37, 99, 235, 0.2) 0%, rgba(124, 58, 237, 0.2) 100%)',
            borderRadius: 3,
            border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
          }}
        >
          <Typography variant="h4" sx={{ fontWeight: 700, mb: 1 }}>
            Welcome back, {user?.firstName || user?.username || 'User'}! 👋
          </Typography>
          <Typography variant="body1" sx={{ color: theme.palette.text.secondary, mb: 2 }}>
            Here's what's happening with your projects and teams today.
          </Typography>
          <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
            <Button
              variant="contained"
              startIcon={<AddIcon />}
              onClick={() => navigate('/projects/new')}
              sx={{
                background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)',
                '&:hover': {
                  background: 'linear-gradient(135deg, #1d4ed8 0%, #6d28d9 100%)',
                },
              }}
            >
              New Project
            </Button>
            <Button
              variant="outlined"
              startIcon={<PeopleIcon />}
              onClick={() => navigate('/teams')}
            >
              View Teams
            </Button>
          </Box>
        </Box>
      </motion.div>

      {/* Stats Cards */}
      <Grid container spacing={3} sx={{ mb: 4 }}>
        <Grid item xs={12} sm={6} lg={3}>
          <StatCard
            title="Total Projects"
            value={stats.totalProjects}
            icon={<ProjectIcon />}
            trend={15}
            color={theme.palette.primary.main}
          />
        </Grid>
        <Grid item xs={12} sm={6} lg={3}>
          <StatCard
            title="Active Teams"
            value={stats.activeTeams}
            icon={<PeopleIcon />}
            trend={8}
            color={theme.palette.success.main}
          />
        </Grid>
        <Grid item xs={12} sm={6} lg={3}>
          <StatCard
            title="Completed Tasks"
            value={stats.completedTasks}
            icon={<CheckIcon />}
            trend={25}
            color={theme.palette.info.main}
          />
        </Grid>
        <Grid item xs={12} sm={6} lg={3}>
          <StatCard
            title="Pending Tasks"
            value={stats.pendingTasks}
            icon={<WarningIcon />}
            color={theme.palette.warning.main}
          />
        </Grid>
      </Grid>

      {/* Main Content Grid */}
      <Grid container spacing={3}>
        {/* Recent Projects */}
        <Grid item xs={12} lg={8}>
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.6, delay: 0.2 }}
          >
            <Card sx={{ mb: 3 }}>
              <CardContent>
                <Box sx={{ display: 'flex', justifyContent: 'between', alignItems: 'center', mb: 2 }}>
                  <Typography variant="h6" sx={{ fontWeight: 600 }}>
                    Recent Projects
                  </Typography>
                  <Button
                    size="small"
                    onClick={() => navigate('/projects')}
                    sx={{ textTransform: 'none' }}
                  >
                    View All
                  </Button>
                </Box>
                
                {loading ? (
                  <Box>
                    {[1, 2, 3].map((item) => (
                      <Box key={item} sx={{ mb: 2 }}>
                        <Skeleton variant="text" width="60%" height={24} />
                        <Skeleton variant="text" width="80%" height={20} />
                        <Skeleton variant="rectangular" width="100%" height={4} sx={{ mt: 1 }} />
                      </Box>
                    ))}
                  </Box>
                ) : recentProjects.length > 0 ? (
                  <Box>
                    {recentProjects.map((project, index) => (
                      <motion.div
                        key={project.id}
                        initial={{ opacity: 0, x: -20 }}
                        animate={{ opacity: 1, x: 0 }}
                        transition={{ duration: 0.4, delay: index * 0.1 }}
                      >
                        <Box
                          sx={{
                            p: 2,
                            mb: 2,
                            border: `1px solid ${alpha(theme.palette.divider, 0.1)}`,
                            borderRadius: 2,
                            '&:hover': {
                              backgroundColor: alpha(theme.palette.action.hover, 0.05),
                              cursor: 'pointer',
                            },
                          }}
                          onClick={() => navigate(`/projects/${project.id}`)}
                        >
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                            <Typography variant="subtitle1" sx={{ fontWeight: 600 }}>
                              {project.name}
                            </Typography>
                            <Chip
                              label={project.status}
                              size="small"
                              sx={{
                                backgroundColor: alpha(getStatusColor(project.status), 0.1),
                                color: getStatusColor(project.status),
                                fontWeight: 600,
                              }}
                            />
                          </Box>
                          <Typography
                            variant="body2"
                            sx={{ color: theme.palette.text.secondary, mb: 2 }}
                          >
                            {project.description}
                          </Typography>
                          <Box sx={{ mb: 1 }}>
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                              <Typography variant="caption" sx={{ color: theme.palette.text.secondary }}>
                                Progress
                              </Typography>
                              <Typography variant="caption" sx={{ fontWeight: 600 }}>
                                {project.progress}%
                              </Typography>
                            </Box>
                            <LinearProgress
                              variant="determinate"
                              value={project.progress}
                              sx={{
                                height: 6,
                                borderRadius: 3,
                                backgroundColor: alpha(theme.palette.grey[500], 0.2),
                                '& .MuiLinearProgress-bar': {
                                  borderRadius: 3,
                                  backgroundColor: getStatusColor(project.status),
                                },
                              }}
                            />
                          </Box>
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Typography variant="caption" sx={{ color: theme.palette.text.secondary }}>
                              {project.members?.length || 0} members
                            </Typography>
                            {project.deadline && (
                              <Typography variant="caption" sx={{ color: theme.palette.text.secondary }}>
                                Due {new Date(project.deadline).toLocaleDateString()}
                              </Typography>
                            )}
                          </Box>
                        </Box>
                      </motion.div>
                    ))}
                  </Box>
                ) : (
                  <Box sx={{ textAlign: 'center', py: 4 }}>
                    <ProjectIcon sx={{ fontSize: 48, color: theme.palette.text.disabled, mb: 2 }} />
                    <Typography variant="body1" sx={{ color: theme.palette.text.secondary, mb: 2 }}>
                      No projects yet
                    </Typography>
                    <Button
                      variant="contained"
                      startIcon={<AddIcon />}
                      onClick={() => navigate('/projects/new')}
                    >
                      Create Your First Project
                    </Button>
                  </Box>
                )}
              </CardContent>
            </Card>
          </motion.div>
        </Grid>

        {/* Sidebar Content */}
        <Grid item xs={12} lg={4}>
          {/* Recent Teams */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.6, delay: 0.3 }}
          >
            <Card sx={{ mb: 3 }}>
              <CardContent>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                  <Typography variant="h6" sx={{ fontWeight: 600 }}>
                    Your Teams
                  </Typography>
                  <Button
                    size="small"
                    onClick={() => navigate('/teams')}
                    sx={{ textTransform: 'none' }}
                  >
                    View All
                  </Button>
                </Box>

                {loading ? (
                  <Box>
                    {[1, 2, 3].map((item) => (
                      <Box key={item} sx={{ mb: 2, display: 'flex', alignItems: 'center' }}>
                        <Skeleton variant="circular" width={40} height={40} sx={{ mr: 2 }} />
                        <Box sx={{ flex: 1 }}>
                          <Skeleton variant="text" width="70%" />
                          <Skeleton variant="text" width="50%" />
                        </Box>
                      </Box>
                    ))}
                  </Box>
                ) : recentTeams.length > 0 ? (
                  <List>
                    {recentTeams.slice(0, 4).map((team, index) => (
                      <motion.div
                        key={team.id}
                        initial={{ opacity: 0, x: 20 }}
                        animate={{ opacity: 1, x: 0 }}
                        transition={{ duration: 0.4, delay: index * 0.1 }}
                      >
                        <ListItem
                          sx={{
                            px: 0,
                            py: 1.5,
                            '&:hover': {
                              backgroundColor: alpha(theme.palette.action.hover, 0.05),
                              cursor: 'pointer',
                            },
                          }}
                          onClick={() => navigate(`/teams/${team.id}`)}
                        >
                          <ListItemAvatar>
                            <Avatar
                              sx={{
                                bgcolor: alpha(theme.palette.primary.main, 0.1),
                                color: theme.palette.primary.main,
                              }}
                            >
                              {team.name.charAt(0)}
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText
                            primary={team.name}
                            secondary={`${team.members?.length || 0} members • ${team.projects?.length || 0} projects`}
                            primaryTypographyProps={{ fontWeight: 600 }}
                          />
                          <ListItemSecondaryAction>
                            <IconButton edge="end" size="small">
                              <MoreIcon />
                            </IconButton>
                          </ListItemSecondaryAction>
                        </ListItem>
                      </motion.div>
                    ))}
                  </List>
                ) : (
                  <Box sx={{ textAlign: 'center', py: 3 }}>
                    <PeopleIcon sx={{ fontSize: 40, color: theme.palette.text.disabled, mb: 1 }} />
                    <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>
                      No teams yet
                    </Typography>
                  </Box>
                )}
              </CardContent>
            </Card>
          </motion.div>

          {/* Recent Activity */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.6, delay: 0.4 }}
          >
            <Card>
              <CardContent>
                <Typography variant="h6" sx={{ fontWeight: 600, mb: 2 }}>
                  Recent Activity
                </Typography>

                <List>
                  {recentActivity.map((activity, index) => (
                    <motion.div
                      key={activity.id}
                      initial={{ opacity: 0, x: 20 }}
                      animate={{ opacity: 1, x: 0 }}
                      transition={{ duration: 0.4, delay: index * 0.1 }}
                    >
                      <ListItem sx={{ px: 0, py: 1.5 }}>
                        <ListItemAvatar>
                          <Avatar sx={{ width: 32, height: 32 }}>
                            {getActivityIcon(activity.type)}
                          </Avatar>
                        </ListItemAvatar>
                        <ListItemText
                          primary={activity.title}
                          secondary={
                            <Box>
                              <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>
                                {activity.description}
                              </Typography>
                              <Typography variant="caption" sx={{ color: theme.palette.text.disabled }}>
                                {activity.timestamp}
                              </Typography>
                            </Box>
                          }
                          primaryTypographyProps={{ fontWeight: 600, fontSize: '0.875rem' }}
                        />
                      </ListItem>
                    </motion.div>
                  ))}
                </List>
              </CardContent>
            </Card>
          </motion.div>
        </Grid>
      </Grid>
    </Box>
  );
};

export default Dashboard;
</file>

<file path="frontend/src/pages/Profile/Profile.jsx">
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import {
  Grid,
  Card,
  CardContent,
  Typography,
  TextField,
  Button,
  Avatar,
  Box,
  Chip,
  IconButton,
} from '@mui/material';
import {
  Edit,
  Save,
  Cancel,
  PhotoCamera,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import toast from 'react-hot-toast';
import Layout from '../../components/Layout/Layout';
import { setUser } from '../../store/slices/authSlice';
import { updateUserProfile, selectUserLoading } from '../../store/slices/userSlice';
import { useAppDispatch } from '../../store/store'; // Import useAppDispatch

const schema = yup.object({
  firstName: yup.string().required('First name is required'),
  lastName: yup.string().required('Last name is required'),
  email: yup.string().email('Invalid email').required('Email is required'),
});

const Profile = () => {
  const dispatch = useAppDispatch(); // Use the typed dispatch
  const { user } = useSelector((state) => state.auth);
  const isLoading = useSelector(selectUserLoading);
  
  const [isEditing, setIsEditing] = useState(false);
  const [profileImage, setProfileImage] = useState(null);

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm({
    resolver: yupResolver(schema),
  });

  // Set default form values when user data is available
  useEffect(() => {
    if (user) {
        reset({
            firstName: user.firstName || '',
            lastName: user.lastName || '',
            email: user.email || '',
        });
    }
  }, [user, reset]);


  const handleEdit = () => {
    setIsEditing(true);
  };

  const handleCancel = () => {
    setIsEditing(false);
    reset();
  };

  const onSubmit = async (data) => {
    if (!user) return;
    try {
      const resultAction = await dispatch(updateUserProfile({ id: user.id, userData: data }));
      if (updateUserProfile.fulfilled.match(resultAction)) {
        dispatch(setUser(resultAction.payload));
        toast.success('Profile updated successfully!');
        setIsEditing(false);
      } else {
        toast.error(resultAction.payload || 'Failed to update profile');
      }
    } catch (error) {
      toast.error('An unexpected error occurred.');
    }
  };
  
  const handleImageChange = (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onloadend = () => {
            setProfileImage(reader.result);
            toast.success("Profile picture updated (preview). Upload functionality coming soon!");
        };
        reader.readAsDataURL(file);
    }
  };

  return (
    <Layout>
      <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }}>
        <Typography variant="h4" fontWeight="bold" gutterBottom>Profile Settings</Typography>
        <Typography variant="body1" color="text.secondary" sx={{ mb: 4 }}>Manage your personal information and account settings.</Typography>

        <Grid container spacing={3}>
          <Grid item xs={12} md={4}>
            <Card><CardContent sx={{ textAlign: 'center' }}>
              <Box position="relative" display="inline-block" mb={2}>
                <Avatar src={profileImage || user?.profilePicture} sx={{ width: 120, height: 120, mx: 'auto' }}>
                  {user?.username?.charAt(0).toUpperCase()}
                </Avatar>
                <IconButton component="label" sx={{ position: 'absolute', bottom: 0, right: 0, bgcolor: 'primary.main', color: 'white', '&:hover': { bgcolor: 'primary.dark' } }}>
                  <PhotoCamera />
                  <input type="file" hidden accept="image/*" onChange={handleImageChange} />
                </IconButton>
              </Box>
              <Typography variant="h6" gutterBottom>{user?.firstName} {user?.lastName}</Typography>
              <Typography variant="body2" color="text.secondary" gutterBottom>@{user?.username}</Typography>
              <Box mt={1}>
                {user?.roles?.map((role) => (
                  <Chip key={role.id} label={role.name.replace('ROLE_', '')} size="small" color={role.name === 'ROLE_ADMIN' ? 'error' : role.name === 'ROLE_MANAGER' ? 'warning' : 'primary'} />
                ))}
              </Box>
            </CardContent></Card>
          </Grid>
          <Grid item xs={12} md={8}>
            <Card><CardContent>
              <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
                <Typography variant="h6">Personal Information</Typography>
                {!isEditing ? (
                  <Button startIcon={<Edit />} onClick={handleEdit}>Edit Profile</Button>
                ) : (
                  <Box display="flex" gap={1}>
                    <Button onClick={handleCancel} color="inherit">Cancel</Button>
                    <Button startIcon={<Save />} onClick={handleSubmit(onSubmit)} variant="contained" disabled={isLoading}>{isLoading ? 'Saving...' : 'Save Changes'}</Button>
                  </Box>
                )}
              </Box>
              {isEditing ? (
                <Box component="form" onSubmit={handleSubmit(onSubmit)}>
                  <Grid container spacing={2}>
                    <Grid item xs={12} sm={6}><TextField fullWidth label="First Name" {...register('firstName')} error={!!errors.firstName} helperText={errors.firstName?.message} /></Grid>
                    <Grid item xs={12} sm={6}><TextField fullWidth label="Last Name" {...register('lastName')} error={!!errors.lastName} helperText={errors.lastName?.message} /></Grid>
                    <Grid item xs={12}><TextField fullWidth label="Email" {...register('email')} error={!!errors.email} helperText={errors.email?.message} /></Grid>
                  </Grid>
                </Box>
              ) : (
                <Grid container spacing={2} sx={{ p: 2 }}>
                  <Grid item xs={12} sm={6}><Typography variant="body2" color="text.secondary">Full Name</Typography><Typography>{user?.firstName} {user?.lastName}</Typography></Grid>
                  <Grid item xs={12} sm={6}><Typography variant="body2" color="text.secondary">Email Address</Typography><Typography>{user?.email}</Typography></Grid>
                  <Grid item xs={12} sm={6}><Typography variant="body2" color="text.secondary">Username</Typography><Typography>@{user?.username}</Typography></Grid>
                  <Grid item xs={12} sm={6}><Typography variant="body2" color="text.secondary">Member Since</Typography><Typography>{user?.createdAt ? new Date(user.createdAt).toLocaleDateString() : 'N/A'}</Typography></Grid>
                </Grid>
              )}
            </CardContent></Card>
          </Grid>
        </Grid>
      </motion.div>
    </Layout>
  );
};

export default Profile;
</file>

<file path="frontend/src/pages/Settings/Settings.jsx">
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  Grid,
  Card,
  CardContent,
  Typography,
  Switch,
  Divider,
  Box,
  Button,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  Alert,
} from '@mui/material';
import {
  DarkMode,
  Notifications,
  Security,
  Storage,
  Delete,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import Layout from '../../components/Layout/Layout';
import { toggleTheme, selectEffectiveTheme } from '../../store/slices/themeSlice';

const Settings = () => {
  const dispatch = useDispatch();
  const effectiveTheme = useSelector(selectEffectiveTheme);
  const { user } = useSelector((state) => state.auth);

  const handleThemeToggle = () => {
    dispatch(toggleTheme());
  };

  const settingsCategories = [
    {
      title: 'Appearance',
      icon: <DarkMode />,
      settings: [
        {
          label: 'Dark Mode',
          description: 'Toggle between light and dark theme',
          control: (
            <Switch
              checked={effectiveTheme === 'dark'}
              onChange={handleThemeToggle}
              color="primary"
            />
          ),
        },
      ],
    },
    {
      title: 'Notifications',
      icon: <Notifications />,
      settings: [
        {
          label: 'Email Notifications',
          description: 'Receive notifications via email',
          control: <Switch defaultChecked color="primary" />,
        },
        {
          label: 'Push Notifications',
          description: 'Receive push notifications in browser',
          control: <Switch defaultChecked color="primary" />,
        },
      ],
    },
    {
      title: 'Privacy & Security',
      icon: <Security />,
      settings: [
        {
          label: 'Two-Factor Authentication',
          description: 'Add an extra layer of security',
          control: <Button variant="outlined" size="small">Enable</Button>,
        },
      ],
    },
  ];

  return (
    <Layout>
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
      >
        <Typography variant="h4" fontWeight="bold" gutterBottom>
          Settings
        </Typography>
        <Typography variant="body1" color="text.secondary" sx={{ mb: 4 }}>
          Customize your experience and manage your preferences.
        </Typography>

        <Grid container spacing={3}>
          {settingsCategories.map((category, index) => (
            <Grid item xs={12} key={category.title}>
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: index * 0.1 }}
              >
                <Card>
                  <CardContent>
                    <Box display="flex" alignItems="center" mb={2}>
                      {category.icon}
                      <Typography variant="h6" sx={{ ml: 1 }}>
                        {category.title}
                      </Typography>
                    </Box>
                    <Divider sx={{ mb: 2 }} />
                    <List>
                      {category.settings.map((setting, settingIndex) => (
                        <ListItem key={settingIndex} divider={settingIndex < category.settings.length - 1}>
                          <ListItemText
                            primary={setting.label}
                            secondary={setting.description}
                          />
                          <ListItemSecondaryAction>
                            {setting.control}
                          </ListItemSecondaryAction>
                        </ListItem>
                      ))}
                    </List>
                  </CardContent>
                </Card>
              </motion.div>
            </Grid>
          ))}

          {/* Danger Zone */}
          <Grid item xs={12}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.4 }}
            >
              <Card sx={{ border: '1px solid', borderColor: 'error.main' }}>
                <CardContent>
                  <Box display="flex" alignItems="center" mb={2}>
                    <Delete color="error" />
                    <Typography variant="h6" sx={{ ml: 1 }} color="error">
                      Danger Zone
                    </Typography>
                  </Box>
                  <Divider sx={{ mb: 2 }} />
                  <Alert severity="warning" sx={{ mb: 2 }}>
                    This action is irreversible. Please proceed with caution.
                  </Alert>
                  <Box>
                    <Box display="flex" justifyContent="space-between" alignItems="center">
                      <Box>
                        <Typography variant="body1" fontWeight="medium">
                          Delete Account
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                          Permanently delete your account and all data.
                        </Typography>
                      </Box>
                      <Button variant="outlined" color="error">
                        Delete My Account
                      </Button>
                    </Box>
                  </Box>
                </CardContent>
              </Card>
            </motion.div>
          </Grid>
        </Grid>
      </motion.div>
    </Layout>
  );
};

export default Settings;
</file>

<file path="frontend/src/services/apiClient.ts">
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import { config } from '../config/environment';
import { ApiResponse, ApiError } from '../types';

class ApiClient {
  private instance: AxiosInstance;

  constructor() {
    this.instance = axios.create({
      baseURL: '/',
      timeout: 15000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    // Request interceptor to add auth token
    this.instance.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('token');
        if (token && config.headers) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );

    // Response interceptor for error handling
    this.instance.interceptors.response.use(
      (response: AxiosResponse) => {
        return response;
      },
      (error: AxiosError) => {
        if (error.response) {
          const { status, data } = error.response;
          
          // Handle specific error cases
          if (status === 401) {
            // Unauthorized - token might be expired
            localStorage.removeItem('token');
            window.location.href = '/login';
            return Promise.reject(new Error('Session expired. Please login again.'));
          }
          
          if (status === 403) {
            return Promise.reject(new Error('Access denied. Insufficient permissions.'));
          }
          
          if (status === 404) {
            return Promise.reject(new Error('Resource not found.'));
          }
          
          if (status >= 500) {
            return Promise.reject(new Error('Server error. Please try again later.'));
          }
          
          // Extract error message from response
          const errorMessage = (data as any)?.message || (data as any)?.error || 'An error occurred';
          return Promise.reject(new Error(errorMessage));
        }
        
        if (error.request) {
          return Promise.reject(new Error('Network error. Please check your connection.'));
        }
        
        return Promise.reject(new Error('Request failed. Please try again.'));
      }
    );
  }

  public async get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.get<T>(url, config);
    return response.data;
  }

  public async post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.post<T>(url, data, config);
    return response.data;
  }

  public async put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.put<T>(url, data, config);
    return response.data;
  }

  public async patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.patch<T>(url, data, config);
    return response.data;
  }

  public async delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.delete<T>(url, config);
    return response.data;
  }

  public async upload<T = any>(url: string, formData: FormData, onProgress?: (progress: number) => void): Promise<T> {
    const response = await this.instance.post<T>(url, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
          onProgress(progress);
        }
      },
    });
    return response.data;
  }

  // Method to update auth token
  public setAuthToken(token: string): void {
    if (token) {
      this.instance.defaults.headers.common['Authorization'] = `Bearer ${token}`;
    } else {
      delete this.instance.defaults.headers.common['Authorization'];
    }
  }

  // Method to clear auth token
  public clearAuthToken(): void {
    delete this.instance.defaults.headers.common['Authorization'];
  }

  // Get raw axios instance for advanced usage
  public getInstance(): AxiosInstance {
    return this.instance;
  }
}

const apiClient = new ApiClient();
export default apiClient;
</file>

<file path="frontend/src/services/authService.ts">
import apiClient from './apiClient';
import { endpoints } from '../config/environment';
import { LoginRequest, SignupRequest, AuthResponse, User } from '../types';

export const login = async (credentials: LoginRequest): Promise<AuthResponse> => {
  const response = await apiClient.post(endpoints.auth.signin, credentials);
  return response;
};

export const signup = async (userData: SignupRequest): Promise<{ message: string }> => {
  const response = await apiClient.post(endpoints.auth.signup, userData);
  return response;
};

export const getCurrentUser = async (): Promise<User> => {
  const response = await apiClient.get('/api/users/me'); 
  return response;
};

export const verifyEmail = async (data: { code: string }): Promise<{ message: string }> => {
    return apiClient.post('/api/auth/verify-email', data);
};

export const resendVerificationEmail = async (data: { email: string }): Promise<{ message: string }> => {
    return apiClient.post('/api/auth/resend-verification', data);
};

export const forgotPassword = async (data: { email: string }): Promise<{ message: string }> => {
    return apiClient.post('/api/auth/forgot-password', data);
};

export const verifyResetCode = async (data: { email: string, code: string }): Promise<{ message: string }> => {
    return apiClient.post('/api/auth/verify-reset-code', data);
};

export const resetPassword = async (data: { email: string, code: string, newPassword: string }): Promise<{ message: string }> => {
    return apiClient.post('/api/auth/reset-password', data);
};


export const updateProfile = async (userData: Partial<User>): Promise<User> => {
  const response = await apiClient.put('/api/users/me', userData);
  return response;
};

export const uploadAvatar = async (file: File): Promise<string> => {
  const formData = new FormData();
  formData.append('avatar', file);
  
  const response = await apiClient.upload('/api/users/me/avatar', formData);
  return response.avatarUrl || response.url;
};

export const changePassword = async (currentPassword: string, newPassword: string): Promise<{ message: string }> => {
  const response = await apiClient.put('/api/users/me/password', {
    currentPassword,
    newPassword,
  });
  return response;
};

export const logout = (): void => {
  localStorage.removeItem('token');
  apiClient.clearAuthToken();
};
</file>

<file path="frontend/src/store/slices/themeSlice.ts">
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { ThemeMode } from '../../types';

interface ThemeState {
  mode: ThemeMode;
  systemPrefersDark: boolean;
}

// Get initial theme from localStorage or system preference
const getInitialTheme = (): ThemeMode => {
  const saved = localStorage.getItem('themeMode') as ThemeMode;
  if (saved && ['light', 'dark', 'system'].includes(saved)) {
    return saved;
  }
  return 'system';
};

const initialState: ThemeState = {
  mode: getInitialTheme(),
  systemPrefersDark: window.matchMedia('(prefers-color-scheme: dark)').matches,
};

const themeSlice = createSlice({
  name: 'theme',
  initialState,
  reducers: {
    setThemeMode: (state, action: PayloadAction<ThemeMode>) => {
      state.mode = action.payload;
      localStorage.setItem('themeMode', action.payload);
    },
    setSystemPrefersDark: (state, action: PayloadAction<boolean>) => {
      state.systemPrefersDark = action.payload;
    },
    toggleTheme: (state) => {
      if (state.mode === 'light') {
        state.mode = 'dark';
      } else if (state.mode === 'dark') {
        state.mode = 'light';
      } else {
        // If system, toggle to opposite of current system preference
        state.mode = state.systemPrefersDark ? 'light' : 'dark';
      }
      localStorage.setItem('themeMode', state.mode);
    },
  },
});

export const { setThemeMode, setSystemPrefersDark, toggleTheme } = themeSlice.actions;

// Selectors
export const selectTheme = (state: { theme: ThemeState }) => state.theme;
export const selectThemeMode = (state: { theme: ThemeState }) => state.theme.mode;
export const selectEffectiveTheme = (state: { theme: ThemeState }) => {
  if (state.theme.mode === 'system') {
    return state.theme.systemPrefersDark ? 'dark' : 'light';
  }
  return state.theme.mode;
};

export default themeSlice.reducer;
</file>

<file path="frontend/src/store/slices/uiSlice.ts">
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { LoadingState, ErrorState, Notification } from '../../types';

interface UiState {
  loading: LoadingState;
  errors: ErrorState;
  notifications: Notification[];
  sidebarOpen: boolean;
  mobileSidebarOpen: boolean;
  pageTitle: string;
  breadcrumbs: BreadcrumbItem[];
}

interface BreadcrumbItem {
  label: string;
  path?: string;
  icon?: string;
}

const initialState: UiState = {
  loading: {},
  errors: {},
  notifications: [],
  sidebarOpen: true,
  mobileSidebarOpen: false,
  pageTitle: 'Collabris',
  breadcrumbs: [],
};

const uiSlice = createSlice({
  name: 'ui',
  initialState,
  reducers: {
    setLoading: (state, action: PayloadAction<{ key: string; value: boolean }>) => {
      state.loading[action.payload.key] = action.payload.value;
    },
    clearLoading: (state, action: PayloadAction<string>) => {
      delete state.loading[action.payload];
    },
    setError: (state, action: PayloadAction<{ key: string; value: string | null }>) => {
      state.errors[action.payload.key] = action.payload.value;
    },
    clearError: (state, action: PayloadAction<string>) => {
      delete state.errors[action.payload];
    },
    clearAllErrors: (state) => {
      state.errors = {};
    },
    addNotification: (state, action: PayloadAction<Omit<Notification, 'id'>>) => {
      const notification: Notification = {
        ...action.payload,
        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
      };
      state.notifications.push(notification);
    },
    removeNotification: (state, action: PayloadAction<string>) => {
      state.notifications = state.notifications.filter(n => n.id !== action.payload);
    },
    clearAllNotifications: (state) => {
      state.notifications = [];
    },
    toggleSidebar: (state) => {
      state.sidebarOpen = !state.sidebarOpen;
    },
    setSidebarOpen: (state, action: PayloadAction<boolean>) => {
      state.sidebarOpen = action.payload;
    },
    toggleMobileSidebar: (state) => {
      state.mobileSidebarOpen = !state.mobileSidebarOpen;
    },
    setMobileSidebarOpen: (state, action: PayloadAction<boolean>) => {
      state.mobileSidebarOpen = action.payload;
    },
    setPageTitle: (state, action: PayloadAction<string>) => {
      state.pageTitle = action.payload;
    },
    setBreadcrumbs: (state, action: PayloadAction<BreadcrumbItem[]>) => {
      state.breadcrumbs = action.payload;
    },
  },
});

export const {
  setLoading,
  clearLoading,
  setError,
  clearError,
  clearAllErrors,
  addNotification,
  removeNotification,
  clearAllNotifications,
  toggleSidebar,
  setSidebarOpen,
  toggleMobileSidebar,
  setMobileSidebarOpen,
  setPageTitle,
  setBreadcrumbs,
} = uiSlice.actions;

// Selectors
export const selectUi = (state: { ui: UiState }) => state.ui;
export const selectLoading = (key: string) => (state: { ui: UiState }) => state.ui.loading[key] || false;
export const selectError = (key: string) => (state: { ui: UiState }) => state.ui.errors[key] || null;
export const selectNotifications = (state: { ui: UiState }) => state.ui.notifications;
export const selectSidebarOpen = (state: { ui: UiState }) => state.ui.sidebarOpen;
export const selectMobileSidebarOpen = (state: { ui: UiState }) => state.ui.mobileSidebarOpen;
export const selectPageTitle = (state: { ui: UiState }) => state.ui.pageTitle;
export const selectBreadcrumbs = (state: { ui: UiState }) => state.ui.breadcrumbs;

// Helper action creators
export const showNotification = (notification: Omit<Notification, 'id'>) => addNotification(notification);
export const showSuccessNotification = (title: string, message: string) => 
  addNotification({ type: 'success', title, message });
export const showErrorNotification = (title: string, message: string) => 
  addNotification({ type: 'error', title, message });
export const showWarningNotification = (title: string, message: string) => 
  addNotification({ type: 'warning', title, message });
export const showInfoNotification = (title: string, message: string) => 
  addNotification({ type: 'info', title, message });

export type { BreadcrumbItem };
export default uiSlice.reducer;
</file>

<file path="frontend/src/store/slices/userSlice.ts">
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { User, PaginatedResponse } from '../../types';
import * as userService from '../../services/userService';
import { RootState } from '../store';

interface UserState {
  users: User[];
  selectedUser: User | null;
  isLoading: boolean;
  error: string | null;
}

const initialState: UserState = {
  users: [],
  selectedUser: null,
  isLoading: false,
  error: null,
};

// Async thunks
export const fetchUsers = createAsyncThunk<User[], void, { rejectValue: string }>(
  'users/fetchAll',
  async (_, { rejectWithValue }) => {
    try {
      // The service returns a PaginatedResponse, so we extract the content
      const response: PaginatedResponse<User> = await userService.getAllUsers();
      return response.content;
    } catch (error: any) {
      return rejectWithValue(error.message || 'Failed to fetch users');
    }
  }
);

export const updateUserProfile = createAsyncThunk<User, { id: number; userData: Partial<User> }, { rejectValue: string }>(
  'users/updateProfile',
  async ({ id, userData }, { rejectWithValue }) => {
    try {
      const updatedUser = await userService.updateUser(id, userData);
      return updatedUser;
    } catch (error: any) {
      return rejectWithValue(error.message || 'Failed to update user profile');
    }
  }
);

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    // Fetch all users
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action: PayloadAction<User[]>) => {
        state.isLoading = false;
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });

    // Update user profile
    builder
      .addCase(updateUserProfile.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(updateUserProfile.fulfilled, (state, action: PayloadAction<User>) => {
        state.isLoading = false;
        const index = state.users.findIndex(u => u.id === action.payload.id);
        if (index !== -1) {
          state.users[index] = action.payload;
        }
        if (state.selectedUser && state.selectedUser.id === action.payload.id) {
            state.selectedUser = action.payload;
        }
      })
      .addCase(updateUserProfile.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
  },
});

export const { clearError } = userSlice.actions;

// Selectors
export const selectAllUsers = (state: RootState) => state.user.users;
export const selectUserLoading = (state: RootState) => state.user.isLoading;
export const selectUserError = (state: RootState) => state.user.error;

export default userSlice.reducer;
</file>

<file path="frontend/src/store/store.ts">
import { configureStore } from '@reduxjs/toolkit';
import { useDispatch, useSelector, TypedUseSelectorHook } from 'react-redux';
import authReducer from './slices/authSlice';
import themeReducer from './slices/themeSlice';
import uiReducer from './slices/uiSlice';
import userReducer from './slices/userSlice'; // Import the new reducer

export const store = configureStore({
  reducer: {
    auth: authReducer,
    theme: themeReducer,
    ui: uiReducer,
    user: userReducer, // Add the user reducer to the store
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: false,
    }),
  devTools: process.env.NODE_ENV !== 'production',
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

export default store;
</file>

<file path="frontend/src/theme/customStyles.css">
/* Google Fonts Import */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

/* Custom animations */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideInLeft {
  from {
    opacity: 0;
    transform: translateX(-30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
}

@keyframes shimmer {
  0% {
    background-position: -200px 0;
  }
  100% {
    background-position: calc(200px + 100%) 0;
  }
}

/* Utility classes */
.animate-fade-in {
  animation: fadeIn 0.6s ease-out;
}

.animate-slide-right {
  animation: slideInRight 0.5s ease-out;
}

.animate-slide-left {
  animation: slideInLeft 0.5s ease-out;
}

.animate-pulse {
  animation: pulse 2s infinite;
}

/* Loading skeleton */
.skeleton {
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200px 100%;
  animation: shimmer 1.5s infinite;
}

.skeleton-dark {
  background: linear-gradient(90deg, #2d3748 25%, #4a5568 50%, #2d3748 75%);
  background-size: 200px 100%;
  animation: shimmer 1.5s infinite;
}

/* Custom scrollbar */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.1);
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.2);
}

/* Gradient backgrounds */
.gradient-bg-primary {
  background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
}

.gradient-bg-secondary {
  background: linear-gradient(135deg, #7c3aed 0%, #ec4899 100%);
}

.gradient-bg-success {
  background: linear-gradient(135deg, #059669 0%, #22c55e 100%);
}

.gradient-text-primary {
  background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* Glass morphism effect */
.glass-effect {
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.glass-effect-dark {
  background: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

/* Hover effects */
.hover-lift {
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.hover-lift:hover {
  transform: translateY(-2px);
  box-shadow: 0px 10px 15px -3px rgba(0, 0, 0, 0.1), 0px 4px 6px -2px rgba(0, 0, 0, 0.05);
}

.hover-scale {
  transition: transform 0.2s ease-in-out;
}

.hover-scale:hover {
  transform: scale(1.02);
}

/* Image overlay effects */
.image-overlay {
  position: relative;
  overflow: hidden;
}

.image-overlay::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(135deg, rgba(37, 99, 235, 0.8) 0%, rgba(124, 58, 237, 0.8) 100%);
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}

.image-overlay:hover::after {
  opacity: 1;
}

/* Custom button styles */
.btn-gradient {
  background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
  border: none;
  color: white;
  transition: all 0.3s ease;
}

.btn-gradient:hover {
  background: linear-gradient(135deg, #1d4ed8 0%, #6d28d9 100%);
  transform: translateY(-1px);
  box-shadow: 0px 8px 15px rgba(37, 99, 235, 0.3);
}

/* Chat bubble animations */
.chat-message {
  animation: fadeIn 0.3s ease-out;
}

.chat-message.own {
  animation: slideInRight 0.3s ease-out;
}

.chat-message.other {
  animation: slideInLeft 0.3s ease-out;
}

/* Notification animations */
.notification-enter {
  opacity: 0;
  transform: translateY(-50px) scale(0.8);
}

.notification-enter-active {
  opacity: 1;
  transform: translateY(0) scale(1);
  transition: all 0.3s ease-out;
}

.notification-exit {
  opacity: 1;
  transform: translateY(0) scale(1);
}

.notification-exit-active {
  opacity: 0;
  transform: translateY(-50px) scale(0.8);
  transition: all 0.3s ease-in;
}

/* Page transition styles */
.page-transition-enter {
  opacity: 0;
  transform: translateY(20px);
}

.page-transition-enter-active {
  opacity: 1;
  transform: translateY(0);
  transition: all 0.4s ease-out;
}

.page-transition-exit {
  opacity: 1;
  transform: translateY(0);
}

.page-transition-exit-active {
  opacity: 0;
  transform: translateY(-20px);
  transition: all 0.3s ease-in;
}

/* Responsive utilities */
@media (max-width: 640px) {
  .mobile-hidden {
    display: none !important;
  }
}

@media (min-width: 641px) {
  .mobile-only {
    display: none !important;
  }
}

/* Print styles */
@media print {
  .no-print {
    display: none !important;
  }
}
</file>

<file path="frontend/src/theme/theme.ts">
import { createTheme, ThemeOptions } from '@mui/material/styles';
import { PaletteMode } from '@mui/material';

// Collabris color palette
const collabrisColors = {
  primary: {
    main: '#2563eb', // Blue
    light: '#3b82f6',
    dark: '#1d4ed8',
    contrastText: '#ffffff',
  },
  secondary: {
    main: '#7c3aed', // Purple
    light: '#8b5cf6',
    dark: '#6d28d9',
    contrastText: '#ffffff',
  },
  accent: {
    main: '#059669', // Green
    light: '#10b981',
    dark: '#047857',
  },
  warning: {
    main: '#f59e0b',
    light: '#fbbf24',
    dark: '#d97706',
  },
  error: {
    main: '#ef4444',
    light: '#f87171',
    dark: '#dc2626',
  },
  success: {
    main: '#22c55e',
    light: '#4ade80',
    dark: '#16a34a',
  },
};

const getDesignTokens = (mode: PaletteMode): ThemeOptions => ({
  palette: {
    mode,
    primary: collabrisColors.primary,
    secondary: collabrisColors.secondary,
    error: collabrisColors.error,
    warning: collabrisColors.warning,
    success: collabrisColors.success,
    ...(mode === 'light'
      ? {
          // Light mode
          background: {
            default: '#f8fafc',
            paper: '#ffffff',
          },
          text: {
            primary: '#1e293b',
            secondary: '#64748b',
          },
          divider: '#e2e8f0',
        }
      : {
          // Dark mode
          background: {
            default: '#0f172a',
            paper: '#1e293b',
          },
          text: {
            primary: '#f1f5f9',
            secondary: '#94a3b8',
          },
          divider: '#334155',
        }),
  },
  typography: {
    fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontWeight: 700,
      fontSize: '2.5rem',
      lineHeight: 1.2,
    },
    h2: {
      fontWeight: 600,
      fontSize: '2rem',
      lineHeight: 1.3,
    },
    h3: {
      fontWeight: 600,
      fontSize: '1.5rem',
      lineHeight: 1.4,
    },
    h4: {
      fontWeight: 600,
      fontSize: '1.25rem',
      lineHeight: 1.4,
    },
    h5: {
      fontWeight: 600,
      fontSize: '1.125rem',
      lineHeight: 1.5,
    },
    h6: {
      fontWeight: 600,
      fontSize: '1rem',
      lineHeight: 1.5,
    },
    body1: {
      fontSize: '1rem',
      lineHeight: 1.6,
    },
    body2: {
      fontSize: '0.875rem',
      lineHeight: 1.5,
    },
    button: {
      textTransform: 'none',
      fontWeight: 500,
    },
  },
  shape: {
    borderRadius: 12,
  },
  shadows: [
    'none',
    '0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.06)',
    '0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -1px rgba(0, 0, 0, 0.06)',
    '0px 10px 15px -3px rgba(0, 0, 0, 0.1), 0px 4px 6px -2px rgba(0, 0, 0, 0.05)',
    '0px 20px 25px -5px rgba(0, 0, 0, 0.1), 0px 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '0px 25px 50px -12px rgba(0, 0, 0, 0.25)',
    '0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.06)',
    '0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -1px rgba(0, 0, 0, 0.06)',
    '0px 10px 15px -3px rgba(0, 0, 0, 0.1), 0px 4px 6px -2px rgba(0, 0, 0, 0.05)',
    '0px 20px 25px -5px rgba(0, 0, 0, 0.1), 0px 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '0px 25px 50px -12px rgba(0, 0, 0, 0.25)',
    '0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.06)',
    '0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -1px rgba(0, 0, 0, 0.06)',
    '0px 10px 15px -3px rgba(0, 0, 0, 0.1), 0px 4px 6px -2px rgba(0, 0, 0, 0.05)',
    '0px 20px 25px -5px rgba(0, 0, 0, 0.1), 0px 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '0px 25px 50px -12px rgba(0, 0, 0, 0.25)',
    '0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.06)',
    '0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -1px rgba(0, 0, 0, 0.06)',
    '0px 10px 15px -3px rgba(0, 0, 0, 0.1), 0px 4px 6px -2px rgba(0, 0, 0, 0.05)',
    '0px 20px 25px -5px rgba(0, 0, 0, 0.1), 0px 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '0px 25px 50px -12px rgba(0, 0, 0, 0.25)',
    '0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.06)',
    '0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -1px rgba(0, 0, 0, 0.06)',
    '0px 10px 15px -3px rgba(0, 0, 0, 0.1), 0px 4px 6px -2px rgba(0, 0, 0, 0.05)',
    '0px 20px 25px -5px rgba(0, 0, 0, 0.1), 0px 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '0px 25px 50px -12px rgba(0, 0, 0, 0.25)',
  ],
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          textTransform: 'none',
          fontWeight: 500,
          padding: '8px 16px',
          boxShadow: 'none',
          '&:hover': {
            boxShadow: '0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -1px rgba(0, 0, 0, 0.06)',
          },
        },
        containedPrimary: {
          background: `linear-gradient(135deg, ${collabrisColors.primary.main} 0%, ${collabrisColors.primary.dark} 100%)`,
          '&:hover': {
            background: `linear-gradient(135deg, ${collabrisColors.primary.dark} 0%, ${collabrisColors.primary.main} 100%)`,
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 16,
          border: mode === 'light' ? '1px solid #e2e8f0' : '1px solid #334155',
        },
      },
    },
    MuiTextField: {
      styleOverrides: {
        root: {
          '& .MuiOutlinedInput-root': {
            borderRadius: 8,
          },
        },
      },
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          borderRight: mode === 'light' ? '1px solid #e2e8f0' : '1px solid #334155',
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: mode === 'light' ? '#ffffff' : '#1e293b',
          color: mode === 'light' ? '#1e293b' : '#f1f5f9',
          boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.06)',
        },
      },
    },
  },
});

export const createCollabrisTheme = (mode: PaletteMode) => {
  return createTheme(getDesignTokens(mode));
};

export { collabrisColors };
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,jsx,ts,tsx}",   // all your component files
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Complete Spring Boot Backend for Collabris</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "vite-react-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.57.4",
    "lucide-react": "^0.344.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.18",
    "eslint": "^9.9.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.11",
    "globals": "^15.9.0",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.3.0",
    "vite": "^5.4.2"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="README.md">
# Collabris
</file>

<file path="src/App.tsx">
import React from 'react';

function App() {
  return (
    <div className="min-h-screen bg-gray-100 flex items-center justify-center">
      <p>Start prompting (or editing) to see magic happen :)</p>
    </div>
  );
}

export default App;
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="src/main.tsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {},
  },
  plugins: [],
};
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="backend/src/main/java/com/collabris/config/AdminUserInitializer.java">
package com.collabris.config;

import com.collabris.entity.Role;
import com.collabris.entity.User;
import com.collabris.repository.RoleRepository;
import com.collabris.repository.UserRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

@Component
@Order(2)
public class AdminUserInitializer implements CommandLineRunner {

    private static final Logger logger = LoggerFactory.getLogger(AdminUserInitializer.class);

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    private static final String ADMIN_USERNAME = "Elissa";
    private static final String ADMIN_EMAIL = "sibomanaelissa71@gmail.com";
    private static final String ADMIN_PASSWORD = "Admin@2025";
    private static final String ADMIN_FIRST_NAME = "Elissa";
    private static final String ADMIN_LAST_NAME = "Sibomana";

    @Override
    public void run(String... args) {
        try {
            createAdminUser();
        } catch (Exception e) {
            logger.error("❌ Error occurred while creating admin user: {}", e.getMessage(), e);
        }
    }

    private void createAdminUser() {
        if (userRepository.existsByUsername(ADMIN_USERNAME)) {
            logger.info("⚠️  Admin user '{}' already exists. Skipping creation.", ADMIN_USERNAME);
            return;
        }

        Optional<Role> adminRoleOpt = roleRepository.findByName(Role.ERole.ADMIN);
        if (adminRoleOpt.isEmpty()) {
            logger.error("🚨 FATAL: ADMIN role not found. Admin user cannot be created.");
            return;
        }

        User adminUser = new User(ADMIN_USERNAME, ADMIN_EMAIL, passwordEncoder.encode(ADMIN_PASSWORD));
        adminUser.setFirstName(ADMIN_FIRST_NAME);
        adminUser.setLastName(ADMIN_LAST_NAME);
        adminUser.setEnabled(true);

        Set<Role> roles = new HashSet<>();
        roles.add(adminRoleOpt.get());
        adminUser.setRoles(roles);

        userRepository.save(adminUser);

        logger.info("\n\n" +
                "============================================================\n" +
                "🎉  ADMIN ACCOUNT INITIALIZED SUCCESSFULLY\n" +
                "------------------------------------------------------------\n" +
                "👤 Username : {}\n" +
                "📧 Email    : {}\n" +
                "🔑 Password : {}\n" +
                "------------------------------------------------------------\n" +
                "⚡ You can now log in with this admin account.\n" +
                "============================================================\n",
                ADMIN_USERNAME, ADMIN_EMAIL, ADMIN_PASSWORD);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/config/WebSecurityConfig.java">
package com.collabris.config;

import com.collabris.security.jwt.AuthEntryPointJwt;
import com.collabris.security.jwt.AuthTokenFilter;
import com.collabris.security.services.UserDetailsServiceImpl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableMethodSecurity
public class WebSecurityConfig {

    @Autowired
    private AuthEntryPointJwt unauthorizedHandler;

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    @Bean
    public AuthTokenFilter authenticationJwtTokenFilter() {
        return new AuthTokenFilter();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(passwordEncoder());
        return provider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // ✅ CORS setup allowing your frontend
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:5173")); // ✅ Vite frontend origin
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type", "x-auth-token"));
        configuration.setAllowCredentials(true); // ✅ required for sending tokens

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.cors(cors -> cors.configurationSource(corsConfigurationSource()));

        http.csrf(csrf -> csrf.disable())
                .exceptionHandling(e -> e.authenticationEntryPoint(unauthorizedHandler))
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/auth/**", "/api/test/**", "/swagger-ui/**", "/v3/api-docs/**", "/ws/**").permitAll()
                        .anyRequest().authenticated()
                );

        http.authenticationProvider(authenticationProvider());
        http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
</file>

<file path="backend/src/main/java/com/collabris/config/WebSocketConfig.java">
package com.collabris.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/topic", "/queue");
        config.setApplicationDestinationPrefixes("/app");
        config.setUserDestinationPrefix("/user");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // Native WebSocket endpoint (for ws://)
        registry.addEndpoint("/ws")
                .setAllowedOriginPatterns("*");

        // SockJS fallback (for browsers that can’t handle raw WebSocket)
        registry.addEndpoint("/ws")
                .setAllowedOriginPatterns("*")
                .withSockJS();
    }
}
</file>

<file path="backend/src/main/java/com/collabris/controller/AuthController.java">
package com.collabris.controller;

import com.collabris.dto.request.VerifyEmailRequest; 
import com.collabris.dto.request.LoginRequest;
import com.collabris.dto.request.ResetPasswordConfirmRequest;
import com.collabris.dto.request.ResetPasswordRequest;
import com.collabris.dto.request.SignupRequest;
import com.collabris.dto.response.JwtResponse;
import com.collabris.dto.response.MessageResponse;
import com.collabris.entity.Role;
import com.collabris.entity.User;
import com.collabris.entity.VerificationToken;
import com.collabris.repository.RoleRepository;
import com.collabris.repository.UserRepository;
import com.collabris.security.jwt.JwtUtils;
import com.collabris.security.services.UserPrinciple;
import com.collabris.service.EmailService;
import com.collabris.service.TokenService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
public class AuthController {

    @Autowired
    AuthenticationManager authenticationManager;
    @Autowired
    UserRepository userRepository;
    @Autowired
    RoleRepository roleRepository;
    @Autowired
    PasswordEncoder encoder;
    @Autowired
    JwtUtils jwtUtils;
    @Autowired
    TokenService tokenService;
    @Autowired
    EmailService emailService;

    // ... (signin and signup methods are correct from previous step)

    @PostMapping("/signin")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword()));
        SecurityContextHolder.getContext().setAuthentication(authentication);
        String jwt = jwtUtils.generateJwtToken(authentication);
        UserPrinciple userDetails = (UserPrinciple) authentication.getPrincipal();
        User user = userRepository.findByUsername(userDetails.getUsername())
                .orElseThrow(() -> new RuntimeException("User not found after authentication. This should not happen."));
        if (!user.isEnabled()) {
            return ResponseEntity
                    .badRequest()
                    .body(new MessageResponse("Error: Please verify your email before logging in."));
        }
        return ResponseEntity.ok(new JwtResponse(jwt, user));
    }

    @PostMapping("/signup")
    public ResponseEntity<?> registerUser(@Valid @RequestBody SignupRequest signUpRequest) {
        if (userRepository.existsByUsername(signUpRequest.getUsername())) {
            return ResponseEntity.badRequest().body(new MessageResponse("Error: Username is already taken!"));
        }
        if (userRepository.existsByEmail(signUpRequest.getEmail())) {
            return ResponseEntity.badRequest().body(new MessageResponse("Error: Email is already in use!"));
        }
        User user = new User(signUpRequest.getUsername(), signUpRequest.getEmail(), encoder.encode(signUpRequest.getPassword()));
        user.setFirstName(signUpRequest.getFirstName());
        user.setLastName(signUpRequest.getLastName());
        user.setEnabled(false);
        Set<String> strRoles = signUpRequest.getRole();
        Set<Role> roles = new HashSet<>();
        if (strRoles == null || strRoles.isEmpty()) {
            Role userRole = roleRepository.findByName(Role.ERole.MEMBER)
                    .orElseThrow(() -> new RuntimeException("Error: Role 'MEMBER' is not found."));
            roles.add(userRole);
        } else {
            strRoles.forEach(role -> {
                switch (role.toLowerCase()) {
                    case "admin":
                        Role adminRole = roleRepository.findByName(Role.ERole.ADMIN)
                                .orElseThrow(() -> new RuntimeException("Error: Role 'ADMIN' is not found."));
                        roles.add(adminRole);
                        break;
                    case "manager":
                        Role modRole = roleRepository.findByName(Role.ERole.MANAGER)
                                .orElseThrow(() -> new RuntimeException("Error: Role 'MANAGER' is not found."));
                        roles.add(modRole);
                        break;
                    default:
                        Role userRole = roleRepository.findByName(Role.ERole.MEMBER)
                                .orElseThrow(() -> new RuntimeException("Error: Role 'MEMBER' is not found."));
                        roles.add(userRole);
                        break;
                }
            });
        }
        user.setRoles(roles);
        User savedUser = userRepository.save(user);
        VerificationToken token = tokenService.createVerificationToken(savedUser, VerificationToken.TokenType.EMAIL_VERIFICATION);
        emailService.sendEmail(savedUser.getEmail(), "Verify Your Collabris Account", "templates/email-verification.html",
                Map.of("firstName", savedUser.getFirstName(), "verificationCode", token.getCode()));
        return ResponseEntity.ok(new MessageResponse("User registered successfully! Please verify your email."));
    }

    // --- THIS IS THE FIX ---
    @PostMapping("/verify-email")
    public ResponseEntity<?> verifyEmail(@Valid @RequestBody VerifyEmailRequest request) {
        // The method now correctly accepts a request body with a "code" field.
        String tokenCode = request.getCode();
        
        Optional<VerificationToken> tokenOpt = tokenService.findValidToken(tokenCode, VerificationToken.TokenType.EMAIL_VERIFICATION);
        
        if (tokenOpt.isEmpty()) {
            return ResponseEntity.badRequest().body(new MessageResponse("Invalid or expired token."));
        }

        VerificationToken verificationToken = tokenOpt.get();
        User user = verificationToken.getUser();

        if (user.isEnabled()) {
            return ResponseEntity.badRequest().body(new MessageResponse("Account is already verified."));
        }

        user.setEnabled(true);
        userRepository.save(user);
        tokenService.consumeToken(verificationToken);

        return ResponseEntity.ok(new MessageResponse("Email verified successfully! You can now log in."));
    }

    // ... (password reset methods are correct from previous step)
    @PostMapping("/reset-password-request")
    public ResponseEntity<?> resetPasswordRequest(@Valid @RequestBody ResetPasswordRequest request) {
        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new RuntimeException("User not found with that email."));
        VerificationToken token = tokenService.createVerificationToken(user, VerificationToken.TokenType.PASSWORD_RESET);
        emailService.sendEmail(user.getEmail(), "Collabris Password Reset", "templates/password-reset.html",
                Map.of("firstName", user.getFirstName(), "verificationCode", token.getCode()));
        return ResponseEntity.ok(new MessageResponse("Password reset email sent."));
    }

    @PostMapping("/reset-password")
    public ResponseEntity<?> resetPassword(@Valid @RequestBody ResetPasswordConfirmRequest request) {
        Optional<VerificationToken> tokenOpt = tokenService.findValidToken(request.getToken(), VerificationToken.TokenType.PASSWORD_RESET);
        if (tokenOpt.isEmpty()) {
            return ResponseEntity.badRequest().body(new MessageResponse("Invalid or expired token."));
        }
        VerificationToken verificationToken = tokenOpt.get();
        User user = verificationToken.getUser();
        user.setPassword(encoder.encode(request.getNewPassword()));
        userRepository.save(user);
        tokenService.consumeToken(verificationToken);
        return ResponseEntity.ok(new MessageResponse("Password reset successful!"));
    }
}
</file>

<file path="backend/src/main/java/com/collabris/controller/ChatController.java">
package com.collabris.controller;

import com.collabris.dto.request.ChatMessageRequest;
import com.collabris.dto.response.ChatMessageResponse; // Now correctly imported
import com.collabris.entity.ChatMessage;
import com.collabris.entity.User;
import com.collabris.service.ChatService;
import com.collabris.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.messaging.handler.annotation.DestinationVariable;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

import java.security.Principal;
import java.util.List;

@Controller
public class ChatController {

    @Autowired
    private SimpMessagingTemplate messagingTemplate;
    @Autowired
    private ChatService chatService;
    @Autowired
    private UserService userService;

    // HTTP Endpoint for Message History
    @GetMapping("/api/chat/projects/{projectId}/messages")
    public ResponseEntity<List<ChatMessageResponse>> getProjectMessages(@PathVariable Long projectId) {
        return ResponseEntity.ok(chatService.getMessagesForProject(projectId));
    }

    // WebSocket Endpoint for Sending a New Message
    @MessageMapping("/chat/{projectId}/sendMessage")
    public void sendMessage(@DestinationVariable Long projectId, @Payload ChatMessageRequest chatMessage, Principal principal) {
        if (principal == null) {
            // Should not happen if security is configured correctly, but good to check
            return;
        }
        User sender = userService.findByUsername(principal.getName())
            .orElseThrow(() -> new RuntimeException("Sender not found for authenticated principal"));
            
        ChatMessage savedMessage = chatService.saveMessage(chatMessage.getContent(), projectId, sender);
        
        ChatMessageResponse response = new ChatMessageResponse(savedMessage);

        messagingTemplate.convertAndSend("/topic/project/" + projectId + "/chat", response);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/controller/UserController.java">
// File Path: backend/src/main/java/com/collabris/controller/UserController.java
package com.collabris.controller;

import com.collabris.dto.request.AdminUserUpdateRequest;
import com.collabris.dto.response.MessageResponse;
import com.collabris.dto.response.UserResponse;
import com.collabris.entity.User;
import com.collabris.service.UserService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    // --- EXISTING ENDPOINT (NO CHANGE) ---
    @GetMapping("/me")
    public ResponseEntity<UserResponse> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        if (userDetails == null) {
            return ResponseEntity.status(401).build();
        }
        User user = userService.findByUsername(userDetails.getUsername())
                .orElseThrow(() -> new RuntimeException("Error: Authenticated user not found."));
        return ResponseEntity.ok(new UserResponse(user));
    }

    // --- NEW ADMIN ENDPOINTS ---

    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<UserResponse>> getAllUsers() {
        return ResponseEntity.ok(userService.getAllUsers());
    }
    
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> createUser(@Valid @RequestBody AdminUserUpdateRequest request) {
        try {
            User newUser = userService.createUserByAdmin(request);
            return ResponseEntity.ok(new UserResponse(newUser));
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().body(new MessageResponse(e.getMessage()));
        }
    }

    @PutMapping("/{userId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> updateUser(@PathVariable Long userId, @Valid @RequestBody AdminUserUpdateRequest request) {
        try {
            User updatedUser = userService.updateUserByAdmin(userId, request);
            return ResponseEntity.ok(new UserResponse(updatedUser));
        } catch (RuntimeException e) {
            return ResponseEntity.badRequest().body(new MessageResponse(e.getMessage()));
        }
    }

    @DeleteMapping("/{userId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> deleteUser(@PathVariable Long userId) {
        // Optional: Add logic to prevent an admin from deleting themselves
        userService.deleteUserByAdmin(userId);
        return ResponseEntity.ok(new MessageResponse("User deleted successfully!"));
    }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/AdminUserUpdateRequest.java">
// File path: backend/src/main/java/com/collabris/dto/request/AdminUserUpdateRequest.java
package com.collabris.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.util.Set;

public class AdminUserUpdateRequest {
    @NotBlank
    @Size(min = 3, max = 20)
    private String username;

    @NotBlank
    @Size(max = 50)
    @Email
    private String email;
    
    // Password is optional on update, but may be required on create
    @Size(min = 6, max = 40)
    private String password;
    
    private String firstName;
    private String lastName;
    private Boolean enabled;
    private Set<String> roles;

    // Getters and Setters
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    public Boolean getEnabled() { return enabled; }
    public void setEnabled(Boolean enabled) { this.enabled = enabled; }
    public Set<String> getRoles() { return roles; }
    public void setRoles(Set<String> roles) { this.roles = roles; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/ChatMessageRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;

public class ChatMessageRequest {

    @NotBlank
    private String content;
    
    // No messageType for now, we will just assume TEXT to fix the error.
    
    // Getters and Setters
    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/ProjectRequest.java">
// File path: backend/src/main/java/com/collabris/dto/request/ProjectRequest.java
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class ProjectRequest {
    @NotBlank
    @Size(max = 100)
    private String name;

    @Size(max = 1000)
    private String description;
    
    // Getters and Setters
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/response/ProjectResponse.java">
// File path: backend/src/main/java/com/collabris/dto/response/ProjectResponse.java
package com.collabris.dto.response;

import com.collabris.entity.Project;
import java.time.LocalDateTime;
import java.util.Set;
import java.util.stream.Collectors;

public class ProjectResponse {
    private Long id;
    private String name;
    private String description;
    private UserResponse owner;
    private Set<UserResponse> members;
    private LocalDateTime createdAt;
    
    public ProjectResponse(Project project) {
        this.id = project.getId();
        this.name = project.getName();
        this.description = project.getDescription();
        if(project.getOwner() != null) {
            this.owner = new UserResponse(project.getOwner());
        }
        if(project.getMembers() != null) {
            this.members = project.getMembers().stream()
                .map(UserResponse::new)
                .collect(Collectors.toSet());
        }
        this.createdAt = project.getCreatedAt();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public UserResponse getOwner() { return owner; }
    public void setOwner(UserResponse owner) { this.owner = owner; }
    public Set<UserResponse> getMembers() { return members; }
    public void setMembers(Set<UserResponse> members) { this.members = members; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/User.java">
// File path: backend/src/main/java/com/collabris/entity/User.java
package com.collabris.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    private String firstName;
    private String lastName;
    private String profilePicture;
    private boolean enabled = false;

    // --- THIS IS THE FIX ---
    // Changed FetchType from LAZY (default) to EAGER.
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "user_roles",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "role_id"))
    private Set<Role> roles = new HashSet<>();
    
    @ManyToMany(mappedBy = "members", fetch = FetchType.LAZY)
    private Set<Project> projects = new HashSet<>();

    @ManyToMany(mappedBy = "members", fetch = FetchType.LAZY)
    private Set<Team> teams = new HashSet<>();

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public User() {}

    public User(String username, String email, String password) {
        this.username = username;
        this.email = email;
        this.password = password;
    }
    
    @PrePersist
    protected void onCreate() { this.createdAt = LocalDateTime.now(); }

    @PreUpdate
    protected void onUpdate() { this.updatedAt = LocalDateTime.now(); }

    // --- Getters and Setters (no changes here) ---
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    public String getProfilePicture() { return profilePicture; }
    public void setProfilePicture(String profilePicture) { this.profilePicture = profilePicture; }
    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
    public Set<Role> getRoles() { return roles; }
    public void setRoles(Set<Role> roles) { this.roles = roles; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    public Set<Project> getProjects() { return projects; }
    public void setProjects(Set<Project> projects) { this.projects = projects; }
    public Set<Team> getTeams() { return teams; }
    public void setTeams(Set<Team> teams) { this.teams = teams; }
}
</file>

<file path="backend/src/main/java/com/collabris/repository/UserRepository.java">
package com.collabris.repository;

import com.collabris.entity.Role;
import com.collabris.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    Boolean existsByUsername(String username);
    Boolean existsByEmail(String email);

    @Query("SELECT u FROM User u WHERE u.username LIKE %:search% OR u.email LIKE %:search% OR u.firstName LIKE %:search% OR u.lastName LIKE %:search%")
    List<User> findBySearchTerm(@Param("search") String search);

    @Query("SELECT u FROM User u JOIN u.roles r WHERE r.name = :roleName")
    List<User> findByRoleName(@Param("roleName") String roleName);

    // --- THIS IS THE MISSING METHOD ---
    // This method is required by the DashboardController to count users for the pie chart.
    long countByRoles_Name(Role.ERole roleName);
}
</file>

<file path="backend/src/main/java/com/collabris/service/TeamService.java">
// File path: backend/src/main/java/com/collabris/service/TeamService.java
package com.collabris.service;

import com.collabris.dto.request.TeamRequest;
import com.collabris.dto.response.TeamResponse;
import com.collabris.entity.Team;
import com.collabris.entity.User;
import com.collabris.repository.TeamRepository;
import com.collabris.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

@Service
@Transactional
public class TeamService {

    @Autowired
    private TeamRepository teamRepository;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private SimpMessagingTemplate messagingTemplate;

    public TeamResponse createTeam(TeamRequest teamRequest, User owner) {
        Team team = new Team();
        team.setName(teamRequest.getName());
        team.setDescription(teamRequest.getDescription());
        team.setOwner(owner);
        team.addMember(owner);

        Team savedTeam = teamRepository.save(team);

        long totalTeams = teamRepository.count();
        messagingTemplate.convertAndSend("/topic/dashboard/stats", Map.of("totalTeams", totalTeams));

        return new TeamResponse(savedTeam);
    }

    public TeamResponse getTeamById(Long teamId) {
        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new NoSuchElementException("Team not found with ID: " + teamId));
        return new TeamResponse(team);
    }

    public List<TeamResponse> getTeamsForUser(User user) {
        return teamRepository.findByMemberId(user.getId()).stream()
                .map(TeamResponse::new)
                .collect(Collectors.toList());
    }

    public TeamResponse updateTeam(Long teamId, TeamRequest teamRequest) {
        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new NoSuchElementException("Team not found with ID: " + teamId));
        team.setName(teamRequest.getName());
        team.setDescription(teamRequest.getDescription());
        return new TeamResponse(teamRepository.save(team));
    }

    public void deleteTeam(Long teamId) {
        teamRepository.deleteById(teamId);
        
        long totalTeams = teamRepository.count();
        messagingTemplate.convertAndSend("/topic/dashboard/stats", Map.of("totalTeams", totalTeams));
    }

    public TeamResponse addMemberToTeam(Long teamId, Long userId) {
        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new NoSuchElementException("Team not found with ID: " + teamId));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new NoSuchElementException("User not found with ID: " + userId));
        team.addMember(user);
        return new TeamResponse(teamRepository.save(team));
    }

    public TeamResponse removeMemberFromTeam(Long teamId, Long userId) {
        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new NoSuchElementException("Team not found with ID: " + teamId));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new NoSuchElementException("User not found with ID: " + userId));
        team.removeMember(user);
        return new TeamResponse(teamRepository.save(team));
    }
}
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Collabris</title>
    <script>
      var global = global || window;
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/package.json">
{
  "name": "collabris-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@emotion/react": "^11.11.1",
    "@emotion/styled": "^11.11.0",
    "@hookform/resolvers": "^3.3.2",
    "@mui/icons-material": "^5.15.1",
    "@mui/material": "^5.15.1",
    "@mui/x-charts": "^6.18.1",
    "@mui/x-data-grid": "^6.18.1",
    "@reduxjs/toolkit": "^2.0.1",
    "@stomp/stompjs": "^7.2.1",
    "axios": "^1.6.2",
    "framer-motion": "^10.16.16",
    "lucide-react": "^0.344.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.48.2",
    "react-hot-toast": "^2.4.1",
    "react-icons": "^5.5.0",
    "react-redux": "^9.0.4",
    "react-router-dom": "^6.20.1",
    "recharts": "^2.8.0",
    "sockjs-client": "^1.6.1",
    "stompjs": "^2.3.3",
    "yup": "^1.4.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@types/sockjs-client": "^1.5.4",
    "@vitejs/plugin-react": "^4.7.0",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.9.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.11",
    "globals": "^15.9.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.3.0",
    "vite": "^5.4.20"
  }
}
</file>

<file path="frontend/src/components/Admin/UserTable.jsx">
// File path: frontend/src/components/Admin/UserTable.jsx
import React from 'react';
import {
    Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Paper,
    IconButton, Chip, Typography, Box
} from '@mui/material';
import { Edit as EditIcon, Delete as DeleteIcon } from '@mui/icons-material';

const UserTable = ({ users, onEdit, onDelete }) => {
    return (
        <TableContainer component={Paper}>
            <Table>
                <TableHead>
                    <TableRow>
                        <TableCell>Name</TableCell>
                        <TableCell>Email</TableCell>
                        <TableCell>Roles</TableCell>
                        <TableCell>Status</TableCell>
                        <TableCell>Actions</TableCell>
                    </TableRow>
                </TableHead>
                <TableBody>
                    {users.map((user) => (
                        <TableRow key={user.id}>
                            <TableCell>
                                <Typography variant="subtitle2">{user.firstName} {user.lastName}</Typography>
                                <Typography variant="body2" color="text.secondary">@{user.username}</Typography>
                            </TableCell>
                            <TableCell>{user.email}</TableCell>
                            <TableCell>
                                <Box sx={{ display: 'flex', gap: 0.5 }}>
                                {user.roles.map(role => (
                                    <Chip key={role} label={role} size="small" 
                                        color={role === 'ADMIN' ? 'error' : role === 'MANAGER' ? 'warning' : 'primary'} />
                                ))}
                                </Box>
                            </TableCell>
                            <TableCell>
                                <Chip label={user.enabled ? 'Active' : 'Disabled'} size="small" 
                                    color={user.enabled ? 'success' : 'default'} />
                            </TableCell>
                            <TableCell>
                                <IconButton onClick={() => onEdit(user)}><EditIcon /></IconButton>
                                <IconButton onClick={() => onDelete(user.id)}><DeleteIcon /></IconButton>
                            </TableCell>
                        </TableRow>
                    ))}
                </TableBody>
            </Table>
        </TableContainer>
    );
};

export default UserTable;
</file>

<file path="frontend/src/components/Layout/Layout.tsx">
// File Path: frontend/src/components/Layout/Layout.tsx
import React, { useState, ReactNode } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  AppBar,
  Toolbar,
  Typography,
  IconButton,
  Drawer,
  List,
  ListItemButton, // Use ListItemButton for better click handling
  ListItemIcon,
  ListItemText,
  Box,
  Avatar,
  Menu,
  MenuItem,
  Divider,
  CircularProgress, // Use a proper loading component
} from '@mui/material';
import {
  Menu as MenuIcon,
  Dashboard as DashboardIcon,
  People as PeopleIcon,
  Assignment as AssignmentIcon,
  Settings as SettingsIcon,
} from '@mui/icons-material';
import { Link, useNavigate } from 'react-router-dom';
import { logout, selectUser } from '../../store/slices/authSlice';

const drawerWidth = 240;

// Define the type for the component's props
interface LayoutProps {
  children: ReactNode;
}

const Layout: React.FC<LayoutProps> = ({ children }) => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const user = useSelector(selectUser);
  const [mobileOpen, setMobileOpen] = useState(false);
  
  // Define the type for anchorEl state
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  // Define the type for the menu event
  const handleMenu = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleLogout = () => {
    dispatch(logout());
    // Use replace: true to prevent user from going back to a protected page
    navigate('/login', { replace: true });
    handleClose();
  };

  const menuItems = [
    { text: 'Dashboard', icon: <DashboardIcon />, path: '/dashboard' },
    { text: 'Projects', icon: <AssignmentIcon />, path: '/projects' },
    { text: 'Teams', icon: <PeopleIcon />, path: '/teams' },
    { text: 'Settings', icon: <SettingsIcon />, path: '/settings' },
  ];
  
  // Bulletproof safety check. If the user is somehow not available,
  // show a full-screen loader to prevent any rendering crashes.
  if (!user) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
        <Typography sx={{ ml: 2 }}>Loading Session...</Typography>
      </Box>
    );
  }

  const drawer = (
    <div>
      <Toolbar />
      <Divider />
      <List>
        {menuItems.map((item) => (
          <ListItemButton key={item.text} component={Link} to={item.path}>
            <ListItemIcon>{item.icon}</ListItemIcon>
            <ListItemText primary={item.text} />
          </ListItemButton>
        ))}
      </List>
    </div>
  );

  return (
    <Box sx={{ display: 'flex' }}>
      <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
        <Toolbar>
          <IconButton
            color="inherit"
            aria-label="open drawer"
            edge="start"
            onClick={handleDrawerToggle}
            sx={{ mr: 2, display: { sm: 'none' } }}
          >
            <MenuIcon />
          </IconButton>
          <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
            Collabris
          </Typography>
          <div>
            <IconButton onClick={handleMenu} color="inherit">
              <Avatar sx={{ width: 32, height: 32, bgcolor: 'secondary.main' }}>
                {/* Safety check to prevent crash if username is missing */}
                {user.username ? user.username.charAt(0).toUpperCase() : '?'}
              </Avatar>
            </IconButton>
            <Menu
              anchorEl={anchorEl}
              anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
              keepMounted
              transformOrigin={{ vertical: 'top', horizontal: 'right' }}
              open={Boolean(anchorEl)}
              onClose={handleClose}
            >
              <MenuItem component={Link} to="/profile" onClick={handleClose}>Profile</MenuItem>
              <MenuItem onClick={handleLogout}>Logout</MenuItem>
            </Menu>
          </div>
        </Toolbar>
      </AppBar>
      <Box
        component="nav"
        sx={{ width: { sm: drawerWidth }, flexShrink: { sm: 0 } }}
        aria-label="mailbox folders"
      >
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{ keepMounted: true }}
          sx={{
            display: { xs: 'block', sm: 'none' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
          }}
        >
          {drawer}
        </Drawer>
        <Drawer
          variant="permanent"
          sx={{
            display: { xs: 'none', sm: 'block' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
          }}
          open
        >
          {drawer}
        </Drawer>
      </Box>
      <Box
        component="main"
        sx={{ flexGrow: 1, p: 3, width: { sm: `calc(100% - ${drawerWidth}px)` } }}
      >
        <Toolbar />
        {children}
      </Box>
    </Box>
  );
};

export default Layout;
</file>

<file path="frontend/src/main.tsx">
// File Path: frontend/src/main.tsx
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';
import './index.css';

// This is the correct structure
createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);
</file>

<file path="frontend/src/pages/Auth/Login.tsx">
// File path: frontend/src/pages/Auth/Login.tsx
import React, { useState, useEffect } from 'react';
import { Link as RouterLink, useNavigate, useLocation } from 'react-router-dom';
import {
    Box, Card, CardContent, TextField, Button, Typography, Link, Alert,
    InputAdornment, IconButton, Divider, useTheme
} from '@mui/material';
import { alpha } from '@mui/material/styles';
import {
    Visibility as VisibilityIcon,
    VisibilityOff as VisibilityOffIcon,
    EmailOutlined as EmailIcon,
    LockOutlined as PasswordIcon,
} from '@mui/icons-material';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { useAppDispatch, useAppSelector } from '../../store/store';
import { login, clearError, selectIsLoading, selectAuthError } from '../../store/slices/authSlice';
import { LoginRequest } from '../../types'; // Import the type

const loginSchema = yup.object().shape({
    username: yup.string().required('Username or Email is required'),
    password: yup.string().required('Password is required'),
});

const Login: React.FC = () => {
    const [showPassword, setShowPassword] = useState(false);
    const theme = useTheme();
    const navigate = useNavigate();
    const location = useLocation();
    const dispatch = useAppDispatch();
    
    const isLoading = useAppSelector(selectIsLoading);
    const error = useAppSelector(selectAuthError);

    const { control, handleSubmit, formState: { errors }, getValues } = useForm<LoginRequest>({
        resolver: yupResolver(loginSchema),
        defaultValues: { username: '', password: '' },
    });

    useEffect(() => {
        dispatch(clearError());
    }, [dispatch]);

    // --- THIS IS THE FIX ---
    // Added the 'LoginRequest' type to the 'data' parameter
    const onSubmit = async (data: LoginRequest) => {
        try {
            await dispatch(login(data)).unwrap();
            const from = (location.state as any)?.from?.pathname || '/dashboard';
            navigate(from, { replace: true });
        } catch (err: any) {
            if (err && err.message && err.message.includes('verify your email')) {
                const usernameOrEmail = getValues("username");
                navigate('/verify-email', { state: { email: usernameOrEmail } });
            }
        }
    };

    return (
        <Box
            sx={{
                minHeight: '100vh',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                background: `linear-gradient(135deg, ${theme.palette.background.default} 0%, ${alpha(theme.palette.primary.main, 0.1)} 100%)`,
                p: 2,
            }}
        >
            <Card
                sx={{
                    maxWidth: 420,
                    width: '100%',
                    borderRadius: 3,
                    boxShadow: '0 25px 50px -12px rgba(0,0,0,0.25)',
                    backdropFilter: 'blur(20px)',
                    backgroundColor: alpha(theme.palette.background.paper, 0.9),
                }}
            >
                <CardContent sx={{ p: { xs: 3, sm: 4 } }}>
                    <Box textAlign="center" mb={3}>
                        <Typography variant="h4" component="h1" sx={{ fontWeight: 700, mb: 1, color: 'primary.main' }}>
                            Welcome Back
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                            Sign in to continue to Collabris
                        </Typography>
                    </Box>

                    {error && <Alert severity="error" sx={{ mb: 3 }}>{error}</Alert>}

                    <Box component="form" onSubmit={handleSubmit(onSubmit)} noValidate>
                        <Controller name="username" control={control} render={({ field }) => ( <TextField {...field} fullWidth label="Username or Email" error={!!errors.username} helperText={errors.username?.message} sx={{ mb: 2 }} InputProps={{ startAdornment: ( <InputAdornment position="start"><EmailIcon color="action" /></InputAdornment> ), }} /> )}/>
                        <Controller name="password" control={control} render={({ field }) => ( <TextField {...field} fullWidth label="Password" type={showPassword ? 'text' : 'password'} error={!!errors.password} helperText={errors.password?.message} sx={{ mb: 3 }} InputProps={{ startAdornment: ( <InputAdornment position="start"><PasswordIcon color="action" /></InputAdornment> ), endAdornment: ( <InputAdornment position="end"><IconButton onClick={() => setShowPassword(!showPassword)} edge="end">{showPassword ? <VisibilityOffIcon /> : <VisibilityIcon />}</IconButton></InputAdornment> ), }} /> )}/>

                        <Button type="submit" fullWidth variant="contained" size="large" disabled={isLoading} sx={{ py: 1.5, mb: 2, fontWeight: 600 }}>
                            {isLoading ? 'Signing In...' : 'Sign In'}
                        </Button>
                        
                        <Divider sx={{ my: 2 }}>
                            <Typography variant="body2" color="text.secondary"> OR </Typography>
                        </Divider>

                        <Box textAlign="center">
                            <Typography variant="body2" color="text.secondary"> Don't have an account?{' '} <Link component={RouterLink} to="/register" fontWeight="medium"> Sign up </Link> </Typography>
                        </Box>
                    </Box>
                </CardContent>
            </Card>
        </Box>
    );
};

export default Login;
</file>

<file path="frontend/src/pages/Auth/Register.tsx">
// File Path: frontend/src/pages/Auth/Register.tsx
import React, { useState, useEffect } from 'react';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import {
    Box, Card, CardContent, TextField, Button, Typography, Link, Alert,
    InputAdornment, IconButton, Divider, useTheme
} from '@mui/material';
import { alpha } from '@mui/material/styles'; // <-- THIS IS THE CRITICAL FIX
import {
    Visibility as VisibilityIcon,
    VisibilityOff as VisibilityOffIcon,
    PersonOutline as UserIcon,
    EmailOutlined as EmailIcon,
    LockOutlined as PasswordIcon,
} from '@mui/icons-material';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { useAppDispatch, useAppSelector } from '../../store/store';
import { signup, clearError, selectIsLoading, selectAuthError } from '../../store/slices/authSlice';
import { SignupRequest } from '../../types';

const signupSchema = yup.object().shape({
    firstName: yup.string().required('First name is required'),
    lastName: yup.string().required('Last name is required'),
    username: yup.string().required('Username is required'),
    email: yup.string().email('Enter a valid email').required('Email is required'),
    password: yup.string().min(8, 'Password must be at least 8 characters').required('Password is required'),
});

const Register: React.FC = () => {
    const [showPassword, setShowPassword] = useState(false);
    const theme = useTheme();
    const navigate = useNavigate();
    const dispatch = useAppDispatch();

    const isLoading = useAppSelector(selectIsLoading);
    const error = useAppSelector(selectAuthError);

    const { control, handleSubmit, formState: { errors } } = useForm<SignupRequest>({
        resolver: yupResolver(signupSchema),
        defaultValues: { firstName: '', lastName: '', username: '', email: '', password: '' },
    });

    useEffect(() => {
        dispatch(clearError());
    }, [dispatch]);

    const onSubmit = async (data: SignupRequest) => {
        try {
            await dispatch(signup(data)).unwrap();
            navigate('/verify-email', { state: { email: data.email }, replace: true });
        } catch (err) {
            // Error is handled by the authSlice
        }
    };

    return (
        <Box
            sx={{
                minHeight: '100vh',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                background: `linear-gradient(135deg, ${theme.palette.background.default} 0%, ${alpha(theme.palette.secondary.main, 0.1)} 100%)`,
                p: 2,
            }}
        >
            <Card
                sx={{
                    maxWidth: 420,
                    width: '100%',
                    borderRadius: 3,
                    boxShadow: '0 25px 50px -12px rgba(0,0,0,0.25)',
                    backdropFilter: 'blur(20px)',
                    backgroundColor: alpha(theme.palette.background.paper, 0.9),
                }}
            >
                <CardContent sx={{ p: { xs: 3, sm: 4 } }}>
                    <Box textAlign="center" mb={3}>
                        <Typography variant="h4" component="h1" sx={{ fontWeight: 700, mb: 1, color: 'secondary.main' }}>
                            Create an Account
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                            Join Collabris and start collaborating
                        </Typography>
                    </Box>

                    {error && <Alert severity="error" sx={{ mb: 3 }}>{error}</Alert>}

                    <Box component="form" onSubmit={handleSubmit(onSubmit)} noValidate>
                        <Box sx={{ display: 'flex', gap: 2, mb: 2 }}>
                            <Controller name="firstName" control={control} render={({ field }) => (<TextField {...field} fullWidth label="First Name" error={!!errors.firstName} helperText={errors.firstName?.message} />)} />
                            <Controller name="lastName" control={control} render={({ field }) => (<TextField {...field} fullWidth label="Last Name" error={!!errors.lastName} helperText={errors.lastName?.message} />)} />
                        </Box>
                        
                        <Controller name="username" control={control} render={({ field }) => ( <TextField {...field} fullWidth label="Username" error={!!errors.username} helperText={errors.username?.message} sx={{ mb: 2 }} InputProps={{ startAdornment: (<InputAdornment position="start"><UserIcon color="action" /></InputAdornment>), }} /> )}/>
                        <Controller name="email" control={control} render={({ field }) => ( <TextField {...field} fullWidth label="Email" error={!!errors.email} helperText={errors.email?.message} sx={{ mb: 2 }} InputProps={{ startAdornment: (<InputAdornment position="start"><EmailIcon color="action" /></InputAdornment>), }} /> )}/>
                        <Controller name="password" control={control} render={({ field }) => ( <TextField {...field} fullWidth label="Password" type={showPassword ? 'text' : 'password'} error={!!errors.password} helperText={errors.password?.message} sx={{ mb: 3 }} InputProps={{ startAdornment: (<InputAdornment position="start"><PasswordIcon color="action" /></InputAdornment>), endAdornment: (<InputAdornment position="end"><IconButton onClick={() => setShowPassword(!showPassword)} edge="end">{showPassword ? <VisibilityOffIcon /> : <VisibilityIcon />}</IconButton></InputAdornment>), }}/> )}/>

                        <Button type="submit" fullWidth variant="contained" size="large" color="secondary" disabled={isLoading} sx={{ py: 1.5, mb: 2, fontWeight: 600 }}>
                            {isLoading ? 'Creating Account...' : 'Create Account'}
                        </Button>

                        <Divider sx={{ my: 2 }}>
                            <Typography variant="body2" color="text.secondary">OR</Typography>
                        </Divider>

                        <Box textAlign="center">
                             <Typography variant="body2" color="text.secondary">Already have an account?{' '}<Link component={RouterLink} to="/login" fontWeight="medium">Sign in</Link></Typography>
                        </Box>
                    </Box>
                </CardContent>
            </Card>
        </Box>
    );
};

export default Register;
</file>

<file path="frontend/src/pages/Dashboard/Dashboard.jsx">
// File Path: frontend/src/pages/Dashboard/Dashboard.jsx
import React from 'react';
import { useSelector } from 'react-redux';
import { selectUser } from '../../store/slices/authSlice';

import AdminDashboard from './AdminDashboard';
import ManagerDashboard from './ManagerDashboard';
import MemberDashboard from './MemberDashboard';
import LoadingSpinner from '../../components/Common/LoadingSpinner';

const Dashboard = () => {
    const user = useSelector(selectUser);

    if (!user || !user.roles) {
        return <LoadingSpinner message="Loading user data..." />;
    }

    // --- THIS IS THE FIX ---
    // The backend sends `user.roles` as an array of strings (e.g., ['ADMIN']).
    // We can use this array directly. No .map() is needed.
    const roles = user.roles;

    // This check will now work correctly.
    if (roles.includes('ADMIN')) {
        return <AdminDashboard />;
    }
    
    if (roles.includes('MANAGER')) {
        return <ManagerDashboard />;
    }
    
    if (roles.includes('MEMBER')) {
        return <MemberDashboard />;
    }
    
    // Fallback message for a user with no valid roles.
    return (
        <div>
            <h1>Welcome</h1>
            <p>You do not have a role assigned. Please contact an administrator.</p>
        </div>
    );
};

export default Dashboard;
</file>

<file path="frontend/src/pages/Landing/Landing.tsx">
// File Path: frontend/src/pages/Landing/Landing.tsx
import React from 'react';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import {
  Box, Container, Typography, Button, Grid, Card, CardContent, Avatar,
  useTheme, AppBar, Toolbar, IconButton
} from '@mui/material';
import { alpha } from '@mui/material/styles'; // <-- THIS IS THE CRITICAL FIX
import {
  ArrowForward as ArrowForwardIcon,
  People as PeopleIcon,
  Assignment as AssignmentIcon,
  Chat as ChatIcon,
  Security as SecurityIcon,
  Speed as SpeedIcon,
  Star as StarIcon,
  Brightness4 as DarkModeIcon,
  Brightness7 as LightModeIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import { useAppSelector, useAppDispatch } from '../../store/store';
import { selectEffectiveTheme, toggleTheme } from '../../store/slices/themeSlice';

const Landing: React.FC = () => {
  const theme = useTheme();
  const navigate = useNavigate();
  const dispatch = useAppDispatch();
  const currentTheme = useAppSelector(selectEffectiveTheme);

  const handleGetStarted = () => navigate('/register');
  const handleSignIn = () => navigate('/login');
  const handleThemeToggle = () => dispatch(toggleTheme());

  const features = [
    { icon: <PeopleIcon sx={{ fontSize: 40 }} />, title: 'Team Management', description: 'Organize teams, assign roles, and manage permissions with ease.' },
    { icon: <AssignmentIcon sx={{ fontSize: 40 }} />, title: 'Project Tracking', description: 'Track project progress, set deadlines, and monitor team productivity.' },
    { icon: <ChatIcon sx={{ fontSize: 40 }} />, title: 'Real-time Chat', description: 'Communicate instantly with team members through integrated messaging.' },
    { icon: <SecurityIcon sx={{ fontSize: 40 }} />, title: 'Secure & Private', description: 'Enterprise-grade security with role-based access control.' },
    { icon: <SpeedIcon sx={{ fontSize: 40 }} />, title: 'Fast & Responsive', description: 'Lightning-fast performance with modern web technologies.' },
  ];

  const testimonials = [
    { name: 'Sarah J.', role: 'Product Manager', avatar: 'SJ', rating: 5, text: 'Collabris transformed how our team collaborates. The real-time features are game-changing!' },
    { name: 'Michael C.', role: 'Software Engineer', avatar: 'MC', rating: 5, text: 'The most intuitive project management tool I\'ve used. Setup was incredibly easy.' },
    { name: 'Emily R.', role: 'Design Lead', avatar: 'ER', rating: 5, text: 'Finally, a platform that actually makes our workflow smoother.' },
  ];

  return (
    <Box sx={{ backgroundColor: theme.palette.background.default, color: theme.palette.text.primary }}>
      <AppBar position="sticky" elevation={0} sx={{ backgroundColor: alpha(theme.palette.background.paper, 0.8), backdropFilter: 'blur(20px)', borderBottom: `1px solid ${theme.palette.divider}` }}>
        <Toolbar>
          <Typography variant="h5" component="div" sx={{ flexGrow: 1, fontWeight: 700, background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>Collabris</Typography>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <IconButton onClick={handleThemeToggle} color="inherit">
              {currentTheme === 'dark' ? <LightModeIcon /> : <DarkModeIcon />}
            </IconButton>
            <Button color="inherit" onClick={handleSignIn} sx={{ textTransform: 'none', display: { xs: 'none', sm: 'inline-flex' } }}>Sign In</Button>
            <Button variant="contained" onClick={handleGetStarted} sx={{ textTransform: 'none', background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)', '&:hover': { background: 'linear-gradient(135deg, #1d4ed8 0%, #6d28d9 100%)' } }}>Get Started</Button>
          </Box>
        </Toolbar>
      </AppBar>

      <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.8 }}>
        <Container maxWidth="lg" sx={{ textAlign: 'center', py: { xs: 8, md: 12 } }}>
          <Typography variant="h1" component="h1" sx={{ fontSize: { xs: '2.5rem', md: '4rem' }, fontWeight: 800, mb: 2, background: `linear-gradient(135deg, ${theme.palette.primary.main} 0%, ${theme.palette.secondary.main} 100%)`, WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>Collaborate Smarter, Achieve More</Typography>
          <Typography variant="h5" sx={{ color: 'text.secondary', mb: 4, maxWidth: '700px', mx: 'auto' }}>The ultimate platform for modern teams. Manage projects, communicate in real-time, and drive success together.</Typography>
          <Button variant="contained" size="large" endIcon={<ArrowForwardIcon />} onClick={handleGetStarted} sx={{ px: 5, py: 1.5, fontSize: '1.1rem', background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)', '&:hover': { background: 'linear-gradient(135deg, #1d4ed8 0%, #6d28d9 100%)' } }}>Get Started for Free</Button>
        </Container>
      </motion.div>
    </Box>
  );
};

export default Landing;
</file>

<file path="frontend/src/pages/Projects/ProjectModal.jsx">
// File path: frontend/src/pages/Projects/ProjectModal.jsx
import React, { useEffect } from 'react';
import {
    Dialog, DialogTitle, DialogContent, DialogActions,
    Button, TextField, Grid, Typography
} from '@mui/material';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';

const schema = yup.object().shape({
    name: yup.string().required('Project name is required').max(100, 'Name cannot exceed 100 characters'),
    description: yup.string().max(1000, 'Description cannot exceed 1000 characters'),
});

const ProjectModal = ({ open, onClose, onSave, project }) => {
    const { control, handleSubmit, reset, formState: { errors } } = useForm({
        resolver: yupResolver(schema)
    });
    const isEditing = !!project;

    useEffect(() => {
        if (open) {
            if (project) {
                // If editing, populate the form with existing project data
                reset({
                    name: project.name || '',
                    description: project.description || ''
                });
            } else {
                // If creating a new project, ensure the form is blank
                reset({
                    name: '',
                    description: ''
                });
            }
        }
    }, [project, open, reset]);

    const onSubmit = (data) => {
        onSave(data, project?.id);
    };

    return (
        <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
            <DialogTitle>{isEditing ? 'Edit Project' : 'Create a New Project'}</DialogTitle>
            <form onSubmit={handleSubmit(onSubmit)}>
                <DialogContent>
                    <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                        Fill in the details below to start your new project.
                    </Typography>
                    <Grid container spacing={2} sx={{ mt: 1 }}>
                        <Grid item xs={12}>
                            <Controller
                                name="name"
                                control={control}
                                defaultValue=""
                                render={({ field }) => (
                                    <TextField
                                        {...field}
                                        label="Project Name"
                                        fullWidth
                                        required
                                        autoFocus
                                        error={!!errors.name}
                                        helperText={errors.name?.message}
                                    />
                                )}
                            />
                        </Grid>
                        <Grid item xs={12}>
                            <Controller
                                name="description"
                                control={control}
                                defaultValue=""
                                render={({ field }) => (
                                    <TextField
                                        {...field}
                                        label="Project Description (Optional)"
                                        fullWidth
                                        multiline
                                        rows={4}
                                        error={!!errors.description}
                                        helperText={errors.description?.message}
                                    />
                                )}
                            />
                        </Grid>
                    </Grid>
                </DialogContent>
                <DialogActions sx={{ p: 3 }}>
                    <Button onClick={onClose}>Cancel</Button>
                    <Button type="submit" variant="contained">
                        {isEditing ? 'Save Changes' : 'Create Project'}
                    </Button>
                </DialogActions>
            </form>
        </Dialog>
    );
};

export default ProjectModal;
</file>

<file path="frontend/src/pages/Teams/TeamDetailPage.jsx">
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import {
    Box, Typography, CircularProgress, Alert, Paper, Grid,
    Avatar, List, ListItem, ListItemAvatar, ListItemText, Divider, Chip
} from '@mui/material';
import { Group as GroupIcon, Person as PersonIcon } from '@mui/icons-material';
import toast from 'react-hot-toast';

import Layout from '../../components/Layout/Layout';
import { getTeamById } from '../../services/teamService';

const TeamDetailPage = () => {
    const { teamId } = useParams();
    const [team, setTeam] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
        const fetchTeam = async () => {
            if (!teamId) return;
            try {
                setLoading(true);
                setError(null);
                const teamData = await getTeamById(teamId);
                setTeam(teamData);
            } catch (err) {
                console.error("Failed to fetch team details:", err);
                setError("Could not load the team. It may not exist or you may not have access.");
                toast.error("Failed to load team details.");
            } finally {
                setLoading(false);
            }
        };

        fetchTeam();
    }, [teamId]);

    if (loading) {
        return (
            <Layout>
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '60vh' }}>
                    <CircularProgress color="secondary" />
                    <Typography sx={{ ml: 2 }}>Loading team...</Typography>
                </Box>
            </Layout>
        );
    }

    if (error) {
        return <Layout><Alert severity="error" sx={{ m: 2 }}>{error}</Alert></Layout>;
    }

    if (!team) {
        return <Layout><Alert severity="warning" sx={{ m: 2 }}>Team not found.</Alert></Layout>;
    }

    return (
        <Layout>
            {/* Header */}
            <Box mb={4}>
                <Typography variant="h4" fontWeight="bold" color="secondary.main">{team.name}</Typography>
                <Typography color="text.secondary">{team.description}</Typography>
            </Box>

            <Grid container spacing={3}>
                {/* Main Content Area (Projects, Chat will go here later) */}
                <Grid item xs={12} md={8}>
                    <Paper sx={{ p: 2, minHeight: 400 }}>
                        <Typography variant="h6">Team Workspace</Typography>
                        <Typography color="text.secondary">(Associated projects and chat will be implemented here)</Typography>
                    </Paper>
                </Grid>

                {/* Right Sidebar with Members List */}
                <Grid item xs={12} md={4}>
                    <Paper sx={{ p: 2 }}>
                        <Typography variant="h6" gutterBottom>Members ({team.members?.length || 0})</Typography>
                        <Divider />
                        <List>
                            {team.members && team.members.map(member => (
                                <ListItem key={member.id}>
                                    <ListItemAvatar>
                                        <Avatar sx={{ bgcolor: 'secondary.light' }}>
                                            {member.firstName?.charAt(0)}
                                        </Avatar>
                                    </ListItemAvatar>
                                    <ListItemText
                                        primary={`${member.firstName} ${member.lastName}`}
                                        secondary={`@${member.username}`}
                                    />
                                    {member.id === team.owner?.id && <Chip label="Owner" size="small" variant="outlined" />}
                                </ListItem>
                            ))}
                        </List>
                    </Paper>
                </Grid>
            </Grid>
        </Layout>
    );
};

export default TeamDetailPage;
</file>

<file path="frontend/src/pages/Teams/TeamModal.jsx">
// File path: frontend/src/pages/Teams/TeamModal.jsx
import React, { useEffect } from 'react';
import {
    Dialog, DialogTitle, DialogContent, DialogActions,
    Button, TextField, Grid, Typography
} from '@mui/material';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';

const schema = yup.object().shape({
    name: yup.string().required('Team name is required').max(100, 'Name cannot exceed 100 characters'),
    description: yup.string().max(1000, 'Description cannot exceed 1000 characters'),
});

const TeamModal = ({ open, onClose, onSave, team }) => {
    const { control, handleSubmit, reset, formState: { errors } } = useForm({
        resolver: yupResolver(schema)
    });
    const isEditing = !!team;

    useEffect(() => {
        if (open) {
            if (team) {
                reset({
                    name: team.name || '',
                    description: team.description || ''
                });
            } else {
                reset({ name: '', description: '' });
            }
        }
    }, [team, open, reset]);

    const onSubmit = (data) => {
        onSave(data, team?.id);
    };

    return (
        <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
            <DialogTitle>{isEditing ? 'Edit Team' : 'Create a New Team'}</DialogTitle>
            <form onSubmit={handleSubmit(onSubmit)}>
                <DialogContent>
                    <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                        Bring people together to collaborate on projects.
                    </Typography>
                    <Grid container spacing={2} sx={{ mt: 1 }}>
                        <Grid item xs={12}>
                            <Controller
                                name="name"
                                control={control}
                                defaultValue=""
                                render={({ field }) => (
                                    <TextField
                                        {...field}
                                        label="Team Name"
                                        fullWidth
                                        required
                                        autoFocus
                                        error={!!errors.name}
                                        helperText={errors.name?.message}
                                    />
                                )}
                            />
                        </Grid>
                        <Grid item xs={12}>
                            <Controller
                                name="description"
                                control={control}
                                defaultValue=""
                                render={({ field }) => (
                                    <TextField
                                        {...field}
                                        label="Description (Optional)"
                                        fullWidth
                                        multiline
                                        rows={3}
                                        error={!!errors.description}
                                        helperText={errors.description?.message}
                                    />
                                )}
                            />
                        </Grid>
                    </Grid>
                </DialogContent>
                <DialogActions sx={{ p: 3 }}>
                    <Button onClick={onClose}>Cancel</Button>
                    <Button type="submit" variant="contained" color="secondary">
                        {isEditing ? 'Save Changes' : 'Create Team'}
                    </Button>
                </DialogActions>
            </form>
        </Dialog>
    );
};

export default TeamModal;
</file>

<file path="frontend/src/pages/Teams/TeamsPage.jsx">
// File path: frontend/src/pages/Teams/TeamsPage.jsx
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import {
    Box, Grid, Card, CardContent, CardActions, Button,
    Typography, CircularProgress, Alert, Avatar, AvatarGroup
} from '@mui/material';
import { Add as AddIcon, Group as GroupIcon } from '@mui/icons-material';
import { motion } from 'framer-motion';
import toast from 'react-hot-toast';

import Layout from '../../components/Layout/Layout';
import { getMyTeams, createTeam } from '../../services/teamService';
import TeamModal from './TeamModal.jsx'; // Note the .jsx extension

const TeamsPage = () => {
    const [teams, setTeams] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    
    const fetchTeams = async () => {
        try {
            const teamsData = await getMyTeams();
            setTeams(teamsData);
        } catch (err) {
            console.error("Failed to fetch teams:", err);
            setError("Could not load your teams.");
            toast.error("Failed to load teams.");
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        setLoading(true);
        fetchTeams();
    }, []);

    const handleSaveTeam = async (teamData) => {
        try {
            await createTeam(teamData);
            toast.success("Team created successfully!");
            setIsModalOpen(false);
            setLoading(true);
            await fetchTeams(); // Refresh list
        } catch (error) {
            console.error("Failed to create team:", error);
            toast.error(error.message || "Failed to create team.");
        }
    };

    const renderContent = () => {
        if (loading) return <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}><CircularProgress /></Box>;
        if (error) return <Alert severity="error">{error}</Alert>;
        if (teams.length === 0) {
            return (
                <Box sx={{ textAlign: 'center', mt: 4, py: 8 }}>
                    <GroupIcon sx={{ fontSize: 60, color: 'text.secondary' }} />
                    <Typography variant="h6" mt={2}>No teams yet!</Typography>
                    <Typography color="text.secondary">Create a team to start collaborating.</Typography>
                </Box>
            );
        }
        return (
            <Grid container spacing={3}>
                {teams.map(team => (
                    <Grid item xs={12} sm={6} md={4} key={team.id}>
                        <motion.div whileHover={{ y: -5 }}>
                            <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                                <CardContent sx={{ flexGrow: 1 }}>
                                    <Typography gutterBottom variant="h5" component="h2" color="secondary.main">{team.name}</Typography>
                                    <Typography color="text.secondary" noWrap sx={{mb: 2}}>{team.description || 'No description'}</Typography>
                                    
                                    <Box display="flex" alignItems="center">
                                        <Typography variant="caption" sx={{mr: 1}}>Members:</Typography>
                                        <AvatarGroup max={4} sx={{ '& .MuiAvatar-root': { width: 24, height: 24, fontSize: 12 } }}>
                                            {team.members && team.members.map(m => (
                                                <Avatar key={m.id} alt={m.username}>{m.firstName?.charAt(0)}</Avatar>
                                            ))}
                                        </AvatarGroup>
                                    </Box>
                                </CardContent>
                                <CardActions>
                                    {/* Detail page coming in next step */}
                                    <Button size="small" color="secondary" component={Link} to={`/teams/${team.id}`}>View Team</Button>
                                </CardActions>
                            </Card>
                        </motion.div>
                    </Grid>
                ))}
            </Grid>
        );
    };

    return (
        <Layout>
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }}>
                <Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
                    <Box>
                        <Typography variant="h4" fontWeight="bold">My Teams</Typography>
                        <Typography color="text.secondary">Teams you are a member of.</Typography>
                    </Box>
                    <Button variant="contained" color="secondary" startIcon={<AddIcon />} onClick={() => setIsModalOpen(true)}>
                        Create Team
                    </Button>
                </Box>
                {renderContent()}
                <TeamModal open={isModalOpen} onClose={() => setIsModalOpen(false)} onSave={handleSaveTeam} />
            </motion.div>
        </Layout>
    );
};

export default TeamsPage;
</file>

<file path="frontend/src/services/chatService.ts">
// File path: frontend/src/services/chatService.ts
import apiClient from './apiClient';
import { ChatMessage } from '../types';

export interface ChatMessageRequest {
    content: string;
}

// --- THIS IS THE MISSING FUNCTION, NOW CORRECTLY ADDED BACK ---
export const getProjectMessages = async (projectId: number): Promise<ChatMessage[]> => {
    // This correctly calls the endpoint for fetching a project's message history.
    const response = await apiClient.get(`/api/chat/projects/${projectId}/messages`);
    return response;
};

// This function can be used for fetching messages from non-project chat rooms later.
export const getMessages = async (roomId: number): Promise<ChatMessage[]> => {
  const response = await apiClient.get(`/api/chat/rooms/${roomId}/messages`);
  return response;
};

// This function can be used for sending messages to non-project chat rooms later.
export const sendMessage = async (messageData: { chatRoomId: number; content: string }): Promise<ChatMessage> => {
  const response = await apiClient.post('/api/chat/messages', messageData);
  return response;
};
</file>

<file path="frontend/src/services/projectService.ts">
// File path: frontend/src/services/projectService.ts
import apiClient from './apiClient';
import { Project, ProjectRequest } from '../types';

// This is the new function to fetch the user's projects
export const getMyProjects = async (): Promise<Project[]> => {
    // This calls the GET /api/projects endpoint we secured in the last step
    const response = await apiClient.get('/api/projects');
    return response;
};

// These functions will be used when we build the project creation/editing modals
export const createProject = async (projectData: ProjectRequest): Promise<Project> => {
    const response = await apiClient.post('/api/projects', projectData);
    return response;
};

export const updateProject = async (projectId: number, projectData: ProjectRequest): Promise<Project> => {
    const response = await apiClient.put(`/api/projects/${projectId}`, projectData);
    return response;
};

export const deleteProject = async (projectId: number): Promise<void> => {
    const response = await apiClient.delete(`/api/projects/${projectId}`);
    return response;
};

export const getProjectById = async (projectId: number): Promise<Project> => {
    const response = await apiClient.get(`/api/projects/${projectId}`);
    return response;
};
</file>

<file path="frontend/src/services/teamService.ts">
// File path: frontend/src/services/teamService.ts
import apiClient from './apiClient';
// FIX: Removed incorrect imports and added the correct ones
import { Team, TeamRequest } from '../types';

export const getMyTeams = async (): Promise<Team[]> => {
    // Calls GET /api/teams to fetch all teams for the current user
    const response = await apiClient.get('/api/teams');
    return response;
};

export const createTeam = async (teamData: TeamRequest): Promise<Team> => {
    // Calls POST /api/teams to create a new team
    const response = await apiClient.post('/api/teams', teamData);
    return response;
};

export const getTeamById = async (teamId: number): Promise<Team> => {
    // Calls GET /api/teams/{teamId} to fetch details for one team
    const response = await apiClient.get(`/api/teams/${teamId}`);
    return response;
};

// Placeholder for future administrative functions
export const updateTeam = async (teamId: number, teamData: TeamRequest): Promise<Team> => {
    const response = await apiClient.put(`/api/teams/${teamId}`, teamData);
    return response;
};

// Placeholder for future administrative functions
export const deleteTeam = async (teamId: number): Promise<void> => {
    const response = await apiClient.delete(`/api/teams/${teamId}`);
    return response;
};
</file>

<file path="frontend/src/store/slices/authSlice.ts">
// File path: frontend/src/store/slices/authSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { User, LoginRequest, SignupRequest, AuthResponse } from '../../types';
import * as authService from '../../services/authService';

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  initialLoad: 'idle' | 'loading' | 'succeeded' | 'failed';
}

const getInitialState = (): AuthState => {
  const token = localStorage.getItem('token');
  return {
    user: null,
    token,
    isAuthenticated: !!token,
    isLoading: false,
    error: null,
    initialLoad: 'idle',
  };
};

const initialState: AuthState = getInitialState();

export const login = createAsyncThunk(
  'auth/login',
  async (credentials: LoginRequest, { rejectWithValue }) => {
    try {
      const response = await authService.login(credentials);
      localStorage.setItem('token', response.token);
      return response;
    } catch (error: any) {
      return rejectWithValue(error.message || 'Login failed');
    }
  }
);

export const signup = createAsyncThunk(
  'auth/signup',
  async (userData: SignupRequest, { rejectWithValue }) => {
    try {
      const response = await authService.signup(userData);
      return response;
    } catch (error: any) {
      return rejectWithValue(error.message || 'Registration failed');
    }
  }
);

export const getCurrentUser = createAsyncThunk(
  'auth/getCurrentUser',
  async (_, { rejectWithValue }) => {
    if (!localStorage.getItem('token')) {
      return rejectWithValue('No token found');
    }
    try {
      const user = await authService.getCurrentUser();
      return user;
    } catch (error: any) {
      localStorage.removeItem('token');
      return rejectWithValue(error.message || 'Failed to fetch user');
    }
  }
);

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logout: (state) => {
      state.user = null;
      state.token = null;
      state.isAuthenticated = false;
      localStorage.removeItem('token');
    },
    clearError: (state) => {
      state.error = null;
    },
    setUser: (state, action: PayloadAction<User>) => {
      state.user = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder
      // LOGIN
      .addCase(login.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(login.fulfilled, (state, action: PayloadAction<AuthResponse>) => {
        state.isLoading = false;
        state.isAuthenticated = true;
        state.token = action.payload.token;
        state.user = action.payload.user; 
      })
      .addCase(login.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      // SIGNUP
      .addCase(signup.pending, (state) => { state.isLoading = true; state.error = null; })
      .addCase(signup.fulfilled, (state) => { state.isLoading = false; })
      .addCase(signup.rejected, (state, action) => { state.isLoading = false; state.error = action.payload as string; })
      // GET CURRENT USER
      .addCase(getCurrentUser.pending, (state) => { state.initialLoad = 'loading'; })
      .addCase(getCurrentUser.fulfilled, (state, action) => {
        state.isAuthenticated = true;
        state.user = action.payload;
        state.initialLoad = 'succeeded';
      })
      .addCase(getCurrentUser.rejected, (state) => {
        state.isAuthenticated = false;
        state.token = null;
        state.user = null;
        state.initialLoad = 'failed';
      });
  },
});

export const { logout, clearError, setUser } = authSlice.actions;

export const selectUser = (state: { auth: AuthState }) => state.auth.user;
export const selectIsAuthenticated = (state: { auth: AuthState }) => state.auth.isAuthenticated;
export const selectIsLoading = (state: { auth: AuthState }) => state.auth.isLoading;
export const selectAuthError = (state: { auth: AuthState }) => state.auth.error;
export const selectInitialLoad = (state: { auth: AuthState }) => state.auth.initialLoad;

// --- THIS IS THE FIX ---
// The `roles` array now contains strings, so we check the string directly.
export const selectIsAdmin = (state: { auth: AuthState }) =>
  state.auth.user?.roles.some(role => role === 'ADMIN') || false;

export default authSlice.reducer;
</file>

<file path="frontend/src/store/slices/dashboardSlice.ts">
// File Path: frontend/src/store/slices/dashboardSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { getAdminDashboardStats } from '../../services/dashboardService';

// This defines the full shape of the stats object for the Admin Dashboard
interface AdminStats {
    totalUsers: number | string;
    totalProjects: number | string;
    totalTeams: number | string;
    roleDistribution: any[]; // Kept as 'any' for simplicity for now
    userGrowth: any[];
}

interface DashboardState {
  adminStats: AdminStats | null;
  loading: boolean;
  error: string | null;
}

const initialState: DashboardState = {
  adminStats: null,
  loading: false,
  error: null,
};

// Async thunk to fetch the initial stats
export const fetchAdminStats = createAsyncThunk(
    'dashboard/fetchAdminStats',
    async (_, { rejectWithValue }) => {
        try {
            const data = await getAdminDashboardStats();
            return data as AdminStats;
        } catch (error: any) {
            return rejectWithValue(error.message);
        }
    }
);

const dashboardSlice = createSlice({
    name: 'dashboard',
    initialState,
    reducers: {
        // --- THIS IS THE FIX ---
        // This reducer now accepts a partial object and merges it into the state.
        // This allows a single action to handle updates for users, projects, or teams.
        updateAdminStats: (state, action: PayloadAction<Partial<AdminStats>>) => {
            if (state.adminStats) {
                // Merge the incoming payload with the existing stats
                Object.assign(state.adminStats, action.payload);
            }
        },
    },
    extraReducers: (builder) => {
        builder
            .addCase(fetchAdminStats.pending, (state) => {
                state.loading = true;
            })
            .addCase(fetchAdminStats.fulfilled, (state, action) => {
                state.loading = false;
                state.adminStats = action.payload;
            })
            .addCase(fetchAdminStats.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload as string;
            });
    }
});

export const { updateAdminStats } = dashboardSlice.actions;

export const selectAdminStats = (state: { dashboard: DashboardState }) => state.dashboard.adminStats;
export const selectDashboardLoading = (state: { dashboard: DashboardState }) => state.dashboard.loading;

export default dashboardSlice.reducer;
</file>

<file path="multi-commit.ps1">
# multi-commit.ps1
# Automate committing each changed file individually

# Step 1: Get all modified and untracked files
$files = git status --porcelain | ForEach-Object {
    $parts = $_.Trim().Split(" ", 2)
    if ($parts.Count -eq 2) { $parts[1] }
}

# Step 2: Loop through each file and commit separately
foreach ($file in $files) {
    Write-Host "Committing: $file"
    git add "$file"

    # Smart auto message depending on file type
    if ($file -match "frontend") {
        $msg = "feat(frontend): update $([System.IO.Path]::GetFileNameWithoutExtension($file))"
    } elseif ($file -match "backend") {
        $msg = "refactor(backend): update $([System.IO.Path]::GetFileNameWithoutExtension($file))"
    } else {
        $msg = "chore: update $([System.IO.Path]::GetFileNameWithoutExtension($file))"
    }

    git commit -m $msg
}

# Step 3: Push all commits at once
git push origin main
Write-Host "All changes committed and pushed successfully!"
</file>

<file path="backend/src/main/java/com/collabris/controller/DashboardController.java">
// File Path: backend/src/main/java/com/collabris/controller/DashboardController.java
package com.collabris.controller;

import com.collabris.entity.Role;
import com.collabris.entity.User;
import com.collabris.repository.ProjectRepository;
import com.collabris.repository.TeamRepository;
import com.collabris.repository.UserRepository;
import com.collabris.service.UserService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/dashboard")
@Tag(name = "Dashboard Analytics", description = "Endpoints for fetching role-specific dashboard data")
@SecurityRequirement(name = "bearerAuth")
public class DashboardController {

    @Autowired
    private UserRepository userRepository;
    @Autowired
    private ProjectRepository projectRepository;
    @Autowired
    private TeamRepository teamRepository;
    @Autowired
    private UserService userService;

    // Helper to get the full User entity from the security context
    private User getCurrentUser(UserDetails userDetails) {
        if (userDetails == null) return null;
        return userService.findByUsername(userDetails.getUsername()).orElse(null);
    }

    @GetMapping("/admin")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Get Admin Dashboard Stats", description = "Provides system-wide statistics for the admin dashboard. Requires ADMIN role.")
    public ResponseEntity<?> getAdminDashboardStats() {
        long totalUsers = userRepository.count();
        long totalProjects = projectRepository.count();
        long totalTeams = teamRepository.count();

        long adminCount = userRepository.countByRoles_Name(Role.ERole.ADMIN);
        long managerCount = userRepository.countByRoles_Name(Role.ERole.MANAGER);
        long memberCount = userRepository.countByRoles_Name(Role.ERole.MEMBER);

        List<Map<String, Object>> roleDistribution = List.of(
            Map.of("name", "Admins", "value", adminCount),
            Map.of("name", "Managers", "value", managerCount),
            Map.of("name", "Members", "value", memberCount)
        );

        List<Map<String, Object>> userGrowth = List.of(
            Map.of("name", "Jan", "users", 0), Map.of("name", "Feb", "users", 0),
            Map.of("name", "Mar", "users", 0), Map.of("name", "Apr", "users", 0),
            Map.of("name", "May", "users", 0), Map.of("name", "Jun", "users", totalUsers)
        );

        return ResponseEntity.ok(Map.of(
            "totalUsers", totalUsers,
            "totalProjects", totalProjects,
            "totalTeams", totalTeams,
            "roleDistribution", roleDistribution,
            "userGrowth", userGrowth
        ));
    }

    @GetMapping("/manager")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get Manager Dashboard Stats", description = "Provides overview statistics for the manager dashboard. Requires MANAGER or ADMIN role.")
    public ResponseEntity<?> getManagerDashboardStats() {
        long totalProjects = projectRepository.count();
        long totalTeams = teamRepository.count();
        long tasksCompleted = 78; // Placeholder value

        // --- NEW DATA FOR MANAGER CHART ---
        // These are placeholder values. In a real app, this would query the task status.
        List<Map<String, Object>> projectsStatusData = List.of(
            Map.of("name", "On Track", "value", totalProjects - 2), // Mocking 2 projects as not on track
            Map.of("name", "At Risk", "value", 1),
            Map.of("name", "Overdue", "value", 1)
        );
        
        return ResponseEntity.ok(Map.of(
            "totalProjects", totalProjects,
            "totalTeams", totalTeams,
            "tasksCompletedThisWeek", tasksCompleted,
            "projectsStatusData", projectsStatusData // Add new chart data to response
        ));
    }

    @GetMapping("/member")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Get Member Dashboard Stats", description = "Provides statistics specific to the currently authenticated user. Requires any authenticated role.")
    public ResponseEntity<?> getMemberDashboardStats(@AuthenticationPrincipal UserDetails userDetails) {
        User currentUser = getCurrentUser(userDetails);
        if (currentUser == null) {
            return ResponseEntity.status(401).build();
        }
        
        long myProjectsCount = projectRepository.findByMemberId(currentUser.getId()).size();
        long myTeamsCount = teamRepository.findByMemberId(currentUser.getId()).size();
        
        // --- NEW DATA FOR MEMBER CHART ---
        // These are placeholder values for a user's personal tasks
        List<Map<String, Object>> myTasksData = List.of(
            Map.of("name", "To Do", "value", 8),
            Map.of("name", "In Progress", "value", 4),
            Map.of("name", "Done", "value", 12)
        );

        return ResponseEntity.ok(Map.of(
            "myProjects", myProjectsCount,
            "myTeams", myTeamsCount,
            "myTasksDue", 8, // Using the "To Do" value for the StatsCard
            "myTasksData", myTasksData // Add new chart data to response
        ));
    }
}
</file>

<file path="backend/src/main/java/com/collabris/controller/TeamController.java">
package com.collabris.controller;

import com.collabris.dto.request.TeamRequest;
import com.collabris.dto.response.TeamResponse;
import com.collabris.entity.User;
import com.collabris.service.TeamService;
import com.collabris.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/teams")
public class TeamController {

    @Autowired
    private TeamService teamService;
    @Autowired
    private UserService userService;
    
    private User getCurrentUser(UserDetails userDetails) {
        return userService.findByUsername(userDetails.getUsername())
                .orElseThrow(() -> new RuntimeException("Error: Authenticated user not found in database."));
    }

    @PostMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<TeamResponse> createTeam(@RequestBody TeamRequest request, @AuthenticationPrincipal UserDetails userDetails) {
        return ResponseEntity.ok(teamService.createTeam(request, getCurrentUser(userDetails)));
    }

    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<TeamResponse>> getAllTeams(@AuthenticationPrincipal UserDetails userDetails) {
        return ResponseEntity.ok(teamService.getTeamsForUser(getCurrentUser(userDetails)));
    }

    @GetMapping("/{teamId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<TeamResponse> getTeamById(@PathVariable Long teamId) {
        return ResponseEntity.ok(teamService.getTeamById(teamId));
    }

    @PutMapping("/{teamId}")
    @PreAuthorize("hasRole('ADMIN') or @teamRepository.findById(#teamId).get().getOwner().getUsername() == authentication.name")
    public ResponseEntity<TeamResponse> updateTeam(@PathVariable Long teamId, @RequestBody TeamRequest request) {
        return ResponseEntity.ok(teamService.updateTeam(teamId, request));
    }

    @DeleteMapping("/{teamId}")
    @PreAuthorize("hasRole('ADMIN') or @teamRepository.findById(#teamId).get().getOwner().getUsername() == authentication.name")
    public ResponseEntity<Void> deleteTeam(@PathVariable Long teamId) {
        teamService.deleteTeam(teamId);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{teamId}/members/{userId}")
    @PreAuthorize("hasRole('ADMIN') or @teamRepository.findById(#teamId).get().getOwner().getUsername() == authentication.name")
    public ResponseEntity<TeamResponse> addMemberToTeam(@PathVariable Long teamId, @PathVariable Long userId) {
        return ResponseEntity.ok(teamService.addMemberToTeam(teamId, userId));
    }

    @DeleteMapping("/{teamId}/members/{userId}")
    @PreAuthorize("hasRole('ADMIN') or @teamRepository.findById(#teamId).get().getOwner().getUsername() == authentication.name")
    public ResponseEntity<TeamResponse> removeMemberFromTeam(@PathVariable Long teamId, @PathVariable Long userId) {
        return ResponseEntity.ok(teamService.removeMemberFromTeam(teamId, userId));
    }
}
</file>

<file path="backend/src/main/java/com/collabris/service/UserService.java">
// File path: backend/src/main/java/com/collabris/service/UserService.java
package com.collabris.service;

import com.collabris.dto.request.AdminUserUpdateRequest;
import com.collabris.dto.response.UserResponse;
import com.collabris.entity.Role;
import com.collabris.entity.User;
import com.collabris.repository.RoleRepository;
import com.collabris.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@Transactional
public class UserService {

    @Autowired
    private UserRepository userRepository;
    @Autowired
    private RoleRepository roleRepository;
    @Autowired
    private PasswordEncoder passwordEncoder;
    @Autowired
    private SimpMessagingTemplate messagingTemplate;

    public User saveUser(User user) {
        User savedUser = userRepository.save(user);
        broadcastUserStats(); // Send WebSocket update
        return savedUser;
    }

    public Optional<User> findByUsername(String username) {
        return userRepository.findByUsername(username);
    }

    public UserResponse getUserResponseByUsername(String username) {
        User user = findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found with username: " + username));
        return new UserResponse(user);
    }
    
    public List<UserResponse> getAllUsers() {
        return userRepository.findAll().stream().map(UserResponse::new).collect(Collectors.toList());
    }

    public User createUserByAdmin(AdminUserUpdateRequest request) {
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new IllegalArgumentException("Error: Username is already taken!");
        }
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new IllegalArgumentException("Error: Email is already in use!");
        }

        User user = new User(request.getUsername(), request.getEmail(), passwordEncoder.encode(request.getPassword()));
        user.setFirstName(request.getFirstName());
        user.setLastName(request.getLastName());
        user.setEnabled(request.getEnabled() != null ? request.getEnabled() : true); // Default to enabled
        
        user.setRoles(getRolesFromStrings(request.getRoles()));
        
        return saveUser(user); // Use saveUser to trigger WebSocket event
    }

    public User updateUserByAdmin(Long userId, AdminUserUpdateRequest request) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Error: User not found."));

        user.setUsername(request.getUsername());
        user.setEmail(request.getEmail());
        user.setFirstName(request.getFirstName());
        user.setLastName(request.getLastName());
        
        if (request.getEnabled() != null) {
            user.setEnabled(request.getEnabled());
        }

        if (request.getPassword() != null && !request.getPassword().isEmpty()) {
            user.setPassword(passwordEncoder.encode(request.getPassword()));
        }

        if (request.getRoles() != null) {
            user.setRoles(getRolesFromStrings(request.getRoles()));
        }

        // We call the repository directly here since it's an update, not a new user.
        return userRepository.save(user);
    }

    public void deleteUserByAdmin(Long userId) {
        userRepository.deleteById(userId);
        broadcastUserStats(); // Send WebSocket update
    }

    // Helper method to convert role strings to Role entities
    private Set<Role> getRolesFromStrings(Set<String> strRoles) {
        Set<Role> roles = new HashSet<>();
        if (strRoles == null || strRoles.isEmpty()) {
            roles.add(roleRepository.findByName(Role.ERole.MEMBER)
                .orElseThrow(() -> new RuntimeException("Error: Role MEMBER is not found.")));
        } else {
            strRoles.forEach(role -> {
                switch (role.toUpperCase()) {
                    case "ADMIN":
                        roles.add(roleRepository.findByName(Role.ERole.ADMIN)
                            .orElseThrow(() -> new RuntimeException("Error: Role ADMIN is not found.")));
                        break;
                    case "MANAGER":
                        roles.add(roleRepository.findByName(Role.ERole.MANAGER)
                            .orElseThrow(() -> new RuntimeException("Error: Role MANAGER is not found.")));
                        break;
                    default:
                        roles.add(roleRepository.findByName(Role.ERole.MEMBER)
                            .orElseThrow(() -> new RuntimeException("Error: Role MEMBER is not found.")));
                        break;
                }
            });
        }
        return roles;
    }

    // Helper to send WebSocket updates
    private void broadcastUserStats() {
        long totalUsers = userRepository.count();
        messagingTemplate.convertAndSend("/topic/dashboard/stats", Map.of("totalUsers", totalUsers));
    }
}
</file>

<file path="frontend/src/hooks/useWebSocket.ts">
import { useEffect, useRef, useState } from "react";
import { Client, IMessage } from "@stomp/stompjs";

const useWebSocket = (url: string, onMessage: (msg: IMessage) => void) => {
  const clientRef = useRef<Client | null>(null);
  const [connected, setConnected] = useState(false);
  const [retryCount, setRetryCount] = useState(0);
  const MAX_RETRIES = 3;

  useEffect(() => {
    const connect = () => {
      if (clientRef.current) return; // Prevent duplicate connects

      const stompClient = new Client({
        brokerURL: url.startsWith("ws") ? url : url.replace("http", "ws"),
        reconnectDelay: 5000,
        onConnect: () => {
          console.log("[WebSocket] ✅ Connected");
          setConnected(true);
          setRetryCount(0);
        },
        onDisconnect: () => {
          console.log("[WebSocket] ❌ Disconnected");
          setConnected(false);
        },
        onStompError: (frame) => {
          console.error("[WebSocket] STOMP error:", frame.headers["message"]);
        },
        onWebSocketClose: () => {
          console.log("[WebSocket] 🔌 Closed");
          setConnected(false);

          if (retryCount < MAX_RETRIES) {
            setRetryCount((r) => r + 1);
            console.log(`[WebSocket] Reconnecting... (${retryCount + 1}/${MAX_RETRIES})`);
            setTimeout(connect, 5000);
          } else {
            console.warn("[WebSocket] Reconnect attempts exceeded. Giving up.");
          }
        },
        onUnhandledMessage: onMessage,
      });

      stompClient.activate();
      clientRef.current = stompClient;
    };

    connect();

    return () => {
      console.log("🧹 Cleaning up WebSocket...");
      clientRef.current?.deactivate();
      clientRef.current = null;
    };
  }, [url, onMessage, retryCount]);

  const sendMessage = (destination: string, body: any) => {
    if (clientRef.current?.connected) {
      clientRef.current.publish({ destination, body: JSON.stringify(body) });
    }
  };

  return { connected, sendMessage };
};

export default useWebSocket;
</file>

<file path="frontend/src/pages/Dashboard/ManagerDashboard.jsx">
// File path: frontend/src/pages/Dashboard/ManagerDashboard.jsx
import React, { useState, useEffect } from 'react';
import { Grid, Card, CardContent, Typography, Box, Button } from '@mui/material';
import { Assignment, Group, TrendingUp, Add as AddIcon } from '@mui/icons-material';
import { motion } from 'framer-motion';
import { BarChart, Bar, XAxis, YAxis, Tooltip, Legend, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';
import Layout from '../../components/Layout/Layout';
import StatsCard from '../../components/Common/StatsCard';
import { getManagerDashboardStats } from '../../services/dashboardService';
import LoadingSpinner from '../../components/Common/LoadingSpinner';

const COLORS = ['#00C49F', '#FFBB28', '#FF8042']; // On Track, At Risk, Overdue
// Mock data for one chart (can be replaced later with live data)
const teamPerformanceData = [ { name: 'Frontend', tasks_completed: 45 }, { name: 'Backend', tasks_completed: 62 }, { name: 'Design', tasks_completed: 30 }, { name: 'QA', tasks_completed: 55 }, ];

const ManagerDashboard = () => {
    const [stats, setStats] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchStats = async () => {
            try {
                setLoading(true);
                const data = await getManagerDashboardStats();
                setStats(data);
            } catch (error) {
                console.error("Failed to fetch manager stats:", error);
                setStats({ totalProjects: 'Error', totalTeams: 'Error', tasksCompletedThisWeek: 'Error', projectsStatusData: [] });
            } finally {
                setLoading(false);
            }
        };
        fetchStats();
    }, []);

    if (loading || !stats) {
        return (
            <Layout>
                <LoadingSpinner message="Loading Manager Dashboard..." />
            </Layout>
        );
    }

    return (
        <Layout>
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }}>
                <Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
                    <Box>
                        <Typography variant="h4" fontWeight="bold">Manager's Overview</Typography>
                        <Typography variant="body1" color="text.secondary">Monitor team performance and project health across the organization.</Typography>
                    </Box>
                    <Button variant="contained" startIcon={<AddIcon />}>Invite User</Button>
                </Box>
                
                <Grid container spacing={3}>
                    <Grid item xs={12} sm={4}><StatsCard title="Total Projects" value={stats.totalProjects} icon={<Assignment />} color="primary" /></Grid>
                    <Grid item xs={12} sm={4}><StatsCard title="Active Teams" value={stats.totalTeams} icon={<Group />} color="secondary" /></Grid>
                    <Grid item xs={12} sm={4}><StatsCard title="Tasks Completed This Week" value={stats.tasksCompletedThisWeek} icon={<TrendingUp />} color="success" /></Grid>

                    <Grid item xs={12} md={7}>
                        <Card sx={{ height: '100%' }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>Team Performance (Tasks Completed)</Typography>
                                <ResponsiveContainer width="100%" height={300}>
                                    <BarChart data={teamPerformanceData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
                                        <XAxis dataKey="name" />
                                        <YAxis />
                                        <Tooltip />
                                        <Legend />
                                        <Bar dataKey="tasks_completed" fill="#8884d8" />
                                    </BarChart>
                                </ResponsiveContainer>
                            </CardContent>
                        </Card>
                    </Grid>
                    <Grid item xs={12} md={5}>
                         <Card sx={{ height: '100%' }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>Overall Project Health</Typography>
                                {/* --- FIX: USING LIVE DATA --- */}
                                {stats.projectsStatusData && (
                                    <ResponsiveContainer width="100%" height={300}>
                                        <PieChart>
                                            <Pie data={stats.projectsStatusData} cx="50%" cy="50%" labelLine={false} outerRadius={100} fill="#8884d8" dataKey="value" label={({ name, value }) => `${name}: ${value}`}>
                                                {stats.projectsStatusData.map((entry, index) => (<Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />))}
                                            </Pie>
                                            <Tooltip />
                                        </PieChart>
                                    </ResponsiveContainer>
                                )}
                            </CardContent>
                        </Card>
                    </Grid>
                </Grid>
            </motion.div>
        </Layout>
    );
};

export default ManagerDashboard;
</file>

<file path="frontend/src/pages/Dashboard/MemberDashboard.jsx">
// File path: frontend/src/pages/Dashboard/MemberDashboard.jsx
import React, { useState, useEffect } from 'react';
import { useSelector } from 'react-redux';
import { Grid, Card, CardContent, Typography, Box } from '@mui/material';
import { Assignment, Group, TrendingUp } from '@mui/icons-material';
import { motion } from 'framer-motion';
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';
import Layout from '../../components/Layout/Layout';
import StatsCard from '../../components/Common/StatsCard';
import { selectUser } from '../../store/slices/authSlice';
import { getMemberDashboardStats } from '../../services/dashboardService';
import LoadingSpinner from '../../components/Common/LoadingSpinner';

const COLORS = ['#FFBB28', '#00C49F', '#0088FE']; // To Do, In Progress, Done
// Mock data for one chart
const myProjectsData = [ { name: 'Website Redesign', progress: 75 }, { name: 'Mobile App', progress: 40 }, { name: 'API Integration', progress: 90 }, ];

const MemberDashboard = () => {
    const user = useSelector(selectUser);
    const [stats, setStats] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchStats = async () => {
            try {
                setLoading(true);
                const data = await getMemberDashboardStats();
                setStats(data);
            } catch (error) {
                console.error("Failed to fetch member stats:", error);
                setStats({ myProjects: 'Error', myTeams: 'Error', myTasksDue: 'Error', myTasksData: [] });
            } finally {
                setLoading(false);
            }
        };
        fetchStats();
    }, []);

    if (loading || !stats) {
        return (
            <Layout>
                <LoadingSpinner message="Loading Your Dashboard..." />
            </Layout>
        );
    }

    return (
        <Layout>
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }}>
                <Typography variant="h4" fontWeight="bold" gutterBottom>
                    Welcome back, {user?.firstName}!
                </Typography>
                <Typography variant="body1" color="text.secondary" sx={{ mb: 4 }}>
                    Here's your personal summary of what's happening today.
                </Typography>

                <Grid container spacing={3}>
                    <Grid item xs={12} sm={4}><StatsCard title="My Active Projects" value={stats.myProjects} icon={<Assignment />} color="primary" /></Grid>
                    <Grid item xs={12} sm={4}><StatsCard title="My Teams" value={stats.myTeams} icon={<Group />} color="secondary" /></Grid>
                    <Grid item xs={12} sm={4}><StatsCard title="My Tasks Due" value={stats.myTasksDue} icon={<TrendingUp />} color="success" /></Grid>

                    <Grid item xs={12} md={7}>
                        <Card sx={{ height: '100%' }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>My Project Progress</Typography>
                                <ResponsiveContainer width="100%" height={300}>
                                    <BarChart data={myProjectsData} layout="vertical" margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
                                        <XAxis type="number" />
                                        <YAxis dataKey="name" type="category" width={120} />
                                        <Tooltip />
                                        <Bar dataKey="progress" fill="#8884d8" barSize={20} />
                                    </BarChart>
                                </ResponsiveContainer>
                            </CardContent>
                        </Card>
                    </Grid>
                    <Grid item xs={12} md={5}>
                         <Card sx={{ height: '100%' }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>My Task Status</Typography>
                                {/* --- FIX: USING LIVE DATA --- */}
                                {stats.myTasksData && (
                                    <ResponsiveContainer width="100%" height={300}>
                                        <PieChart>
                                            <Pie data={stats.myTasksData} cx="50%" cy="50%" labelLine={false} outerRadius={100} fill="#8884d8" dataKey="value" label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}>
                                                {stats.myTasksData.map((entry, index) => (<Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />))}
                                            </Pie>
                                            <Tooltip />
                                        </PieChart>
                                    </ResponsiveContainer>
                                )}
                            </CardContent>
                        </Card>
                    </Grid>
                </Grid>
            </motion.div>
        </Layout>
    );
};

export default MemberDashboard;
</file>

<file path="frontend/src/pages/Projects/ProjectsPage.jsx">
// File path: frontend/src/pages/Projects/ProjectsPage.jsx
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import {
    Box, Grid, Card, CardContent, CardActions, Button,
    Typography, CircularProgress, Alert
} from '@mui/material';
import { Add as AddIcon, Folder as FolderIcon } from '@mui/icons-material';
import { motion } from 'framer-motion';
import toast from 'react-hot-toast';

import Layout from '../../components/Layout/Layout';
import { getMyProjects, createProject } from '../../services/projectService';
import ProjectModal from './ProjectModal.jsx';

const ProjectsPage = () => {
    const [projects, setProjects] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    
    const fetchProjects = async () => {
        try {
            // No need to set loading to true here, handled in initial load
            const projectsData = await getMyProjects();
            setProjects(projectsData);
        } catch (err) {
            console.error("Failed to fetch projects:", err);
            setError("Could not load your projects. Please try refreshing the page.");
            toast.error("Failed to load projects.");
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        setLoading(true);
        fetchProjects();
    }, []);

    const handleOpenModal = () => {
        setIsModalOpen(true);
    };
    
    const handleCloseModal = () => {
        setIsModalOpen(false);
    };

    const handleSaveProject = async (projectData) => {
        try {
            await createProject(projectData);
            toast.success("Project created successfully!");
            handleCloseModal();
            // Set loading to true while we re-fetch
            setLoading(true);
            await fetchProjects();
        } catch (error) {
            console.error("Failed to create project:", error);
            toast.error(error.message || "Failed to create project.");
        }
    };

    const renderContent = () => {
        if (loading) {
            return (
                <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
                    <CircularProgress />
                </Box>
            );
        }
        if (error) {
            return <Alert severity="error">{error}</Alert>;
        }
        if (projects.length === 0) {
            return (
                <Box sx={{ textAlign: 'center', mt: 4, py: 8 }}>
                    <FolderIcon sx={{ fontSize: 60, color: 'text.secondary' }} />
                    <Typography variant="h6" mt={2}>No projects yet!</Typography>
                    <Typography color="text.secondary">Get started by creating your first project.</Typography>
                </Box>
            );
        }
        return (
            <Grid container spacing={3}>
                {projects.map(project => (
                    <Grid item xs={12} sm={6} md={4} key={project.id}>
                        <motion.div whileHover={{ y: -5 }}>
                            <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column', border: '1px solid rgba(0,0,0,0.1)' }}>
                                <CardContent sx={{ flexGrow: 1 }}>
                                    <Typography gutterBottom variant="h5" component="h2">{project.name}</Typography>
                                    {/* Using noWrap to prevent long descriptions from breaking the layout */}
                                    <Typography color="text.secondary" noWrap sx={{height: 20}}>
                                        {project.description}
                                    </Typography>
                                </CardContent>
                                <CardActions>
                                    <Button size="small" component={Link} to={`/projects/${project.id}`}>View Details</Button>
                                </CardActions>
                            </Card>
                        </motion.div>
                    </Grid>
                ))}
            </Grid>
        );
    };

    return (
        <Layout>
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }}>
                <Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
                    <Box>
                        <Typography variant="h4" fontWeight="bold">My Projects</Typography>
                        <Typography color="text.secondary">All projects you are a member of.</Typography>
                    </Box>
                    <Button
                        variant="contained"
                        startIcon={<AddIcon />}
                        onClick={handleOpenModal} // <-- This now correctly opens the modal
                    >
                        Create Project
                    </Button>
                </Box>
                {renderContent()}

                <ProjectModal 
                    open={isModalOpen}
                    onClose={handleCloseModal}
                    onSave={handleSaveProject}
                />
            </motion.div>
        </Layout>
    );
};

export default ProjectsPage;
</file>

<file path="frontend/src/services/dashboardService.ts">
// File path: frontend/src/services/dashboardService.ts
import apiClient from './apiClient';
import { DashboardStats, Activity } from '../types';

// The generic type <T> in apiClient.get<T> tells the client what shape the "data" property will have.
// The client then returns that data directly.

export const getAdminDashboardStats = async (): Promise<{ totalUsers: number, totalProjects: number, totalTeams: number, roleDistribution: any[], userGrowth: any[] }> => {
  // FIX: The apiClient returns the data directly. We do not need to access a .data property.
  const response = await apiClient.get('/api/dashboard/admin');
  return response;
};

export const getManagerDashboardStats = async (): Promise<{ totalProjects: number, totalTeams: number, tasksCompletedThisWeek: number }> => {
  const response = await apiClient.get('/api/dashboard/manager');
  return response;
};

export const getMemberDashboardStats = async (): Promise<{ myProjects: number, myTeams: number, myTasksDue: number }> => {
  const response = await apiClient.get('/api/dashboard/member');
  return response;
};

export const getDashboardStats = async (): Promise<DashboardStats> => {
  const response = await apiClient.get<DashboardStats>('/api/dashboard/stats');
  return response;
};

export const getRecentActivities = async (limit: number = 10): Promise<Activity[]> => {
  const response = await apiClient.get<Activity[]>(`/api/dashboard/activities?limit=${limit}`);
  return response;
};

export const getSystemHealth = async (): Promise<{
  status: 'healthy' | 'warning' | 'critical';
  uptime: number;
  memoryUsage: number;
  cpuUsage: number;
  diskUsage: number;
  activeUsers: number;
  requestsPerMinute: number;
}> => {
  const response = await apiClient.get('/api/dashboard/system/health');
  return response;
};
</file>

<file path="frontend/vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      "/api": {
        target: "http://localhost:8080",
        changeOrigin: true,
        secure: false,
      },
      "/ws": {
        target: "http://localhost:8080",
        ws: true,
        changeOrigin: true,
      },
    },
  },
});
</file>

<file path="backend/src/main/java/com/collabris/dto/response/ChatMessageResponse.java">
package com.collabris.dto.response;

import com.collabris.entity.ChatMessage;
import java.time.LocalDateTime;

public class ChatMessageResponse {
    private Long id;
    private String content;
    private LocalDateTime timestamp;
    private UserResponse sender;
    private Long chatRoomId;

    public ChatMessageResponse(ChatMessage message) {
        this.id = message.getId();
        this.content = message.getContent();
        this.timestamp = message.getTimestamp();
        this.sender = new UserResponse(message.getSender());
        this.chatRoomId = message.getChatRoom().getId();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
    public UserResponse getSender() { return sender; }
    public void setSender(UserResponse sender) { this.sender = sender; }
    public Long getChatRoomId() { return chatRoomId; }
    public void setChatRoomId(Long chatRoomId) { this.chatRoomId = chatRoomId; }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/ChatMessage.java">
package com.collabris.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "chat_messages")
public class ChatMessage {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "sender_id", nullable = false)
    private User sender;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "chat_room_id", nullable = false)
    private ChatRoom chatRoom;

    @Column(nullable = false)
    private LocalDateTime timestamp;

    @PrePersist
    protected void onCreate() {
        this.timestamp = LocalDateTime.now();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }
    public User getSender() { return sender; }
    public void setSender(User sender) { this.sender = sender; }
    public ChatRoom getChatRoom() { return chatRoom; }
    public void setChatRoom(ChatRoom chatRoom) { this.chatRoom = chatRoom; }
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/Team.java">
// File Path: backend/src/main/java/com/collabris/entity/Team.java
package com.collabris.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "teams")
public class Team {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "owner_id", nullable = false)
    private User owner;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(name = "team_members",
            joinColumns = @JoinColumn(name = "team_id"),
            inverseJoinColumns = @JoinColumn(name = "user_id"))
    private Set<User> members = new HashSet<>();
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
    
    // --- THIS IS THE FIX ---
    public void addMember(User user) {
        this.members.add(user);
    }
    
    public void removeMember(User user) {
        this.members.remove(user);
    }
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public User getOwner() { return owner; }
    public void setOwner(User owner) { this.owner = owner; }
    public Set<User> getMembers() { return members; }
    public void setMembers(Set<User> members) { this.members = members; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}
</file>

<file path="backend/src/main/java/com/collabris/repository/ChatMessageRepository.java">
package com.collabris.repository;

import com.collabris.entity.ChatMessage;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface ChatMessageRepository extends JpaRepository<ChatMessage, Long> {
    List<ChatMessage> findByChatRoomIdOrderByTimestampAsc(Long chatRoomId);
}
</file>

<file path="backend/src/main/java/com/collabris/service/ChatService.java">
package com.collabris.service;

import com.collabris.dto.response.ChatMessageResponse;
import com.collabris.entity.ChatMessage;
import com.collabris.entity.ChatRoom;
import com.collabris.entity.Project;
import com.collabris.entity.User;
import com.collabris.repository.ChatMessageRepository;
import com.collabris.repository.ProjectRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

@Service
@Transactional
public class ChatService {

    @Autowired
    private ChatMessageRepository chatMessageRepository;
    @Autowired
    private ProjectRepository projectRepository;

    public ChatMessage saveMessage(String content, Long projectId, User sender) {
        Project project = projectRepository.findById(projectId)
                .orElseThrow(() -> new NoSuchElementException("Project not found with ID: " + projectId));
        
        ChatRoom chatRoom = project.getChatRoom();
        if (chatRoom == null) {
            throw new IllegalStateException("Project " + projectId + " does not have an associated chat room.");
        }

        ChatMessage message = new ChatMessage();
        message.setContent(content);
        message.setChatRoom(chatRoom);
        message.setSender(sender);
        return chatMessageRepository.save(message);
    }

    public List<ChatMessageResponse> getMessagesForProject(Long projectId) {
        Project project = projectRepository.findById(projectId)
                .orElseThrow(() -> new NoSuchElementException("Project not found with ID: " + projectId));

        ChatRoom chatRoom = project.getChatRoom();
        if (chatRoom == null) {
            return List.of();
        }

        return chatMessageRepository.findByChatRoomIdOrderByTimestampAsc(chatRoom.getId())
                .stream()
                .map(ChatMessageResponse::new)
                .collect(Collectors.toList());
    }
}
</file>

<file path="frontend/src/components/Admin/UserModal.jsx">
import React, { useState, useEffect } from 'react';
import {
    Dialog, DialogTitle, DialogContent, DialogActions, Button, TextField,
    Grid, FormControlLabel, Switch, FormGroup, Checkbox, Typography
} from '@mui/material';
import { useForm, Controller } from 'react-hook-form';

const UserModal = ({ open, onClose, onSave, user }) => {
    const { control, handleSubmit, reset, formState: { errors } } = useForm();
    const isEditing = !!user;

    useEffect(() => {
        if (open) {
            if (user) {
                reset({
                    username: user.username || '', email: user.email || '',
                    firstName: user.firstName || '', lastName: user.lastName || '',
                    enabled: user.enabled || false,

                    formRoles: user.roles || [],
                });
            } else {
                reset({
                    username: '', email: '', firstName: '', lastName: '', password: '',
                    enabled: true,
                    // Default new users to just the MEMBER role
                    formRoles: ['MEMBER'],
                });
            }
        }
    }, [user, open, reset]);

    const onSubmit = (data) => {
        //  directly use the 'formRoles' from the form data now, which is an array.
        // ensure the property name is 'roles' for the API call.
        const finalUserData = { 
            ...data, 
            roles: data.formRoles 
        };
        delete finalUserData.formRoles; // Clean up the temporary form field

        onSave(finalUserData, user?.id);
    };

    const handleRoleChange = (role, checked) => {
        const currentRoles = control._formValues.formRoles || [];
        if (checked) {
            // Add the role if it's not already there
            reset({ ...control._formValues, formRoles: [...new Set([...currentRoles, role])] });
        } else {
            // Remove the role
            reset({ ...control._formValues, formRoles: currentRoles.filter(r => r !== role) });
        }
    };
    
    return (
        <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
            <DialogTitle>{isEditing ? 'Edit User' : 'Create New User'}</DialogTitle>
            <form onSubmit={handleSubmit(onSubmit)}>
                <DialogContent>
                    <Grid container spacing={2} sx={{ mt: 1 }}>
                        <Grid item xs={12} sm={6}>
                            <Controller name="firstName" control={control} render={({ field }) => ( <TextField {...field} label="First Name" fullWidth required /> )}/>
                        </Grid>
                        <Grid item xs={12} sm={6}>
                            <Controller name="lastName" control={control} render={({ field }) => ( <TextField {...field} label="Last Name" fullWidth required /> )}/>
                        </Grid>
                        <Grid item xs={12} sm={6}>
                            <Controller name="username" control={control} render={({ field }) => ( <TextField {...field} label="Username" fullWidth required /> )}/>
                        </Grid>
                        <Grid item xs={12} sm={6}>
                            <Controller name="email" control={control} render={({ field }) => ( <TextField {...field} label="Email" type="email" fullWidth required /> )}/>
                        </Grid>
                        <Grid item xs={12}>
                             <Controller name="password" control={control} render={({ field }) => (
                                <TextField {...field} label="Password" type="password" fullWidth
                                    helperText={isEditing ? "Leave blank to keep current password" : "Required for new user"}
                                    required={!isEditing} />
                            )} />
                        </Grid>
                        <Grid item xs={12}>
                             <Controller name="enabled" control={control} defaultValue={true} render={({ field }) => ( <FormControlLabel control={<Switch {...field} checked={field.value} />} label="User Enabled" /> )}/>
                        </Grid>
                        <Grid item xs={12}>
                            <Typography variant="subtitle2">Roles</Typography>
                            <Controller name="formRoles" control={control} defaultValue={[]} render={({ field }) => (
                                <FormGroup>
                                    <FormControlLabel control={<Checkbox checked={field.value.includes('MEMBER')} onChange={(e) => handleRoleChange('MEMBER', e.target.checked)} />} label="Member" />
                                    <FormControlLabel control={<Checkbox checked={field.value.includes('MANAGER')} onChange={(e) => handleRoleChange('MANAGER', e.target.checked)} />} label="Manager" />
                                    <FormControlLabel control={<Checkbox checked={field.value.includes('ADMIN')} onChange={(e) => handleRoleChange('ADMIN', e.target.checked)} />} label="Admin" />
                                </FormGroup>
                            )} />
                        </Grid>
                    </Grid>
                </DialogContent>
                <DialogActions>
                    <Button onClick={onClose}>Cancel</Button>
                    <Button type="submit" variant="contained">{isEditing ? 'Save Changes' : 'Create User'}</Button>
                </DialogActions>
            </form>
        </Dialog>
    );
};

export default UserModal;
</file>

<file path="frontend/src/hooks/useTheme.ts">
// File path: frontend/src/hooks/useTheme.ts
import { useMemo } from 'react';
import { useAppSelector } from '../store/store';
import { selectEffectiveTheme } from '../store/slices/themeSlice';
// FIX: This now imports the one and only function exported from your theme.ts
import { createCollabrisTheme } from '../theme/theme';

export const useTheme = () => {
  const themeMode = useAppSelector(selectEffectiveTheme);

  // This hook now correctly calls your existing `createCollabrisTheme` function
  // to generate the appropriate MUI theme object based on the current mode ('light' or 'dark').
  const theme = useMemo(
    () => createCollabrisTheme(themeMode),
    [themeMode]
  );

  // It returns the theme object and the theme mode string.
  return [theme, themeMode] as const;
};
</file>

<file path="frontend/src/pages/Dashboard/AdminDashboard.jsx">
// File Path: frontend/src/pages/Dashboard/AdminDashboard.jsx
import React, { useState, useEffect } from 'react';
import { Grid, Card, CardContent, Typography, Box, Button } from '@mui/material';
import { PeopleAlt, FolderSpecial, Dns, Add as AddIcon } from '@mui/icons-material';
import { motion } from 'framer-motion';
import { LineChart, Line, XAxis, YAxis, Tooltip, Legend, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';
import toast from 'react-hot-toast';

import Layout from '../../components/Layout/Layout';
import StatsCard from '../../components/Common/StatsCard';
import { getAdminDashboardStats } from '../../services/dashboardService';
import { getAllUsers, createUser, updateUser, deleteUser } from '../../services/userService';
import LoadingSpinner from '../../components/Common/LoadingSpinner';
import UserTable from '../../components/Admin/UserTable';
import UserModal from '../../components/Admin/UserModal';

const COLORS = ['#FF8042', '#FFBB28', '#0088FE']; // For Admins, Managers, Members

const AdminDashboard = () => {
    const [stats, setStats] = useState(null);
    const [users, setUsers] = useState([]);
    const [loading, setLoading] = useState(true);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [editingUser, setEditingUser] = useState(null);

    const fetchAllData = async () => {
        try {
            // No need to set loading here, it's already true
            const [statsData, usersData] = await Promise.all([
                getAdminDashboardStats(),
                getAllUsers(),
            ]);
            setStats(statsData);
            setUsers(usersData);
        } catch (error) {
            toast.error("Failed to load dashboard data. Please refresh.");
            console.error(error);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchAllData();
    }, []);

    const handleOpenModal = (user = null) => {
        setEditingUser(user);
        setIsModalOpen(true);
    };

    const handleCloseModal = () => {
        setIsModalOpen(false);
        setEditingUser(null);
    };

    const handleSaveUser = async (userData, userId) => {
        try {
            if (userId) {
                await updateUser(userId, userData);
                toast.success("User updated successfully!");
            } else {
                await createUser(userData);
                toast.success("User created successfully!");
            }
            handleCloseModal();
            fetchAllData(); 
        } catch (error) {
            toast.error(error.message || "Failed to save user.");
            console.error(error);
        }
    };
    
    const handleDeleteUser = async (userId) => {
        if (window.confirm("Are you sure you want to delete this user? This action cannot be undone.")) {
            try {
                await deleteUser(userId);
                toast.success("User deleted successfully!");
                fetchAllData(); 
            } catch (error) {
                toast.error(error.message || "Failed to delete user.");
                console.error(error);
            }
        }
    };
    
    // --- THIS IS THE KEY FIX ---
    // Show a loading spinner if we are in the initial loading state OR if stats is still null.
    // This prevents any rendering attempt before the data is ready.
    if (loading || !stats) {
        return <Layout><LoadingSpinner message="Loading Admin Dashboard..." /></Layout>;
    }

    return (
        <Layout>
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }}>
                <Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
                    <Box>
                        <Typography variant="h4" fontWeight="bold" gutterBottom>System Administration</Typography>
                        <Typography variant="body1" color="text.secondary">Manage users, monitor platform health, and view system-wide analytics.</Typography>
                    </Box>
                    <Button variant="contained" startIcon={<AddIcon />} onClick={() => handleOpenModal()}>Create New User</Button>
                </Box>

                <Grid container spacing={3}>
                    {/* These will now render safely */}
                    <Grid item xs={12} sm={4}><StatsCard title="Total Users" value={stats.totalUsers} icon={<PeopleAlt />} color="primary" /></Grid>
                    <Grid item xs={12} sm={4}><StatsCard title="Total Projects" value={stats.totalProjects} icon={<FolderSpecial />} color="secondary" /></Grid>
                    <Grid item xs={12} sm={4}><StatsCard title="Total Teams" value={stats.totalTeams} icon={<Dns />} color="success" /></Grid>

                    <Grid item xs={12} md={7}>
                        <Card sx={{ height: '100%' }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>User Growth (Last 6 Months)</Typography>
                                {/* Safety check for userGrowth array */}
                                {stats.userGrowth && (
                                    <ResponsiveContainer width="100%" height={300}>
                                        <LineChart data={stats.userGrowth} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
                                            <XAxis dataKey="name" />
                                            <YAxis />
                                            <Tooltip />
                                            <Legend />
                                            <Line type="monotone" dataKey="users" stroke="#8884d8" activeDot={{ r: 8 }} />
                                        </LineChart>
                                    </ResponsiveContainer>
                                )}
                            </CardContent>
                        </Card>
                    </Grid>
                    <Grid item xs={12} md={5}>
                         <Card sx={{ height: '100%' }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>User Role Distribution</Typography>
                                {/* Safety check for roleDistribution array */}
                                {stats.roleDistribution && (
                                    <ResponsiveContainer width="100%" height={300}>
                                        <PieChart>
                                            <Pie data={stats.roleDistribution} cx="50%" cy="50%" labelLine={false} outerRadius={100} fill="#8884d8" dataKey="value" label={({ name, value }) => `${name}: ${value}`}>
                                                {stats.roleDistribution.map((entry, index) => (<Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />))}
                                            </Pie>
                                            <Tooltip />
                                        </PieChart>
                                    </ResponsiveContainer>
                                )}
                            </CardContent>
                        </Card>
                    </Grid>
                    
                    <Grid item xs={12}>
                        <Card>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>User Management</Typography>
                                {/* Safety check for the users array */}
                                {users && (
                                    <UserTable users={users} onEdit={handleOpenModal} onDelete={handleDeleteUser} />
                                )}
                            </CardContent>
                        </Card>
                    </Grid>
                </Grid>

                <UserModal
                    open={isModalOpen}
                    onClose={handleCloseModal}
                    onSave={handleSaveUser}
                    user={editingUser}
                />
            </motion.div>
        </Layout>
    );
};

export default AdminDashboard;
</file>

<file path="frontend/src/services/userService.ts">
// File path: frontend/src/services/userService.ts
import apiClient from './apiClient';
import { User } from '../types';

// This is the type for the data sent when an admin creates/updates a user
export interface AdminUserUpdateRequest {
    id?: number;
    username: string;
    email: string;
    firstName: string;
    lastName: string;
    password?: string;
    enabled: boolean;
    roles: string[];
}

// Function to get the currently logged-in user's details
export const getCurrentUser = async (): Promise<User> => {
    const response = await apiClient.get('/api/users/me');
    return response;
};

// --- CORRECTED ADMIN FUNCTIONS ---

// Function for an ADMIN to get a list of all users
export const getAllUsers = async (): Promise<User[]> => {
    const response = await apiClient.get('/api/users');
    return response;
};

// Function for an ADMIN to create a new user
export const createUser = async (userData: AdminUserUpdateRequest): Promise<User> => {
    const response = await apiClient.post('/api/users', userData);
    return response;
};

// Function for an ADMIN to update an existing user
export const updateUser = async (userId: number, userData: AdminUserUpdateRequest): Promise<User> => {
    const response = await apiClient.put(`/api/users/${userId}`, userData);
    return response;
};

// Function for an ADMIN to delete a user
export const deleteUser = async (userId: number): Promise<any> => {
    const response = await apiClient.delete(`/api/users/${userId}`);
    return response;
};
</file>

<file path="frontend/src/types/index.ts">
// File path: frontend/src/types/index.ts

// --- USER & AUTH TYPES ---
export interface User {
  id: number;
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  enabled: boolean;
  roles: string[]; 
  profilePicture?: string;
  createdAt: string;
  updatedAt?: string;
}

export interface LoginRequest {
  username: string;
  password: string;
}

export interface SignupRequest {
  username: string;
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  role?: string[];
}

export interface AuthResponse {
  token: string;
  type: string;
  user: User;
}

// --- PROJECT & TEAM TYPES ---

export interface Project {
  id: number;
  name: string;
  description: string;
  owner: User;
  members: User[];
  createdAt: string;
}

export interface ProjectRequest {
  name: string;
  description?: string;
}

// THIS IS THE MISSING PIECE
export interface Team {
    id: number;
    name: string;
    description: string;
    owner: User;
    members: User[];
    createdAt: string;
}

export interface TeamRequest {
  name: string;
  description?: string;
}
// END OF MISSING PIECE


// --- ALL OTHER TYPES BELOW THIS LINE ARE FOR FUTURE USE ---

// Chat types
export interface ChatRoom {
  id: number;
  name: string;
  description?: string;
  type: 'DIRECT' | 'GROUP' | 'TEAM' | 'PROJECT';
  createdAt: string;
  updatedAt: string;
  members: User[];
  lastMessage?: ChatMessage;
}

export interface ChatMessage {
  id: number;
  content: string;
  messageType: 'TEXT' | 'IMAGE' | 'FILE';
  timestamp: string;
  sender: User;
  chatRoom: ChatRoom;
  edited?: boolean;
  editedAt?: string;
}

export interface ChatMessageRequest {
  content: string;
  messageType: ChatMessage['messageType'];
  chatRoomId: number;
}

export interface ChatRoomRequest {
  name: string;
  description?: string;
  type: ChatRoom['type'];
  memberIds: number[];
}

// UI State types
export interface LoadingState {
  [key: string]: boolean;
}

export interface ErrorState {
  [key: string]: string | null;
}

// Theme types
export type ThemeMode = 'light' | 'dark' | 'system';

// API Response types
export interface ApiResponse<T = any> {
  data: T;
  message?: string;
  success: boolean;
}

export interface ApiError {
  message: string;
  status: number;
  details?: any;
}

// Pagination types
export interface PaginationParams {
  page?: number;
  size?: number;
  sort?: string;
  direction?: 'ASC' | 'DESC';
}

export interface PaginatedResponse<T> {
  content: T[];
  totalElements: number;
  totalPages: number;
  size: number;
  number: number;
  first: boolean;
  last: boolean;
  numberOfElements: number;
}

// Dashboard types
export interface DashboardStats {
  totalUsers?: number;
  totalTeams?: number;
  totalProjects?: number;
  activeProjects?: number;
  completedProjects?: number;
  totalMessages?: number;
  userGrowth?: number;
  projectProgress?: {
    completed: number;
    inProgress: number;
    planning: number;
    onHold: number;
  };
  recentActivities?: Activity[];
}

export interface Activity {
  id: number;
  type: 'USER_JOINED' | 'PROJECT_CREATED' | 'TEAM_CREATED' | 'MESSAGE_SENT' | 'PROJECT_COMPLETED';
  description: string;
  user?: User;
  entity?: string;
  entityId?: number;
  timestamp: string;
}

// Form types
export interface FormErrors {
  [key: string]: string | undefined;
}

// File upload types
export interface FileUpload {
  file: File;
  progress: number;
  status: 'pending' | 'uploading' | 'completed' | 'error';
  url?: string;
}

// Notification types
export interface Notification {
  id: string;
  type: 'success' | 'error' | 'warning' | 'info';
  title: string;
  message: string;
  duration?: number;
  actions?: NotificationAction[];
}

export interface NotificationAction {
  label: string;
  onClick: () => void;
  variant?: 'text' | 'outlined' | 'contained';
}

// WebSocket types
export interface WebSocketMessage {
  type: string;
  payload: any;
  timestamp: string;
}
</file>

<file path="backend/src/main/java/com/collabris/controller/ProjectController.java">
package com.collabris.controller;

import com.collabris.dto.request.ProjectRequest;
import com.collabris.dto.response.ProjectResponse;
import com.collabris.entity.User;
import com.collabris.service.ProjectService;
import com.collabris.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/projects")
public class ProjectController {

    @Autowired
    private ProjectService projectService;
    @Autowired
    private UserService userService;

    private User getCurrentUser(UserDetails userDetails) {
        return userService.findByUsername(userDetails.getUsername())
                .orElseThrow(() -> new RuntimeException("Error: Authenticated user not found in database."));
    }

    @PostMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ProjectResponse> createProject(@RequestBody ProjectRequest request, @AuthenticationPrincipal UserDetails userDetails) {
        // FIX: Service now returns the correct DTO directly
        return ResponseEntity.ok(projectService.createProject(request, getCurrentUser(userDetails)));
    }

    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<ProjectResponse>> getAllForCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        return ResponseEntity.ok(projectService.getProjectsByMemberId(getCurrentUser(userDetails).getId()));
    }

    @GetMapping("/{projectId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ProjectResponse> getProject(@PathVariable Long projectId) {
        return ResponseEntity.ok(projectService.getProjectById(projectId));
    }

    @PutMapping("/{projectId}")
    @PreAuthorize("hasRole('ADMIN') or @projectRepository.findById(#projectId).get().getOwner().getUsername() == authentication.name")
    public ResponseEntity<ProjectResponse> updateProject(@PathVariable Long projectId, @RequestBody ProjectRequest request) {
        // FIX: Service now returns the correct DTO directly
        return ResponseEntity.ok(projectService.updateProject(projectId, request));
    }

    @DeleteMapping("/{projectId}")
    @PreAuthorize("hasRole('ADMIN') or @projectRepository.findById(#projectId).get().getOwner().getUsername() == authentication.name")
    public ResponseEntity<Void> deleteProject(@PathVariable Long projectId) {
        projectService.deleteProject(projectId);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{projectId}/members/{userId}")
    @PreAuthorize("hasRole('ADMIN') or @projectRepository.findById(#projectId).get().getOwner().getUsername() == authentication.name")
    public ResponseEntity<ProjectResponse> addMemberToProject(@PathVariable Long projectId, @PathVariable Long userId) {
        return ResponseEntity.ok(projectService.addMemberToProject(projectId, userId));
    }

    @DeleteMapping("/{projectId}/members/{userId}")
    @PreAuthorize("hasRole('ADMIN') or @projectRepository.findById(#projectId).get().getOwner().getUsername() == authentication.name")
    public ResponseEntity<ProjectResponse> removeMemberFromProject(@PathVariable Long projectId, @PathVariable Long userId) {
        return ResponseEntity.ok(projectService.removeMemberFromProject(projectId, userId));
    }
}
</file>

<file path="backend/src/main/resources/application.properties">
# Database Configuration
spring.datasource.url=jdbc:postgresql://ep-aged-pine-aevx5u5z-pooler.c-2.us-east-2.aws.neon.tech:5432/neondb?sslmode=require&channel_binding=require
spring.datasource.username=neondb_owner
spring.datasource.password=npg_EKxh9oIm5FdZ
spring.datasource.driver-class-name=org.postgresql.Driver

# --- ROBUST HIKARI SETTINGS FOR SERVERLESS/CLOUD DATABASES ---
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.keepalive-time=600000
spring.datasource.hikari.idle-timeout=600000
# THIS IS THE FINAL KEY SETTING:
# It forces Hikari to test if a connection is still alive before using it.
# This prevents the "connection has been closed" warnings.
spring.datasource.hikari.validation-timeout=3000

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.open-in-view=false

# JWT Configuration
jwt.secret=c40031d66765c9a385adb9980ceb96dcd1bf21aba01b96978357b22a255e82f9
jwt.expiration=86400000

# Server Configuration
server.port=8080

# Swagger/OpenAPI Configuration
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method

# CORS Configuration - Update for production
cors.allowed-origins=http://localhost:5173

# Jackson Configuration
spring.jackson.serialization.fail-on-empty-beans=false

# File Upload Configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
file.upload-dir=uploads

# Email Configuration
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=sibomanaelissa71@gmail.com
spring.mail.password=wdhapdculcihbvnk
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

# App Mail Configuration
app.mail.enabled=true
app.mail.from=no-reply@collabris.com

# Logging Configuration
logging.level.com.collabris=INFO
logging.level.org.springframework.security=INFO
</file>

<file path="backend/src/main/java/com/collabris/entity/Project.java">
package com.collabris.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "projects")
public class Project {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "owner_id", nullable = false)
    private User owner;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(name = "project_members",
            joinColumns = @JoinColumn(name = "project_id"),
            inverseJoinColumns = @JoinColumn(name = "user_id"))
    private Set<User> members = new HashSet<>();

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id")
    private Team team;
    
    @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = "chat_room_id", referencedColumnName = "id")
    private ChatRoom chatRoom;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() { this.createdAt = LocalDateTime.now(); }
    @PreUpdate
    protected void onUpdate() { this.updatedAt = LocalDateTime.now(); }
    
    public void addMember(User user) { this.members.add(user); }
    public void removeMember(User user) { this.members.remove(user); }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public User getOwner() { return owner; }
    public void setOwner(User owner) { this.owner = owner; }
    public Set<User> getMembers() { return members; }
    public void setMembers(Set<User> members) { this.members = members; }
    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }
    public ChatRoom getChatRoom() { return chatRoom; }
    public void setChatRoom(ChatRoom chatRoom) { this.chatRoom = chatRoom; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
}
</file>

<file path="backend/src/main/java/com/collabris/service/ProjectService.java">
package com.collabris.service;

import com.collabris.dto.request.ProjectRequest;
import com.collabris.dto.response.ProjectResponse;
import com.collabris.entity.ChatRoom;
import com.collabris.entity.Project;
import com.collabris.entity.User;
import com.collabris.repository.ProjectRepository;
import com.collabris.repository.UserRepository;
import org.hibernate.Hibernate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

@Service
@Transactional(readOnly = true)
public class ProjectService {

    @Autowired
    private ProjectRepository projectRepository;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private SimpMessagingTemplate messagingTemplate;

    @Transactional
    public ProjectResponse createProject(ProjectRequest projectRequest, User owner) {
        Project project = new Project();
        project.setName(projectRequest.getName());
        project.setDescription(projectRequest.getDescription());
        project.setOwner(owner);
        project.addMember(owner);
        
        ChatRoom projectChatRoom = new ChatRoom(
            projectRequest.getName(), 
            "Chat for project: " + projectRequest.getName(),
            ChatRoom.RoomType.PROJECT,
            project,
            owner
        );
        project.setChatRoom(projectChatRoom);

        Project savedProject = projectRepository.save(project);

        // Force Hibernate to load the lazy collections before the session closes
        Hibernate.initialize(savedProject.getOwner());
        Hibernate.initialize(savedProject.getMembers());

        long totalProjects = projectRepository.count();
        messagingTemplate.convertAndSend("/topic/dashboard/stats", Map.of("totalProjects", totalProjects));

        return new ProjectResponse(savedProject);
    }

    public ProjectResponse getProjectById(Long projectId) {
        Project project = projectRepository.findById(projectId)
                .orElseThrow(() -> new NoSuchElementException("Project not found with ID: " + projectId));
        // Force initialization before returning
        Hibernate.initialize(project.getOwner());
        Hibernate.initialize(project.getMembers());
        return new ProjectResponse(project);
    }

    public List<ProjectResponse> getProjectsByMemberId(Long userId) {
        List<Project> projects = projectRepository.findByMemberId(userId);
        // Eagerly fetch necessary data within the transaction
        projects.forEach(p -> {
            Hibernate.initialize(p.getOwner());
            Hibernate.initialize(p.getMembers());
        });
        return projects.stream().map(ProjectResponse::new).collect(Collectors.toList());
    }

    @Transactional
    public ProjectResponse updateProject(Long projectId, ProjectRequest projectRequest) {
        Project project = projectRepository.findById(projectId)
            .orElseThrow(() -> new NoSuchElementException("Project not found"));
        project.setName(projectRequest.getName());
        project.setDescription(projectRequest.getDescription());
        Project savedProject = projectRepository.save(project);
        Hibernate.initialize(savedProject.getOwner());
        Hibernate.initialize(savedProject.getMembers());
        return new ProjectResponse(savedProject);
    }

    @Transactional
    public void deleteProject(Long projectId) {
        projectRepository.deleteById(projectId);
        long totalProjects = projectRepository.count();
        messagingTemplate.convertAndSend("/topic/dashboard/stats", Map.of("totalProjects", totalProjects));
    }

    @Transactional
    public ProjectResponse addMemberToProject(Long projectId, Long userId) {
        Project project = projectRepository.findById(projectId)
            .orElseThrow(() -> new NoSuchElementException("Project not found"));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new NoSuchElementException("User not found"));
        project.addMember(user);
        Project savedProject = projectRepository.save(project);
        Hibernate.initialize(savedProject.getOwner());
        Hibernate.initialize(savedProject.getMembers());
        return new ProjectResponse(savedProject);
    }

    @Transactional
    public ProjectResponse removeMemberFromProject(Long projectId, Long userId) {
        Project project = projectRepository.findById(projectId)
            .orElseThrow(() -> new NoSuchElementException("Project not found"));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new NoSuchElementException("User not found"));
        project.removeMember(user);
        Project savedProject = projectRepository.save(project);
        Hibernate.initialize(savedProject.getOwner());
        Hibernate.initialize(savedProject.getMembers());
        return new ProjectResponse(savedProject);
    }
}
</file>

<file path="frontend/src/pages/Projects/ProjectDetailPage.jsx">
import React, { useEffect, useState, useCallback, useRef } from "react";
import { useParams } from "react-router-dom";
import useWebSocket from "../../hooks/useWebSocket";
import { FiSend } from "react-icons/fi";

const ProjectDetailPage = () => {
  const { id } = useParams();
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState("");
  const messagesEndRef = useRef(null);

  // --- Handle incoming WebSocket messages
  const handleMessage = useCallback((msg) => {
    try {
      const body = JSON.parse(msg.body);
      setMessages((prev) => [
        ...prev,
        { sender: body.sender || "Server", content: body.content, self: false, time: new Date() },
      ]);
    } catch (err) {
      console.error("[WebSocket] Invalid message", err);
    }
  }, []);

  // --- Use WebSocket hook
  const { connected, sendMessage } = useWebSocket("ws://localhost:8080/ws", handleMessage);

  // --- Send message + render locally
  const handleSend = () => {
    if (!input.trim()) return;
    const newMessage = {
      sender: "You",
      content: input,
      self: true,
      time: new Date(),
    };

    // render locally
    setMessages((prev) => [...prev, newMessage]);

    // send to backend
    sendMessage("/app/chat.sendMessage", {
      projectId: id,
      content: input,
    });

    setInput("");
  };

  // --- Auto-scroll on new messages
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  return (
    <div className="min-h-screen flex flex-col bg-gradient-to-br from-gray-50 to-gray-100 p-6">
      <div className="max-w-3xl mx-auto w-full flex flex-col flex-1 shadow-lg rounded-2xl bg-white overflow-hidden border border-gray-200">
        {/* Header */}
        <div className="px-6 py-4 border-b border-gray-200 flex justify-between items-center bg-gray-50">
          <h2 className="text-lg font-semibold text-gray-800">
            Project Chat — <span className="text-indigo-600">#{id}</span>
          </h2>
          <div
            className={`flex items-center gap-2 text-sm ${
              connected ? "text-green-600" : "text-red-500"
            }`}
          >
            <span
              className={`w-2 h-2 rounded-full ${
                connected ? "bg-green-500" : "bg-red-400"
              }`}
            ></span>
            {connected ? "Connected" : "Disconnected"}
          </div>
        </div>

        {/* Messages */}
        <div className="flex-1 overflow-y-auto p-6 space-y-4 bg-gray-50">
          {messages.length === 0 ? (
            <p className="text-gray-400 text-center mt-10">
              No messages yet. Start the conversation 👇
            </p>
          ) : (
            messages.map((m, i) => (
              <div
                key={i}
                className={`flex ${m.self ? "justify-end" : "justify-start"}`}
              >
                <div
                  className={`px-4 py-2 rounded-xl max-w-xs text-sm shadow-sm ${
                    m.self
                      ? "bg-indigo-600 text-white"
                      : "bg-white text-gray-800 border border-gray-200"
                  }`}
                >
                  <div className="text-xs opacity-75 mb-1">
                    {m.sender} • {m.time.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })}
                  </div>
                  {m.content}
                </div>
              </div>
            ))
          )}
          <div ref={messagesEndRef} />
        </div>

        {/* Input */}
        <div className="border-t border-gray-200 bg-white p-4 flex items-center gap-3">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Type a message..."
            className="flex-1 bg-gray-100 border border-gray-200 rounded-xl px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:border-indigo-400"
          />
          <button
            onClick={handleSend}
            disabled={!connected}
            className={`flex items-center justify-center rounded-xl px-4 py-2 text-sm font-medium transition-all ${
              connected
                ? "bg-indigo-600 hover:bg-indigo-700 text-white"
                : "bg-gray-300 text-gray-600 cursor-not-allowed"
            }`}
          >
            <FiSend className="text-lg" />
          </button>
        </div>
      </div>
    </div>
  );
};

export default ProjectDetailPage;
</file>

<file path="frontend/src/App.tsx">
import React, { useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { Provider } from 'react-redux';
import { Toaster } from 'react-hot-toast';
import { ThemeProvider, Box } from '@mui/material';
import CssBaseline from '@mui/material/CssBaseline';
import { store, useAppDispatch, useAppSelector } from './store/store';
import { useTheme } from './hooks/useTheme';

import { getCurrentUser, selectInitialLoad, selectIsAuthenticated } from './store/slices/authSlice';

// Pages
import Landing from './pages/Landing/Landing';
import Login from './pages/Auth/Login';
import Register from './pages/Auth/Register';
import Dashboard from './pages/Dashboard/Dashboard';
import Profile from './pages/Profile/Profile';
import Settings from './pages/Settings/Settings';
import VerifyEmail from './pages/Auth/VerifyEmail';
import ProjectsPage from './pages/Projects/ProjectsPage';
import ProjectDetailPage from './pages/Projects/ProjectDetailPage';
import TeamsPage from './pages/Teams/TeamsPage';
import TeamDetailPage from './pages/Teams/TeamDetailPage';

// Components
import ProtectedRoute from './components/Auth/ProtectedRoute';
import LoadingSpinner from './components/Common/LoadingSpinner';

const InitialLoadingScreen = () => (
    <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100vh' }}>
        <LoadingSpinner message="Initializing Application..." />
    </Box>
);

const AppContent = () => {
    const dispatch = useAppDispatch();
    const initialLoad = useAppSelector(selectInitialLoad);
    const isAuthenticated = useAppSelector(selectIsAuthenticated);
    const [theme] = useTheme();

    useEffect(() => {
        // Run this check only once when the app boots up
        if (store.getState().auth.initialLoad === 'idle') {
            dispatch(getCurrentUser());
        }
    }, [dispatch]);
    
    // --- THIS IS THE CRITICAL LOGIC ---
    // Show the loading screen ONLY if the initial check has not completed yet.
    if (initialLoad === 'idle' || initialLoad === 'loading') {
        return <InitialLoadingScreen />;
    }
    
    // If the check is 'succeeded' or 'failed', we know the user's auth status and can render.
    return (
        <ThemeProvider theme={theme}>
            <CssBaseline />
            <Toaster position="bottom-right" reverseOrder={false} />
            <Router>
                <Routes>
                    <Route path="/" element={<Landing />} />
                    <Route path="/login" element={<Login />} />
                    <Route path="/register" element={<Register />} />
                    <Route path="/verify-email" element={<VerifyEmail />} />
                    
                    <Route path="/dashboard" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />
                    <Route path="/profile" element={<ProtectedRoute><Profile /></ProtectedRoute>} />
                    <Route path="/settings" element={<ProtectedRoute><Settings /></ProtectedRoute>} />
                    
                    <Route path="/projects" element={<ProtectedRoute><ProjectsPage /></ProtectedRoute>} />
                    <Route path="/projects/:projectId" element={<ProtectedRoute><ProjectDetailPage /></ProtectedRoute>} />

                    <Route path="/teams" element={<ProtectedRoute><TeamsPage /></ProtectedRoute>} />
                    <Route path="/teams/:teamId" element={<ProtectedRoute><TeamDetailPage /></ProtectedRoute>} />
                    
                    <Route path="*" element={<Navigate to={isAuthenticated ? "/dashboard" : "/"} />} />
                </Routes>
            </Router>
        </ThemeProvider>
    );
};

const App = () => (
    <Provider store={store}>
        <AppContent />
    </Provider>
);

export default App;
</file>

</files>
