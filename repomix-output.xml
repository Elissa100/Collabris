This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/pom.xml
backend/README.md
backend/src/main/java/com/collabris/CollabrisApplication.java
backend/src/main/java/com/collabris/config/AdminUserInitializer.java
backend/src/main/java/com/collabris/config/DataInitializer.java
backend/src/main/java/com/collabris/config/SwaggerConfig.java
backend/src/main/java/com/collabris/config/WebSecurityConfig.java
backend/src/main/java/com/collabris/config/WebSocketConfig.java
backend/src/main/java/com/collabris/controller/AuthController.java
backend/src/main/java/com/collabris/controller/ChatController.java
backend/src/main/java/com/collabris/controller/ProjectController.java
backend/src/main/java/com/collabris/controller/TeamController.java
backend/src/main/java/com/collabris/controller/UserController.java
backend/src/main/java/com/collabris/dto/ProjectRequestDto.java
backend/src/main/java/com/collabris/dto/ProjectResponseDto.java
backend/src/main/java/com/collabris/dto/request/ChatMessageRequest.java
backend/src/main/java/com/collabris/dto/request/ChatRoomRequest.java
backend/src/main/java/com/collabris/dto/request/ForgotPasswordRequest.java
backend/src/main/java/com/collabris/dto/request/LoginRequest.java
backend/src/main/java/com/collabris/dto/request/ProjectRequest.java
backend/src/main/java/com/collabris/dto/request/ResetPasswordRequest.java
backend/src/main/java/com/collabris/dto/request/SignupRequest.java
backend/src/main/java/com/collabris/dto/request/TeamRequest.java
backend/src/main/java/com/collabris/dto/request/VerifyEmailRequest.java
backend/src/main/java/com/collabris/dto/request/VerifyResetCodeRequest.java
backend/src/main/java/com/collabris/dto/response/JwtResponse.java
backend/src/main/java/com/collabris/dto/response/MessageResponse.java
backend/src/main/java/com/collabris/dto/response/ProjectResponse.java
backend/src/main/java/com/collabris/dto/response/TeamResponse.java
backend/src/main/java/com/collabris/dto/response/UserResponse.java
backend/src/main/java/com/collabris/dto/TeamRequestDto.java
backend/src/main/java/com/collabris/dto/TeamResponseDto.java
backend/src/main/java/com/collabris/dto/UserDto.java
backend/src/main/java/com/collabris/entity/ChatMessage.java
backend/src/main/java/com/collabris/entity/ChatRoom.java
backend/src/main/java/com/collabris/entity/Project.java
backend/src/main/java/com/collabris/entity/Role.java
backend/src/main/java/com/collabris/entity/Team.java
backend/src/main/java/com/collabris/entity/User.java
backend/src/main/java/com/collabris/entity/VerificationToken.java
backend/src/main/java/com/collabris/exception/GlobalExceptionHandler.java
backend/src/main/java/com/collabris/repository/ChatMessageRepository.java
backend/src/main/java/com/collabris/repository/ChatRoomRepository.java
backend/src/main/java/com/collabris/repository/ProjectRepository.java
backend/src/main/java/com/collabris/repository/RoleRepository.java
backend/src/main/java/com/collabris/repository/TeamRepository.java
backend/src/main/java/com/collabris/repository/UserRepository.java
backend/src/main/java/com/collabris/repository/VerificationTokenRepository.java
backend/src/main/java/com/collabris/security/jwt/AuthEntryPointJwt.java
backend/src/main/java/com/collabris/security/jwt/AuthTokenFilter.java
backend/src/main/java/com/collabris/security/jwt/JwtUtils.java
backend/src/main/java/com/collabris/security/services/UserDetailsServiceImpl.java
backend/src/main/java/com/collabris/security/services/UserPrinciple.java
backend/src/main/java/com/collabris/service/ChatService.java
backend/src/main/java/com/collabris/service/EmailService.java
backend/src/main/java/com/collabris/service/ProjectService.java
backend/src/main/java/com/collabris/service/TeamService.java
backend/src/main/java/com/collabris/service/TokenService.java
backend/src/main/java/com/collabris/service/UserService.java
backend/src/main/resources/application.properties
backend/src/main/resources/templates/email-verification.html
backend/src/main/resources/templates/password-reset.html
backend/src/test/java/com/collabris/CollabrisApplicationTests.java
backend/src/test/java/com/collabris/controller/AuthControllerTest.java
backend/src/test/resources/application-test.properties
frontend/eslint.config.js
frontend/index.html
frontend/package.json
frontend/postcss.config.js
frontend/src/App.tsx
frontend/src/components/Auth/ProtectedRoute.tsx
frontend/src/components/Common/LoadingSpinner.tsx
frontend/src/components/Common/StatsCard.jsx
frontend/src/components/Layout/Layout.tsx
frontend/src/components/Layout/Navbar.jsx
frontend/src/components/Layout/NavigationItem.tsx
frontend/src/config/environment.ts
frontend/src/hooks/useTheme.ts
frontend/src/index.css
frontend/src/main.tsx
frontend/src/pages/Auth/ForgotPassword.tsx
frontend/src/pages/Auth/Login.tsx
frontend/src/pages/Auth/Register.tsx
frontend/src/pages/Auth/ResetPassword.tsx
frontend/src/pages/Auth/VerifyEmail.tsx
frontend/src/pages/Dashboard.tsx
frontend/src/pages/Dashboard/AdminDashboard.jsx
frontend/src/pages/Dashboard/Dashboard.jsx
frontend/src/pages/Dashboard/ManagerDashboard.jsx
frontend/src/pages/Dashboard/MemberDashboard.jsx
frontend/src/pages/Landing/Landing.tsx
frontend/src/pages/Profile/Profile.jsx
frontend/src/pages/Settings/Settings.jsx
frontend/src/services/apiClient.ts
frontend/src/services/authService.ts
frontend/src/services/chatService.ts
frontend/src/services/dashboardService.ts
frontend/src/services/projectService.ts
frontend/src/services/teamService.ts
frontend/src/services/userService.ts
frontend/src/store/slices/authSlice.ts
frontend/src/store/slices/themeSlice.ts
frontend/src/store/slices/uiSlice.ts
frontend/src/store/slices/userSlice.ts
frontend/src/store/store.ts
frontend/src/theme/customStyles.css
frontend/src/theme/theme.ts
frontend/src/types/index.ts
frontend/src/vite-env.d.ts
frontend/tailwind.config.js
frontend/vite.config.ts
index.html
package.json
postcss.config.js
README.md
src/App.tsx
src/index.css
src/main.tsx
src/vite-env.d.ts
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
WARP.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/main/java/com/collabris/dto/ProjectRequestDto.java">
package com.collabris.dto;

public record ProjectRequestDto(
    String name,
    String description
) {}
</file>

<file path="backend/src/main/java/com/collabris/dto/ProjectResponseDto.java">
package com.collabris.dto;

import java.time.LocalDateTime;

public record ProjectResponseDto(
    Long id,
    String name,
    String description,
    LocalDateTime createdAt
) {}
</file>

<file path="backend/src/main/java/com/collabris/dto/TeamRequestDto.java">
package com.collabris.dto;

public record TeamRequestDto(
    String name,
    String description
) {}
</file>

<file path="backend/src/main/java/com/collabris/dto/TeamResponseDto.java">
package com.collabris.dto;

import java.time.LocalDateTime;

public record TeamResponseDto(
    Long id,
    String name,
    String description,
    LocalDateTime createdAt
) {}
</file>

<file path="backend/src/main/java/com/collabris/dto/UserDto.java">
package com.collabris.dto;

import java.time.LocalDateTime;
import java.util.Set;

public record UserDto(
    Long id,
    String username,
    String email,
    String firstName,
    String lastName,
    LocalDateTime createdAt,
    LocalDateTime updatedAt,
    Set<String> roles
) {}
</file>

<file path="frontend/src/hooks/useTheme.ts">
// File path: frontend/src/hooks/useTheme.ts

import { useMemo } from 'react';
import { useAppSelector } from '../store/store';
import { selectEffectiveTheme } from '../store/slices/themeSlice';
import { createCollabrisTheme } from '../theme/theme';

export const useTheme = () => {
  const themeMode = useAppSelector(selectEffectiveTheme);

  // This hook now correctly uses your `createCollabrisTheme` function
  // to generate the appropriate theme based on the Redux state.
  const theme = useMemo(
    () => createCollabrisTheme(themeMode),
    [themeMode]
  );

  return [theme, themeMode];
};
</file>

<file path="frontend/src/pages/Dashboard/Dashboard.jsx">
import React from 'react';
import { useSelector }from 'react-redux';
import { selectUser } from '../../store/slices/authSlice';

import AdminDashboard from './AdminDashboard';
import ManagerDashboard from './ManagerDashboard';
import MemberDashboard from './MemberDashboard';
import LoadingSpinner from '../../components/Common/LoadingSpinner';

const Dashboard = () => {
    const user = useSelector(selectUser);

    if (!user || !user.roles) {
        return <LoadingSpinner message="Loading user data..." />;
    }

    // Check for roles in descending order of privilege
    const roles = user.roles.map(role => role.name);

    if (roles.includes('ADMIN')) {
        return <AdminDashboard />;
    }
    
    if (roles.includes('MANAGER')) {
        return <ManagerDashboard />;
    }
    
    if (roles.includes('MEMBER')) {
        return <MemberDashboard />;
    }
    
    // Fallback for users with no recognized roles, though this should not happen
    return (
        <div>
            <h1>Welcome</h1>
            <p>You do not have a role assigned. Please contact an administrator.</p>
        </div>
    );
};

export default Dashboard;
</file>

<file path="frontend/src/pages/Dashboard/ManagerDashboard.jsx">
import React from 'react';
import { useSelector } from 'react-redux';
import {
  Grid,
  Card,
  CardContent,
  Typography,
  Box,
  Button
} from '@mui/material';
import {
  Assignment,
  Group,
  TrendingUp,
  Add as AddIcon
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import { BarChart, Bar, XAxis, YAxis, Tooltip, Legend, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';

import Layout from '../../components/Layout/Layout';
import StatsCard from '../../components/Common/StatsCard';
import { selectUser } from '../../store/slices/authSlice';

// Mock Data for Charts
const projectsStatusData = [
  { name: 'On Track', value: 12 },
  { name: 'At Risk', value: 3 },
  { name: 'Overdue', value: 2 },
];
const COLORS = ['#00C49F', '#FFBB28', '#FF8042'];

const teamPerformanceData = [
    { name: 'Frontend', tasks_completed: 45 },
    { name: 'Backend', tasks_completed: 62 },
    { name: 'Design', tasks_completed: 30 },
    { name: 'QA', tasks_completed: 55 },
];


const ManagerDashboard = () => {
    const user = useSelector(selectUser);

    return (
        <Layout>
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }}>
                <Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
                    <Box>
                        <Typography variant="h4" fontWeight="bold" gutterBottom>
                            Manager's Overview
                        </Typography>
                        <Typography variant="body1" color="text.secondary">
                            Monitor team performance and project health across the organization.
                        </Typography>
                    </Box>
                    <Button variant="contained" startIcon={<AddIcon />}>Invite User</Button>
                </Box>
                

                <Grid container spacing={3}>
                    {/* Stats Cards */}
                    <Grid item xs={12} sm={4}><StatsCard title="Total Projects" value="17" icon={<Assignment />} color="primary" /></Grid>
                    <Grid item xs={12} sm={4}><StatsCard title="Active Teams" value="4" icon={<Group />} color="secondary" /></Grid>
                    <Grid item xs={12} sm={4}><StatsCard title="Tasks Completed This Week" value="78" icon={<TrendingUp />} color="success" /></Grid>

                    {/* Charts */}
                    <Grid item xs={12} md={7}>
                        <Card sx={{ height: '100%' }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>Team Performance (Tasks Completed)</Typography>
                                <ResponsiveContainer width="100%" height={300}>
                                    <BarChart data={teamPerformanceData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
                                        <XAxis dataKey="name" />
                                        <YAxis />
                                        <Tooltip />
                                        <Legend />
                                        <Bar dataKey="tasks_completed" fill="#8884d8" />
                                    </BarChart>
                                </ResponsiveContainer>
                            </CardContent>
                        </Card>
                    </Grid>
                    <Grid item xs={12} md={5}>
                         <Card sx={{ height: '100%' }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>Overall Project Health</Typography>
                                <ResponsiveContainer width="100%" height={300}>
                                    <PieChart>
                                        <Pie data={projectsStatusData} cx="50%" cy="50%" labelLine={false} outerRadius={100} fill="#8884d8" dataKey="value" label={({ name, value }) => `${name}: ${value}`}>
                                            {projectsStatusData.map((entry, index) => (<Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />))}
                                        </Pie>
                                        <Tooltip />
                                    </PieChart>
                                </ResponsiveContainer>
                            </CardContent>
                        </Card>
                    </Grid>
                </Grid>
            </motion.div>
        </Layout>
    );
};

export default ManagerDashboard;
</file>

<file path="frontend/src/pages/Dashboard/MemberDashboard.jsx">
import React from 'react';
import { useSelector } from 'react-redux';
import {
  Grid,
  Card,
  CardContent,
  Typography,
  Box,
  Avatar,
  Chip,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Divider,
} from '@mui/material';
import {
  Assignment,
  Group,
  TrendingUp,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';

import Layout from '../../components/Layout/Layout';
import StatsCard from '../../components/Common/StatsCard';
import { selectUser } from '../../store/slices/authSlice';

// Mock Data for Charts - This will later come from the backend/Redux store
const myTasksData = [
  { name: 'To Do', value: 8 },
  { name: 'In Progress', value: 4 },
  { name: 'Done', value: 12 },
];
const COLORS = ['#FFBB28', '#00C49F', '#0088FE'];

const myProjectsData = [
    { name: 'Website Redesign', progress: 75 },
    { name: 'Mobile App', progress: 40 },
    { name: 'API Integration', progress: 90 },
];

const MemberDashboard = () => {
    const user = useSelector(selectUser);

    return (
        <Layout>
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }}>
                <Typography variant="h4" fontWeight="bold" gutterBottom>
                    Welcome back, {user?.firstName}!
                </Typography>
                <Typography variant="body1" color="text.secondary" sx={{ mb: 4 }}>
                    Here's your personal summary of what's happening today.
                </Typography>

                <Grid container spacing={3}>
                    {/* Stats Cards */}
                    <Grid item xs={12} sm={4}><StatsCard title="My Active Projects" value="3" icon={<Assignment />} color="primary" /></Grid>
                    <Grid item xs={12} sm={4}><StatsCard title="My Teams" value="2" icon={<Group />} color="secondary" /></Grid>
                    <Grid item xs={12} sm={4}><StatsCard title="My Tasks Due" value="8" icon={<TrendingUp />} color="success" /></Grid>

                    {/* Charts */}
                    <Grid item xs={12} md={7}>
                        <Card sx={{ height: '100%' }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>My Project Progress</Typography>
                                <ResponsiveContainer width="100%" height={300}>
                                    <BarChart data={myProjectsData} layout="vertical" margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
                                        <XAxis type="number" />
                                        <YAxis dataKey="name" type="category" width={120} />
                                        <Tooltip />
                                        <Bar dataKey="progress" fill="#8884d8" barSize={20} />
                                    </BarChart>
                                </ResponsiveContainer>
                            </CardContent>
                        </Card>
                    </Grid>
                    <Grid item xs={12} md={5}>
                         <Card sx={{ height: '100%' }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>My Task Status</Typography>
                                <ResponsiveContainer width="100%" height={300}>
                                    <PieChart>
                                        <Pie data={myTasksData} cx="50%" cy="50%" labelLine={false} outerRadius={100} fill="#8884d8" dataKey="value" label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}>
                                            {myTasksData.map((entry, index) => (<Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />))}
                                        </Pie>
                                        <Tooltip />
                                    </PieChart>
                                </ResponsiveContainer>
                            </CardContent>
                        </Card>
                    </Grid>
                </Grid>
            </motion.div>
        </Layout>
    );
};

export default MemberDashboard;
</file>

<file path=".gitignore">
# Java / Maven
target/
*.class
*.jar

# IDE
.vscode/
.idea/
*.iml

# Node / frontend
node_modules/
dist/
build/

# Logs, OS
*.log
.DS_Store

# Secrets, environment
.env
*.key
*.pem
uploads/    # don't commit uploaded files
/.mvn/wrapper/maven-wrapper.jar

# other
/.gradle/
</file>

<file path="backend/pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.collabris</groupId>
    <artifactId>collabris-backend</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>collabris-backend</name>
    <description>Collabris Collaboration App Backend</description>
    <properties>
        <java.version>17</java.version>
    </properties>
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- MODIFICATION: Explicitly add the Tomcat starter to resolve version conflicts -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-websocket</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.3</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.3</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.3</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Swagger/OpenAPI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.2.0</version>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
</file>

<file path="backend/README.md">
# Collabris Backend

A comprehensive Spring Boot backend for the Collabris collaboration application.

## Features

- **Authentication & Authorization**: JWT-based authentication with role-based access control
- **User Management**: Complete user registration, login, and profile management
- **Team Management**: Create and manage teams with member assignments
- **Project Management**: Project creation, assignment, and tracking
- **Real-time Chat**: WebSocket-based messaging system with STOMP protocol
- **API Documentation**: Swagger/OpenAPI 3.0 documentation
- **Database**: PostgreSQL with JPA/Hibernate
- **Security**: Spring Security with JWT tokens
- **Testing**: Unit and integration tests

## Technology Stack

- **Framework**: Spring Boot 3.2.0
- **Security**: Spring Security with JWT
- **Database**: PostgreSQL with JPA/Hibernate
- **WebSocket**: STOMP over WebSocket for real-time messaging
- **Documentation**: Swagger/OpenAPI 3.0
- **Testing**: JUnit 5, Spring Boot Test
- **Build Tool**: Maven

## Prerequisites

- Java 17 or higher
- PostgreSQL 12 or higher
- Maven 3.6 or higher

## Database Setup

1. Create PostgreSQL database:
```sql
CREATE DATABASE collabris_db;
CREATE USER collabris_user WITH PASSWORD 'collabris_pass';
GRANT ALL PRIVILEGES ON DATABASE collabris_db TO collabris_user;
```

2. The application will automatically create tables on startup using Hibernate DDL.

## Configuration

The application is configured via `application.properties`. Key configurations:

- **Database**: PostgreSQL connection settings
- **JWT**: Secret key and expiration time
- **CORS**: Allowed origins for frontend
- **File Upload**: Maximum file sizes
- **Email**: SMTP configuration for notifications

## Running the Application

1. Clone the repository
2. Navigate to the backend directory
3. Run the application:

```bash
mvn spring-boot:run
```

The application will start on `http://localhost:8080`

## API Documentation

Once the application is running, access the Swagger UI at:
- **Swagger UI**: http://localhost:8080/swagger-ui.html
- **API Docs**: http://localhost:8080/v3/api-docs

## API Endpoints

### Authentication
- `POST /api/auth/signup` - Register new user
- `POST /api/auth/signin` - User login

### User Management
- `GET /api/users` - Get all users (Admin only)
- `GET /api/users/{id}` - Get user by ID
- `PUT /api/users/{id}` - Update user
- `DELETE /api/users/{id}` - Delete user (Admin only)

### Team Management
- `GET /api/teams` - Get all teams
- `POST /api/teams` - Create team
- `PUT /api/teams/{id}` - Update team
- `DELETE /api/teams/{id}` - Delete team
- `POST /api/teams/{teamId}/members/{userId}` - Add member to team

### Project Management
- `GET /api/projects` - Get all projects
- `POST /api/projects` - Create project
- `PUT /api/projects/{id}` - Update project
- `DELETE /api/projects/{id}` - Delete project
- `POST /api/projects/{projectId}/members/{userId}` - Add member to project

### Chat System
- `GET /api/chat/rooms` - Get all chat rooms
- `POST /api/chat/rooms` - Create chat room
- `GET /api/chat/rooms/{roomId}/messages` - Get messages
- `POST /api/chat/messages` - Send message

### WebSocket Endpoints
- `/ws` - WebSocket connection endpoint
- `/app/chat.sendMessage` - Send message via WebSocket
- `/topic/chat/{roomId}` - Subscribe to room messages

## Security

The application uses JWT tokens for authentication. Include the token in the Authorization header:

```
Authorization: Bearer <your-jwt-token>
```

### Roles
- **ADMIN**: Full system access
- **MANAGER**: Team and project management
- **MEMBER**: Basic user access

## Testing

Run tests with:

```bash
mvn test
```

The test suite includes:
- Unit tests for services and controllers
- Integration tests for API endpoints
- Security tests for authentication and authorization

## Database Schema

The application creates the following main entities:
- **Users**: User accounts with authentication
- **Roles**: User roles for access control
- **Teams**: User groups for collaboration
- **Projects**: Work projects with team assignments
- **ChatRooms**: Communication channels
- **ChatMessages**: Individual messages

## WebSocket Configuration

Real-time messaging is implemented using STOMP over WebSocket:
- **Connection**: `/ws` endpoint with SockJS fallback
- **Message Broker**: Simple broker for `/topic` and `/queue`
- **Application Prefix**: `/app` for client messages

## Error Handling

Global exception handling provides consistent error responses:
- Validation errors with field-specific messages
- Authentication and authorization errors
- Custom business logic exceptions
- Generic error handling for unexpected issues

## Development

### Adding New Features

1. Create entity classes in `com.collabris.entity`
2. Add repository interfaces in `com.collabris.repository`
3. Implement service classes in `com.collabris.service`
4. Create controller classes in `com.collabris.controller`
5. Add DTOs in `com.collabris.dto`
6. Write tests in `src/test/java`

### Code Structure

```
src/main/java/com/collabris/
├── config/          # Configuration classes
├── controller/      # REST controllers
├── dto/            # Data Transfer Objects
├── entity/         # JPA entities
├── exception/      # Exception handling
├── repository/     # Data repositories
├── security/       # Security configuration
└── service/        # Business logic services
```

## Production Deployment

For production deployment:

1. Update `application.properties` with production database settings
2. Change JWT secret to a secure random value
3. Configure proper CORS origins
4. Set up SSL/TLS certificates
5. Configure logging levels
6. Set up monitoring and health checks

## Contributing

1. Follow Spring Boot best practices
2. Write comprehensive tests
3. Document API changes in Swagger annotations
4. Follow the existing code structure and naming conventions
5. Ensure security considerations are addressed

## License

This project is licensed under the Apache License 2.0.
</file>

<file path="backend/src/main/java/com/collabris/CollabrisApplication.java">
package com.collabris;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CollabrisApplication {
    public static void main(String[] args) {
        SpringApplication.run(CollabrisApplication.class, args);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/config/DataInitializer.java">
package com.collabris.config;

import com.collabris.entity.Role;
import com.collabris.repository.RoleRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.beans.factory.annotation.Autowired;

@Component
@Order(1)
public class DataInitializer implements CommandLineRunner {

    @Autowired
    private RoleRepository roleRepository;

    @Override
    public void run(String... args) {
        if (roleRepository.count() == 0) {
            roleRepository.save(new Role(Role.ERole.ADMIN));
            roleRepository.save(new Role(Role.ERole.MANAGER));
            roleRepository.save(new Role(Role.ERole.MEMBER));
        }
    }
}
</file>

<file path="backend/src/main/java/com/collabris/config/SwaggerConfig.java">
package com.collabris.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .components(new Components()
                        .addSecuritySchemes("bearerAuth",
                                new SecurityScheme()
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")))
                .info(new Info()
                        .title("Collabris API")
                        .version("1.0.0")
                        .description("Collaboration App REST API Documentation")
                        .license(new License()
                                .name("Apache 2.0")
                                .url("http://springdoc.org")));
    }
}
</file>

<file path="backend/src/main/java/com/collabris/config/WebSocketConfig.java">
package com.collabris.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/topic", "/queue");
        config.setApplicationDestinationPrefixes("/app");
        config.setUserDestinationPrefix("/user");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws")
                .setAllowedOriginPatterns("*")
                .withSockJS();
    }
}
</file>

<file path="backend/src/main/java/com/collabris/controller/ChatController.java">
package com.collabris.controller;

import com.collabris.dto.request.ChatMessageRequest;
import com.collabris.dto.request.ChatRoomRequest;
import com.collabris.entity.ChatMessage;
import com.collabris.entity.ChatRoom;
import com.collabris.entity.User;
import com.collabris.repository.UserRepository;
import com.collabris.service.ChatService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.security.Principal;
import java.time.LocalDateTime;
import java.util.List;

@CrossOrigin(origins = "*", maxAge = 3600)
@RestController
@RequestMapping("/api/chat")
@Tag(name = "Chat Management", description = "Chat and messaging APIs")
@SecurityRequirement(name = "bearerAuth")
public class ChatController {
    
    @Autowired
    private ChatService chatService;
    
    @Autowired
    private UserRepository userRepository;

    @GetMapping("/rooms")
    @Operation(summary = "Get all chat rooms", description = "Retrieve all chat rooms")
    public ResponseEntity<List<ChatRoom>> getAllChatRooms() {
        List<ChatRoom> chatRooms = chatService.getAllChatRooms();
        return ResponseEntity.ok(chatRooms);
    }

    @GetMapping("/rooms/{id}")
    @Operation(summary = "Get chat room by ID", description = "Retrieve chat room by ID")
    public ResponseEntity<ChatRoom> getChatRoomById(@PathVariable Long id) {
        ChatRoom chatRoom = chatService.getChatRoomById(id);
        return ResponseEntity.ok(chatRoom);
    }

    @GetMapping("/rooms/project/{projectId}")
    @Operation(summary = "Get chat rooms by project", description = "Get chat rooms by project ID")
    public ResponseEntity<List<ChatRoom>> getChatRoomsByProject(@PathVariable Long projectId) {
        List<ChatRoom> chatRooms = chatService.getChatRoomsByProjectId(projectId);
        return ResponseEntity.ok(chatRooms);
    }

    @PostMapping("/rooms")
    @Operation(summary = "Create chat room", description = "Create a new chat room")
    public ResponseEntity<ChatRoom> createChatRoom(@Valid @RequestBody ChatRoomRequest chatRoomRequest, 
                                                  Authentication authentication) {
        User createdBy = userRepository.findByUsername(authentication.getName())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        ChatRoom chatRoom = chatService.createChatRoom(chatRoomRequest, createdBy);
        return ResponseEntity.ok(chatRoom);
    }

    @PutMapping("/rooms/{id}")
    @Operation(summary = "Update chat room", description = "Update chat room information")
    public ResponseEntity<ChatRoom> updateChatRoom(@PathVariable Long id, 
                                                  @Valid @RequestBody ChatRoomRequest chatRoomRequest) {
        ChatRoom chatRoom = chatService.updateChatRoom(id, chatRoomRequest);
        return ResponseEntity.ok(chatRoom);
    }

    @DeleteMapping("/rooms/{id}")
    @Operation(summary = "Delete chat room", description = "Delete chat room")
    public ResponseEntity<?> deleteChatRoom(@PathVariable Long id) {
        chatService.deleteChatRoom(id);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/rooms/{roomId}/messages")
    @Operation(summary = "Get messages", description = "Get messages from chat room")
    public ResponseEntity<List<ChatMessage>> getMessages(@PathVariable Long roomId) {
        List<ChatMessage> messages = chatService.getMessagesByChatRoomId(roomId);
        return ResponseEntity.ok(messages);
    }

    @GetMapping("/rooms/{roomId}/messages/paged")
    @Operation(summary = "Get messages paged", description = "Get messages from chat room with pagination")
    public ResponseEntity<Page<ChatMessage>> getMessagesPaged(@PathVariable Long roomId, Pageable pageable) {
        ChatRoom chatRoom = chatService.getChatRoomById(roomId);
        Page<ChatMessage> messages = chatService.getMessagesByChatRoom(chatRoom, pageable);
        return ResponseEntity.ok(messages);
    }

    @GetMapping("/rooms/{roomId}/messages/recent")
    @Operation(summary = "Get recent messages", description = "Get recent messages since timestamp")
    public ResponseEntity<List<ChatMessage>> getRecentMessages(@PathVariable Long roomId, 
                                                              @RequestParam String since) {
        LocalDateTime sinceDateTime = LocalDateTime.parse(since);
        List<ChatMessage> messages = chatService.getRecentMessages(roomId, sinceDateTime);
        return ResponseEntity.ok(messages);
    }

    @PostMapping("/messages")
    @Operation(summary = "Send message", description = "Send a message to chat room")
    public ResponseEntity<ChatMessage> sendMessage(@Valid @RequestBody ChatMessageRequest messageRequest, 
                                                  Authentication authentication) {
        User sender = userRepository.findByUsername(authentication.getName())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        ChatMessage message = chatService.sendMessage(messageRequest, sender);
        return ResponseEntity.ok(message);
    }

    @DeleteMapping("/messages/{messageId}")
    @Operation(summary = "Delete message", description = "Delete a message")
    public ResponseEntity<?> deleteMessage(@PathVariable Long messageId) {
        chatService.deleteMessage(messageId);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/rooms/{roomId}/messages/count")
    @Operation(summary = "Get message count", description = "Get total message count for chat room")
    public ResponseEntity<Long> getMessageCount(@PathVariable Long roomId) {
        Long count = chatService.getMessageCount(roomId);
        return ResponseEntity.ok(count);
    }
}

@Controller
class WebSocketChatController {
    
    @Autowired
    private ChatService chatService;
    
    @Autowired
    private UserRepository userRepository;

    @MessageMapping("/chat.sendMessage")
    public void sendMessage(@Payload ChatMessageRequest messageRequest, Principal principal) {
        User sender = userRepository.findByUsername(principal.getName())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        chatService.sendMessage(messageRequest, sender);
    }

    @MessageMapping("/chat.addUser")
    public void addUser(@Payload ChatMessageRequest messageRequest, Principal principal) {
        User sender = userRepository.findByUsername(principal.getName())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        messageRequest.setType(ChatMessage.MessageType.JOIN);
        messageRequest.setContent(sender.getUsername() + " joined the chat");
        chatService.sendMessage(messageRequest, sender);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/controller/ProjectController.java">
package com.collabris.controller;

import com.collabris.dto.request.ProjectRequest;
import com.collabris.dto.response.ProjectResponse;
import com.collabris.entity.User;
import com.collabris.service.ProjectService;
import com.collabris.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/projects")
public class ProjectController {

    @Autowired
    private ProjectService projectService;

    @Autowired
    private UserService userService;

    @PostMapping
    public ResponseEntity<ProjectResponse> createProject(@RequestBody ProjectRequest request,
                                                         @AuthenticationPrincipal UserDetails userDetails) {
        User currentUser = userService.findByUsername(userDetails.getUsername())
                .orElseThrow(() -> new RuntimeException("User not found"));
        ProjectResponse project = projectService.createProject(request, currentUser);
        return ResponseEntity.ok(project);
    }

    @GetMapping
    public ResponseEntity<List<ProjectResponse>> getAllForCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        User currentUser = userService.findByUsername(userDetails.getUsername())
                .orElseThrow(() -> new RuntimeException("User not found"));
        List<ProjectResponse> projects = projectService.getAllProjectsForCurrentUser(currentUser);
        return ResponseEntity.ok(projects);
    }

    @GetMapping("/{projectId}")
    public ResponseEntity<ProjectResponse> getProject(@PathVariable Long projectId) {
        ProjectResponse p = projectService.getProjectById(projectId);
        return ResponseEntity.ok(p);
    }

    @PutMapping("/{projectId}")
    public ResponseEntity<ProjectResponse> updateProject(@PathVariable Long projectId,
                                                         @RequestBody ProjectRequest request,
                                                         @AuthenticationPrincipal UserDetails userDetails) {
        User currentUser = userService.findByUsername(userDetails.getUsername())
                .orElseThrow(() -> new RuntimeException("User not found"));
        ProjectResponse updated = projectService.updateProject(projectId, request, currentUser);
        return ResponseEntity.ok(updated);
    }

    @DeleteMapping("/{projectId}")
    public ResponseEntity<Void> deleteProject(@PathVariable Long projectId) {
        projectService.deleteProject(projectId);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{projectId}/members/{userId}")
    public ResponseEntity<ProjectResponse> addMemberToProject(@PathVariable Long projectId, @PathVariable Long userId) {
        ProjectResponse project = projectService.addMemberToProject(projectId, userId);
        return ResponseEntity.ok(project);
    }

    @DeleteMapping("/{projectId}/members/{userId}")
    public ResponseEntity<ProjectResponse> removeMemberFromProject(@PathVariable Long projectId, @PathVariable Long userId) {
        ProjectResponse project = projectService.removeMemberFromProject(projectId, userId);
        return ResponseEntity.ok(project);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/ChatMessageRequest.java">
package com.collabris.dto.request;

import com.collabris.entity.ChatMessage;
import jakarta.validation.constraints.NotBlank;

public class ChatMessageRequest {
    @NotBlank
    private String content;

    private ChatMessage.MessageType type = ChatMessage.MessageType.CHAT;
    private Long chatRoomId;

    // Getters and Setters
    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }

    public ChatMessage.MessageType getType() { return type; }
    public void setType(ChatMessage.MessageType type) { this.type = type; }

    public Long getChatRoomId() { return chatRoomId; }
    public void setChatRoomId(Long chatRoomId) { this.chatRoomId = chatRoomId; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/ChatRoomRequest.java">
package com.collabris.dto.request;

import com.collabris.entity.ChatRoom;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class ChatRoomRequest {
    @NotBlank
    @Size(max = 100)
    private String name;

    @Size(max = 500)
    private String description;

    private ChatRoom.RoomType type;
    private Long projectId;

    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public ChatRoom.RoomType getType() { return type; }
    public void setType(ChatRoom.RoomType type) { this.type = type; }

    public Long getProjectId() { return projectId; }
    public void setProjectId(Long projectId) { this.projectId = projectId; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/ForgotPasswordRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public class ForgotPasswordRequest {
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email address")
    private String email;

    public ForgotPasswordRequest() {}

    public ForgotPasswordRequest(String email) { this.email = email; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/LoginRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;

public class LoginRequest {
    @NotBlank
    private String username;

    @NotBlank
    private String password;

    // Getters and Setters
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/ProjectRequest.java">
package com.collabris.dto.request;

import com.collabris.entity.Project;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;
import java.util.Set;

public class ProjectRequest {
    @NotBlank
    @Size(max = 100)
    private String name;

    @Size(max = 1000)
    private String description;

    private Project.ProjectStatus status;
    private Long teamId;
    private Set<Long> memberIds;
    private LocalDateTime startDate;
    private LocalDateTime endDate;

    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Project.ProjectStatus getStatus() { return status; }
    public void setStatus(Project.ProjectStatus status) { this.status = status; }

    public Long getTeamId() { return teamId; }
    public void setTeamId(Long teamId) { this.teamId = teamId; }

    public Set<Long> getMemberIds() { return memberIds; }
    public void setMemberIds(Set<Long> memberIds) { this.memberIds = memberIds; }

    public LocalDateTime getStartDate() { return startDate; }
    public void setStartDate(LocalDateTime startDate) { this.startDate = startDate; }

    public LocalDateTime getEndDate() { return endDate; }
    public void setEndDate(LocalDateTime endDate) { this.endDate = endDate; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/ResetPasswordRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class ResetPasswordRequest {

    @NotBlank(message = "Email is required")
    private String email;

    @NotBlank(message = "Verification code is required")
    @Size(min = 6, max = 6, message = "Verification code must be exactly 6 characters")
    private String code;

    @NotBlank(message = "New password is required")
    private String newPassword;

    public ResetPasswordRequest() {}

    public ResetPasswordRequest(String email, String code, String newPassword) {
        this.email = email;
        this.code = code;
        this.newPassword = newPassword;
    }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }

    public String getNewPassword() { return newPassword; }
    public void setNewPassword(String newPassword) { this.newPassword = newPassword; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/TeamRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.Set;

public class TeamRequest {
    @NotBlank
    @Size(max = 100)
    private String name;

    @Size(max = 500)
    private String description;

    private Set<Long> memberIds;

    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public Set<Long> getMemberIds() { return memberIds; }
    public void setMemberIds(Set<Long> memberIds) { this.memberIds = memberIds; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/VerifyEmailRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class VerifyEmailRequest {
    
    @NotBlank(message = "Verification code is required")
    @Size(min = 6, max = 6, message = "Verification code must be exactly 6 characters")
    @Pattern(regexp = "^[A-Z0-9]{6}$", message = "Verification code must contain only uppercase letters and numbers")
    private String code;
    
    public VerifyEmailRequest() {}
    
    public VerifyEmailRequest(String code) {
        this.code = code;
    }
    
    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/VerifyResetCodeRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class VerifyResetCodeRequest {

    @NotBlank(message = "Email is required")
    private String email;

    @NotBlank(message = "Verification code is required")
    @Size(min = 6, max = 6, message = "Verification code must be exactly 6 characters")
    @Pattern(regexp = "^[A-Z0-9]{6}$", message = "Verification code must contain only uppercase letters and numbers")
    private String code;

    public VerifyResetCodeRequest() {}
    public VerifyResetCodeRequest(String email, String code) {
        this.email = email;
        this.code = code;
    }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/response/MessageResponse.java">
package com.collabris.dto.response;

public class MessageResponse {
    private String message;

    public MessageResponse(String message) {
        this.message = message;
    }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/response/UserResponse.java">
package com.collabris.dto.response;

import com.collabris.entity.User;

import java.time.LocalDateTime;
import java.util.Set;
import java.util.stream.Collectors;

public class UserResponse {
    private Long id;
    private String username;
    private String email;
    private String firstName;
    private String lastName;
    private String profilePicture;
    private boolean enabled;
    private Set<String> roles;
    private LocalDateTime createdAt;

    public UserResponse(User user) {
        this.id = user.getId();
        this.username = user.getUsername();
        this.email = user.getEmail();
        this.firstName = user.getFirstName();
        this.lastName = user.getLastName();
        this.profilePicture = user.getProfilePicture();
        this.enabled = user.isEnabled();
        this.roles = user.getRoles().stream()
                .map(role -> role.getName().name())
                .collect(Collectors.toSet());
        this.createdAt = user.getCreatedAt();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }

    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }

    public String getProfilePicture() { return profilePicture; }
    public void setProfilePicture(String profilePicture) { this.profilePicture = profilePicture; }

    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }

    public Set<String> getRoles() { return roles; }
    public void setRoles(Set<String> roles) { this.roles = roles; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/ChatMessage.java">
package com.collabris.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;

import java.time.LocalDateTime;

@Entity
@Table(name = "chat_messages")
public class ChatMessage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Column(columnDefinition = "TEXT")
    private String content;

    @Enumerated(EnumType.STRING)
    private MessageType type = MessageType.CHAT;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "sender_id")
    private User sender;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "chat_room_id")
    private ChatRoom chatRoom;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public ChatMessage() {}

    public ChatMessage(String content, MessageType type, User sender, ChatRoom chatRoom) {
        this.content = content;
        this.type = type;
        this.sender = sender;
        this.chatRoom = chatRoom;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }

    public MessageType getType() { return type; }
    public void setType(MessageType type) { this.type = type; }

    public User getSender() { return sender; }
    public void setSender(User sender) { this.sender = sender; }

    public ChatRoom getChatRoom() { return chatRoom; }
    public void setChatRoom(ChatRoom chatRoom) { this.chatRoom = chatRoom; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }

    public enum MessageType {
        CHAT, JOIN, LEAVE, SYSTEM
    }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/ChatRoom.java">
package com.collabris.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "chat_rooms")
public class ChatRoom {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(max = 100)
    private String name;

    @Size(max = 500)
    private String description;

    @Enumerated(EnumType.STRING)
    private RoomType type = RoomType.GROUP;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "project_id")
    private Project project;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "created_by")
    private User createdBy;

    @OneToMany(mappedBy = "chatRoom", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private Set<ChatMessage> messages = new HashSet<>();

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public ChatRoom() {}

    public ChatRoom(String name, String description, RoomType type, Project project, User createdBy) {
        this.name = name;
        this.description = description;
        this.type = type;
        this.project = project;
        this.createdBy = createdBy;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public RoomType getType() { return type; }
    public void setType(RoomType type) { this.type = type; }

    public Project getProject() { return project; }
    public void setProject(Project project) { this.project = project; }

    public User getCreatedBy() { return createdBy; }
    public void setCreatedBy(User createdBy) { this.createdBy = createdBy; }

    public Set<ChatMessage> getMessages() { return messages; }
    public void setMessages(Set<ChatMessage> messages) { this.messages = messages; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }

    public enum RoomType {
        DIRECT, GROUP, PROJECT
    }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/Project.java">
package com.collabris.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "projects")
public class Project {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(max = 100)
    private String name;

    @Size(max = 1000)
    private String description;

    @Enumerated(EnumType.STRING)
    private ProjectStatus status = ProjectStatus.ACTIVE;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "owner_id")
    private User owner;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id")
    private Team team;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(name = "project_members",
               joinColumns = @JoinColumn(name = "project_id"),
               inverseJoinColumns = @JoinColumn(name = "user_id"))
    private Set<User> members = new HashSet<>();

    @OneToMany(mappedBy = "project", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private Set<ChatRoom> chatRooms = new HashSet<>();

    @Column(name = "start_date")
    private LocalDateTime startDate;

    @Column(name = "end_date")
    private LocalDateTime endDate;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public Project() {}

    public Project(String name, String description, User owner) {
        this.name = name;
        this.description = description;
        this.owner = owner;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public ProjectStatus getStatus() { return status; }
    public void setStatus(ProjectStatus status) { this.status = status; }

    public User getOwner() { return owner; }
    public void setOwner(User owner) { this.owner = owner; }

    public Team getTeam() { return team; }
    public void setTeam(Team team) { this.team = team; }

    public Set<User> getMembers() { return members; }
    public void setMembers(Set<User> members) { this.members = members; }

    public Set<ChatRoom> getChatRooms() { return chatRooms; }
    public void setChatRooms(Set<ChatRoom> chatRooms) { this.chatRooms = chatRooms; }

    public LocalDateTime getStartDate() { return startDate; }
    public void setStartDate(LocalDateTime startDate) { this.startDate = startDate; }

    public LocalDateTime getEndDate() { return endDate; }
    public void setEndDate(LocalDateTime endDate) { this.endDate = endDate; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }

    public enum ProjectStatus {
        ACTIVE, COMPLETED, ON_HOLD, CANCELLED
    }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/Role.java">
package com.collabris.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(length = 50, unique = true, nullable = false)
    private ERole name;

    public Role() {}

    public Role(ERole name) {
        this.name = name;
    }

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public ERole getName() { return name; }
    public void setName(ERole name) { this.name = name; }

    public enum ERole {
        ADMIN,
        MANAGER,
        MEMBER
    }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/Team.java">
package com.collabris.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "teams")
public class Team {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(max = 100)
    private String name;

    @Size(max = 500)
    private String description;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "owner_id")
    private User owner;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(name = "team_members",
               joinColumns = @JoinColumn(name = "team_id"),
               inverseJoinColumns = @JoinColumn(name = "user_id"))
    private Set<User> members = new HashSet<>();

    @OneToMany(mappedBy = "team", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private Set<Project> projects = new HashSet<>();

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public Team() {}

    public Team(String name, String description, User owner) {
        this.name = name;
        this.description = description;
        this.owner = owner;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public User getOwner() { return owner; }
    public void setOwner(User owner) { this.owner = owner; }

    public Set<User> getMembers() { return members; }
    public void setMembers(Set<User> members) { this.members = members; }

    public Set<Project> getProjects() { return projects; }
    public void setProjects(Set<Project> projects) { this.projects = projects; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
}
</file>

<file path="backend/src/main/java/com/collabris/repository/ChatMessageRepository.java">
package com.collabris.repository;

import com.collabris.entity.ChatMessage;
import com.collabris.entity.ChatRoom;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface ChatMessageRepository extends JpaRepository<ChatMessage, Long> {
    Page<ChatMessage> findByChatRoomOrderByCreatedAtDesc(ChatRoom chatRoom, Pageable pageable);
    
    List<ChatMessage> findByChatRoomIdOrderByCreatedAtAsc(Long chatRoomId);
    
    @Query("SELECT m FROM ChatMessage m WHERE m.chatRoom.id = :chatRoomId AND m.createdAt >= :since ORDER BY m.createdAt ASC")
    List<ChatMessage> findRecentMessages(@Param("chatRoomId") Long chatRoomId, @Param("since") LocalDateTime since);
    
    Long countByChatRoomId(Long chatRoomId);
}
</file>

<file path="backend/src/main/java/com/collabris/repository/ChatRoomRepository.java">
package com.collabris.repository;

import com.collabris.entity.ChatRoom;
import com.collabris.entity.Project;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ChatRoomRepository extends JpaRepository<ChatRoom, Long> {
    List<ChatRoom> findByProject(Project project);
    List<ChatRoom> findByProjectId(Long projectId);
    List<ChatRoom> findByType(ChatRoom.RoomType type);
}
</file>

<file path="backend/src/main/java/com/collabris/repository/ProjectRepository.java">
package com.collabris.repository;

import com.collabris.entity.Project;
import com.collabris.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProjectRepository extends JpaRepository<Project, Long> {
    List<Project> findByOwner(User owner);
    
    @Query("SELECT p FROM Project p JOIN p.members m WHERE m.id = :userId")
    List<Project> findByMemberId(@Param("userId") Long userId);
    
    @Query("SELECT p FROM Project p WHERE p.team.id = :teamId")
    List<Project> findByTeamId(@Param("teamId") Long teamId);
    
    @Query("SELECT p FROM Project p WHERE p.name LIKE %:search% OR p.description LIKE %:search%")
    List<Project> findBySearchTerm(@Param("search") String search);
}
</file>

<file path="backend/src/main/java/com/collabris/repository/RoleRepository.java">
package com.collabris.repository;

import com.collabris.entity.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(Role.ERole name);
}
</file>

<file path="backend/src/main/java/com/collabris/repository/TeamRepository.java">
package com.collabris.repository;

import com.collabris.entity.Team;
import com.collabris.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface TeamRepository extends JpaRepository<Team, Long> {
    List<Team> findByOwner(User owner);
    
    @Query("SELECT t FROM Team t JOIN t.members m WHERE m.id = :userId")
    List<Team> findByMemberId(@Param("userId") Long userId);
    
    @Query("SELECT t FROM Team t WHERE t.name LIKE %:search% OR t.description LIKE %:search%")
    List<Team> findBySearchTerm(@Param("search") String search);
}
</file>

<file path="backend/src/main/java/com/collabris/repository/UserRepository.java">
package com.collabris.repository;

import com.collabris.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    Boolean existsByUsername(String username);
    Boolean existsByEmail(String email);
    
    @Query("SELECT u FROM User u WHERE u.username LIKE %:search% OR u.email LIKE %:search% OR u.firstName LIKE %:search% OR u.lastName LIKE %:search%")
    List<User> findBySearchTerm(@Param("search") String search);
    
    @Query("SELECT u FROM User u JOIN u.roles r WHERE r.name = :roleName")
    List<User> findByRoleName(@Param("roleName") String roleName);
}
</file>

<file path="backend/src/main/java/com/collabris/repository/VerificationTokenRepository.java">
package com.collabris.repository;

import com.collabris.entity.VerificationToken;
import com.collabris.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface VerificationTokenRepository extends JpaRepository<VerificationToken, Long> {
    
    Optional<VerificationToken> findByCodeAndTokenType(String code, VerificationToken.TokenType tokenType);
    
    Optional<VerificationToken> findByUserAndTokenTypeAndUsedAtIsNull(User user, VerificationToken.TokenType tokenType);
    
    List<VerificationToken> findByUserAndTokenType(User user, VerificationToken.TokenType tokenType);
    
    @Query("SELECT t FROM VerificationToken t WHERE t.user.email = :email AND t.tokenType = :tokenType AND t.usedAt IS NULL ORDER BY t.createdAt DESC")
    Optional<VerificationToken> findLatestUnusedTokenByEmailAndType(@Param("email") String email, @Param("tokenType") VerificationToken.TokenType tokenType);
    
    @Query("SELECT t FROM VerificationToken t WHERE t.user.username = :username AND t.tokenType = :tokenType AND t.usedAt IS NULL ORDER BY t.createdAt DESC")
    Optional<VerificationToken> findLatestUnusedTokenByUsernameAndType(@Param("username") String username, @Param("tokenType") VerificationToken.TokenType tokenType);
    
    @Modifying
    @Query("DELETE FROM VerificationToken t WHERE t.expiresAt < :now")
    void deleteExpiredTokens(@Param("now") LocalDateTime now);
    
    @Modifying
    @Query("DELETE FROM VerificationToken t WHERE t.user = :user AND t.tokenType = :tokenType")
    void deleteByUserAndTokenType(@Param("user") User user, @Param("tokenType") VerificationToken.TokenType tokenType);
}
</file>

<file path="backend/src/main/java/com/collabris/security/jwt/AuthEntryPointJwt.java">
package com.collabris.security.jwt;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component
public class AuthEntryPointJwt implements AuthenticationEntryPoint {

    private static final Logger logger = LoggerFactory.getLogger(AuthEntryPointJwt.class);

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        logger.error("Unauthorized error: {}", authException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        final Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());

        final ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), body);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/security/jwt/AuthTokenFilter.java">
package com.collabris.security.jwt;

import com.collabris.security.services.UserDetailsServiceImpl;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

public class AuthTokenFilter extends OncePerRequestFilter {
    @Autowired
    private JwtUtils jwtUtils;

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    private static final Logger logger = LoggerFactory.getLogger(AuthTokenFilter.class);

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = parseJwt(request);
            if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
                String username = jwtUtils.getUserNameFromJwtToken(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(userDetails,
                                null,
                                userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            logger.error("Cannot set user authentication: {}", e);
        }

        filterChain.doFilter(request, response);
    }

    private String parseJwt(HttpServletRequest request) {
        String headerAuth = request.getHeader("Authorization");

        if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
            return headerAuth.substring(7);
        }

        return null;
    }
}
</file>

<file path="backend/src/main/java/com/collabris/security/jwt/JwtUtils.java">
package com.collabris.security.jwt;

import com.collabris.security.services.UserPrinciple;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;   // ← crypto stays here; Jakarta EE has no jakarta.crypto

import java.util.Date;

@Component
public class JwtUtils {

    private static final Logger logger = LoggerFactory.getLogger(JwtUtils.class);

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${jwt.expiration}")
    private int jwtExpirationMs;

    /**
     * Build a SecretKey for signing/verification.
     */
    private SecretKey key() {
        // Base64 decode the secret then build HMAC-SHA key
        return Keys.hmacShaKeyFor(Decoders.BASE64.decode(jwtSecret));
    }

    /**
     * Generate a JWT token for the authenticated user.
     */
    public String generateJwtToken(Authentication authentication) {
        UserPrinciple userPrincipal = (UserPrinciple) authentication.getPrincipal();

        return Jwts.builder()
                .subject(userPrincipal.getUsername())
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + jwtExpirationMs))
                .signWith(key(), SignatureAlgorithm.HS256)
                .compact();
    }

    /**
     * Extract username from token.
     */
    public String getUserNameFromJwtToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(key())
                .build()
                .parseSignedClaims(token)
                .getPayload();
        return claims.getSubject();
    }

    /**
     * Validate JWT token.
     */
    public boolean validateJwtToken(String authToken) {
        try {
            Jwts.parser()
                    .verifyWith(key())
                    .build()
                    .parseSignedClaims(authToken);
            return true;
        } catch (MalformedJwtException e) {
            logger.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            logger.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            logger.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            logger.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }
}
</file>

<file path="backend/src/main/java/com/collabris/security/services/UserDetailsServiceImpl.java">
package com.collabris.security.services;

import com.collabris.entity.User;
import com.collabris.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    UserRepository userRepository;

    @Override
    @Transactional
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found: " + username));

        return UserPrinciple.build(user);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/security/services/UserPrinciple.java">
package com.collabris.security.services;

import com.collabris.entity.User;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class UserPrinciple implements UserDetails {
    private Long id;
    private String username;
    private String email;

    @JsonIgnore
    private String password;

    private Collection<? extends GrantedAuthority> authorities;

    public UserPrinciple(Long id, String username, String email, String password,
                         Collection<? extends GrantedAuthority> authorities) {
        this.id = id;
        this.username = username;
        this.email = email;
        this.password = password;
        this.authorities = authorities;
    }

    public static UserPrinciple build(User user) {
        List<GrantedAuthority> authorities = user.getRoles().stream()
                .map(role -> new SimpleGrantedAuthority("ROLE_" + role.getName().name()))
                .collect(Collectors.toList());

        return new UserPrinciple(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getPassword(),
                authorities);
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    public Long getId() {
        return id;
    }

    public String getEmail() {
        return email;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        UserPrinciple user = (UserPrinciple) o;
        return Objects.equals(id, user.id);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/service/ChatService.java">
package com.collabris.service;

import com.collabris.dto.request.ChatMessageRequest;
import com.collabris.dto.request.ChatRoomRequest;
import com.collabris.entity.ChatMessage;
import com.collabris.entity.ChatRoom;
import com.collabris.entity.Project;
import com.collabris.entity.User;
import com.collabris.repository.ChatMessageRepository;
import com.collabris.repository.ChatRoomRepository;
import com.collabris.repository.ProjectRepository;
import com.collabris.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class ChatService {
    
    @Autowired
    private ChatRoomRepository chatRoomRepository;
    
    @Autowired
    private ChatMessageRepository chatMessageRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private ProjectRepository projectRepository;
    
    @Autowired
    private SimpMessagingTemplate messagingTemplate;

    public List<ChatRoom> getAllChatRooms() {
        return chatRoomRepository.findAll();
    }

    public ChatRoom getChatRoomById(Long id) {
        return chatRoomRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Chat room not found with id: " + id));
    }

    public List<ChatRoom> getChatRoomsByProjectId(Long projectId) {
        return chatRoomRepository.findByProjectId(projectId);
    }

    public ChatRoom createChatRoom(ChatRoomRequest chatRoomRequest, User createdBy) {
        ChatRoom chatRoom = new ChatRoom();
        chatRoom.setName(chatRoomRequest.getName());
        chatRoom.setDescription(chatRoomRequest.getDescription());
        chatRoom.setType(chatRoomRequest.getType() != null ? chatRoomRequest.getType() : ChatRoom.RoomType.GROUP);
        chatRoom.setCreatedBy(createdBy);
        
        if (chatRoomRequest.getProjectId() != null) {
            Project project = projectRepository.findById(chatRoomRequest.getProjectId())
                    .orElseThrow(() -> new RuntimeException("Project not found with id: " + chatRoomRequest.getProjectId()));
            chatRoom.setProject(project);
        }
        
        return chatRoomRepository.save(chatRoom);
    }

    public ChatRoom updateChatRoom(Long id, ChatRoomRequest chatRoomRequest) {
        ChatRoom chatRoom = getChatRoomById(id);
        
        if (chatRoomRequest.getName() != null) {
            chatRoom.setName(chatRoomRequest.getName());
        }
        if (chatRoomRequest.getDescription() != null) {
            chatRoom.setDescription(chatRoomRequest.getDescription());
        }
        if (chatRoomRequest.getType() != null) {
            chatRoom.setType(chatRoomRequest.getType());
        }
        
        return chatRoomRepository.save(chatRoom);
    }

    public void deleteChatRoom(Long id) {
        ChatRoom chatRoom = getChatRoomById(id);
        chatRoomRepository.delete(chatRoom);
    }

    public List<ChatMessage> getMessagesByChatRoomId(Long chatRoomId) {
        return chatMessageRepository.findByChatRoomIdOrderByCreatedAtAsc(chatRoomId);
    }

    public Page<ChatMessage> getMessagesByChatRoom(ChatRoom chatRoom, Pageable pageable) {
        return chatMessageRepository.findByChatRoomOrderByCreatedAtDesc(chatRoom, pageable);
    }

    public List<ChatMessage> getRecentMessages(Long chatRoomId, LocalDateTime since) {
        return chatMessageRepository.findRecentMessages(chatRoomId, since);
    }

    public ChatMessage sendMessage(ChatMessageRequest messageRequest, User sender) {
        ChatRoom chatRoom = getChatRoomById(messageRequest.getChatRoomId());
        
        ChatMessage message = new ChatMessage();
        message.setContent(messageRequest.getContent());
        message.setType(messageRequest.getType());
        message.setSender(sender);
        message.setChatRoom(chatRoom);
        
        ChatMessage savedMessage = chatMessageRepository.save(message);
        
        // Send message to WebSocket subscribers
        messagingTemplate.convertAndSend("/topic/chat/" + chatRoom.getId(), savedMessage);
        
        return savedMessage;
    }

    public void deleteMessage(Long messageId) {
        ChatMessage message = chatMessageRepository.findById(messageId)
                .orElseThrow(() -> new RuntimeException("Message not found with id: " + messageId));
        chatMessageRepository.delete(message);
    }

    public Long getMessageCount(Long chatRoomId) {
        return chatMessageRepository.countByChatRoomId(chatRoomId);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/service/EmailService.java">
package com.collabris.service;

import jakarta.mail.MessagingException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ClassPathResource;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;

import jakarta.mail.internet.MimeMessage;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.time.format.DateTimeFormatter;
import java.util.Map;

@Service
public class EmailService {
    private static final Logger log = LoggerFactory.getLogger(EmailService.class);

    private final JavaMailSender mailSender;

    @Value("${app.mail.from:no-reply@collabris.local}")
    private String fromAddress;

    @Value("${app.mail.enabled:false}")
    private boolean mailEnabled;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void sendEmail(String to, String subject, String templatePath, Map<String, String> variables) {
        String body = renderTemplate(templatePath, variables);
        if (!mailEnabled) {
            log.info("[MAIL DISABLED] To: {} Subject: {} Body: {}", to, subject, body);
            return;
        }
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, MimeMessageHelper.MULTIPART_MODE_MIXED_RELATED, StandardCharsets.UTF_8.name());
            helper.setFrom(fromAddress);
            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(body, true);
            mailSender.send(message);
        } catch (MessagingException e) {
            log.error("Failed to send email to {}", to, e);
        }
    }

    private String renderTemplate(String templatePath, Map<String, String> variables) {
        try {
            ClassPathResource resource = new ClassPathResource(templatePath);
            String content = Files.readString(resource.getFile().toPath(), StandardCharsets.UTF_8);
            for (Map.Entry<String, String> entry : variables.entrySet()) {
                content = content.replace("{{" + entry.getKey() + "}}", entry.getValue());
            }
            return content;
        } catch (IOException e) {
            // Fallback simple template
            StringBuilder sb = new StringBuilder();
            for (Map.Entry<String, String> entry : variables.entrySet()) {
                sb.append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
            }
            return sb.toString();
        }
    }
}
</file>

<file path="backend/src/main/java/com/collabris/service/ProjectService.java">
package com.collabris.service;

import com.collabris.dto.request.ProjectRequest;
import com.collabris.entity.Project;
import com.collabris.entity.Team;
import com.collabris.entity.User;
import com.collabris.repository.ProjectRepository;
import com.collabris.repository.TeamRepository;
import com.collabris.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
public class ProjectService {
    
    @Autowired
    private ProjectRepository projectRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private TeamRepository teamRepository;

    public List<Project> getAllProjects() {
        return projectRepository.findAll();
    }

    public Project getProjectById(Long id) {
        return projectRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Project not found with id: " + id));
    }

    public List<Project> getProjectsByOwner(User owner) {
        return projectRepository.findByOwner(owner);
    }

    public List<Project> getProjectsByMemberId(Long userId) {
        return projectRepository.findByMemberId(userId);
    }

    public List<Project> getProjectsByTeamId(Long teamId) {
        return projectRepository.findByTeamId(teamId);
    }

    public Project createProject(ProjectRequest projectRequest, User owner) {
        Project project = new Project(projectRequest.getName(), projectRequest.getDescription(), owner);
        
        if (projectRequest.getStatus() != null) {
            project.setStatus(projectRequest.getStatus());
        }
        
        if (projectRequest.getStartDate() != null) {
            project.setStartDate(projectRequest.getStartDate());
        }
        
        if (projectRequest.getEndDate() != null) {
            project.setEndDate(projectRequest.getEndDate());
        }
        
        // Set team if provided
        if (projectRequest.getTeamId() != null) {
            Team team = teamRepository.findById(projectRequest.getTeamId())
                    .orElseThrow(() -> new RuntimeException("Team not found with id: " + projectRequest.getTeamId()));
            project.setTeam(team);
        }
        
        // Add members if provided
        if (projectRequest.getMemberIds() != null && !projectRequest.getMemberIds().isEmpty()) {
            Set<User> members = new HashSet<>();
            for (Long memberId : projectRequest.getMemberIds()) {
                User member = userRepository.findById(memberId)
                        .orElseThrow(() -> new UsernameNotFoundException("User not found with id: " + memberId));
                members.add(member);
            }
            project.setMembers(members);
        }
        
        return projectRepository.save(project);
    }

    public Project updateProject(Long id, ProjectRequest projectRequest) {
        Project project = getProjectById(id);
        
        if (projectRequest.getName() != null) {
            project.setName(projectRequest.getName());
        }
        if (projectRequest.getDescription() != null) {
            project.setDescription(projectRequest.getDescription());
        }
        if (projectRequest.getStatus() != null) {
            project.setStatus(projectRequest.getStatus());
        }
        if (projectRequest.getStartDate() != null) {
            project.setStartDate(projectRequest.getStartDate());
        }
        if (projectRequest.getEndDate() != null) {
            project.setEndDate(projectRequest.getEndDate());
        }
        
        // Update team if provided
        if (projectRequest.getTeamId() != null) {
            Team team = teamRepository.findById(projectRequest.getTeamId())
                    .orElseThrow(() -> new RuntimeException("Team not found with id: " + projectRequest.getTeamId()));
            project.setTeam(team);
        }
        
        // Update members if provided
        if (projectRequest.getMemberIds() != null) {
            Set<User> members = new HashSet<>();
            for (Long memberId : projectRequest.getMemberIds()) {
                User member = userRepository.findById(memberId)
                        .orElseThrow(() -> new UsernameNotFoundException("User not found with id: " + memberId));
                members.add(member);
            }
            project.setMembers(members);
        }
        
        return projectRepository.save(project);
    }

    public void deleteProject(Long id) {
        Project project = getProjectById(id);
        projectRepository.delete(project);
    }

    public Project addMemberToProject(Long projectId, Long userId) {
        Project project = getProjectById(projectId);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with id: " + userId));
        
        project.getMembers().add(user);
        return projectRepository.save(project);
    }

    public Project removeMemberFromProject(Long projectId, Long userId) {
        Project project = getProjectById(projectId);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with id: " + userId));
        
        project.getMembers().remove(user);
        return projectRepository.save(project);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/service/TokenService.java">
package com.collabris.service;

import com.collabris.entity.User;
import com.collabris.entity.VerificationToken;
import com.collabris.repository.VerificationTokenRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.Optional;

@Service
public class TokenService {
    
    @Autowired
    private VerificationTokenRepository tokenRepository;
    
    private static final String CHARACTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    private static final int TOKEN_LENGTH = 6;
    private final SecureRandom random = new SecureRandom();
    
    @Transactional
    public VerificationToken createVerificationToken(User user, VerificationToken.TokenType tokenType) {
        // Delete any existing unused tokens for this user and type
        tokenRepository.deleteByUserAndTokenType(user, tokenType);
        
        // Generate a new 6-character alphanumeric code
        String code = generateRandomCode();
        
        // Create and save the new token
        VerificationToken token = new VerificationToken(user, code, tokenType);
        return tokenRepository.save(token);
    }
    
    @Transactional
    public boolean verifyToken(String code, VerificationToken.TokenType tokenType) {
        Optional<VerificationToken> tokenOpt = tokenRepository.findByCodeAndTokenType(code, tokenType);
        
        if (tokenOpt.isEmpty()) {
            return false;
        }
        
        VerificationToken token = tokenOpt.get();
        
        // Check if token is expired or already used
        if (token.isExpired() || token.isUsed()) {
            return false;
        }
        
        // Mark token as used
        token.markAsUsed();
        tokenRepository.save(token);
        
        return true;
    }
    
    @Transactional(readOnly = true)
    public Optional<VerificationToken> findValidToken(String code, VerificationToken.TokenType tokenType) {
        Optional<VerificationToken> tokenOpt = tokenRepository.findByCodeAndTokenType(code, tokenType);
        
        if (tokenOpt.isEmpty()) {
            return Optional.empty();
        }
        
        VerificationToken token = tokenOpt.get();
        
        // Return only if token is valid (not expired and not used)
        if (!token.isExpired() && !token.isUsed()) {
            return Optional.of(token);
        }
        
        return Optional.empty();
    }
    
    @Transactional(readOnly = true)
    public Optional<VerificationToken> findLatestTokenByEmail(String email, VerificationToken.TokenType tokenType) {
        return tokenRepository.findLatestUnusedTokenByEmailAndType(email, tokenType);
    }
    
    @Transactional(readOnly = true)
    public Optional<VerificationToken> findLatestTokenByUsername(String username, VerificationToken.TokenType tokenType) {
        return tokenRepository.findLatestUnusedTokenByUsernameAndType(username, tokenType);
    }
    
    @Transactional
    public void consumeToken(VerificationToken token) {
        token.markAsUsed();
        tokenRepository.save(token);
    }
    
    private String generateRandomCode() {
        StringBuilder code = new StringBuilder(TOKEN_LENGTH);
        for (int i = 0; i < TOKEN_LENGTH; i++) {
            code.append(CHARACTERS.charAt(random.nextInt(CHARACTERS.length())));
        }
        return code.toString();
    }
    
    // Scheduled method to clean up expired tokens (runs every hour)
    @Scheduled(fixedRate = 3600000) // 1 hour in milliseconds
    @Transactional
    public void cleanupExpiredTokens() {
        tokenRepository.deleteExpiredTokens(LocalDateTime.now());
    }
    
    @Transactional(readOnly = true)
    public boolean hasValidToken(User user, VerificationToken.TokenType tokenType) {
        Optional<VerificationToken> token = tokenRepository.findByUserAndTokenTypeAndUsedAtIsNull(user, tokenType);
        return token.isPresent() && !token.get().isExpired();
    }
}
</file>

<file path="backend/src/main/java/com/collabris/service/UserService.java">
package com.collabris.service;

import com.collabris.entity.Role;
import com.collabris.entity.User;
import com.collabris.repository.RoleRepository;
import com.collabris.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;

@Service
public class UserService {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    public UserService(UserRepository userRepository,
                       RoleRepository roleRepository,
                       PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public User registerNewUser(User user, Set<String> roleNames) {
        if (userRepository.existsByUsername(user.getUsername())) {
            throw new RuntimeException("Username already exists");
        }
        if (userRepository.existsByEmail(user.getEmail())) {
            throw new RuntimeException("Email already exists");
        }

        // Encode password
        user.setPassword(passwordEncoder.encode(user.getPassword()));

        // Set roles
        Set<Role> roles = new HashSet<>();
        for (String roleName : roleNames) {
            Role.ERole eRole = Role.ERole.valueOf(roleName.toUpperCase());
            Role role = roleRepository.findByName(eRole)
                    .orElseThrow(() -> new RuntimeException("Role not found: " + roleName));
            roles.add(role);
        }
        user.setRoles(roles);

        return userRepository.save(user);
    }

    public Optional<User> findByUsername(String username) {
        return userRepository.findByUsername(username);
    }

    public Optional<User> findByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    public Optional<User> getUserById(Long id) {
        return userRepository.findById(id);
    }

    public User updateUser(Long id, User updatedUser) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));

        user.setFirstName(updatedUser.getFirstName());
        user.setLastName(updatedUser.getLastName());
        user.setEmail(updatedUser.getEmail());

        if (updatedUser.getPassword() != null && !updatedUser.getPassword().isBlank()) {
            user.setPassword(passwordEncoder.encode(updatedUser.getPassword()));
        }

        return userRepository.save(user);
    }

    public void deleteUser(Long id) {
        if (!userRepository.existsById(id)) {
            throw new RuntimeException("User not found with id " + id);
        }
        userRepository.deleteById(id);
    }
}
</file>

<file path="backend/src/main/resources/templates/password-reset.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Password Reset - Collabris</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        .container {
            max-width: 600px;
            margin: 40px auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: 600;
        }
        .content {
            padding: 40px 30px;
            text-align: center;
        }
        .verification-code {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            border: 2px dashed #6b7280;
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
            font-size: 32px;
            font-weight: bold;
            letter-spacing: 4px;
            color: #1f2937;
            font-family: 'Courier New', monospace;
        }
        .message {
            line-height: 1.6;
            color: #4b5563;
            margin-bottom: 30px;
        }
        .footer {
            background: #f9fafb;
            padding: 20px;
            text-align: center;
            font-size: 14px;
            color: #6b7280;
            border-top: 1px solid #e5e7eb;
        }
        .warning {
            background: #fee2e2;
            border: 1px solid #dc2626;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            color: #991b1b;
            font-size: 14px;
        }
        .security-notice {
            background: #eff6ff;
            border: 1px solid #3b82f6;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            color: #1d4ed8;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔐 Password Reset</h1>
        </div>
        
        <div class="content">
            <p class="message">
                Hi <strong>{{firstName}}</strong>,<br><br>
                We received a request to reset your password for your Collabris account. Use the verification code below to proceed with resetting your password:
            </p>
            
            <div class="verification-code">
                {{verificationCode}}
            </div>
            
            <div class="warning">
                ⏰ This verification code will expire in <strong>10 minutes</strong> for security reasons.
            </div>
            
            <div class="security-notice">
                🔒 For your security, this code can only be used once. After entering the code, you'll be able to set a new password.
            </div>
            
            <p class="message">
                If you didn't request a password reset, please ignore this email. Your password will remain unchanged.
            </p>
        </div>
        
        <div class="footer">
            <p>© 2024 Collabris. All rights reserved.</p>
            <p>This is an automated message, please do not reply to this email.</p>
        </div>
    </div>
</body>
</html>
</file>

<file path="backend/src/test/java/com/collabris/CollabrisApplicationTests.java">
package com.collabris;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;

@SpringBootTest
@TestPropertySource(locations = "classpath:application-test.properties")
class CollabrisApplicationTests {

    @Test
    void contextLoads() {
    }
}
</file>

<file path="backend/src/test/java/com/collabris/controller/AuthControllerTest.java">
package com.collabris.controller;

import com.collabris.dto.request.LoginRequest;
import com.collabris.dto.request.SignupRequest;
import com.collabris.entity.Role;
import com.collabris.entity.User;
import com.collabris.repository.RoleRepository;
import com.collabris.repository.UserRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import java.util.Set;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@AutoConfigureMockMvc
@TestPropertySource(locations = "classpath:application-test.properties")
@Transactional // Ensures tests are rolled back and isolated
public class AuthControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @BeforeEach
    void setUp() {
        // Clean up database before each test to ensure isolation
        userRepository.deleteAll();
        roleRepository.deleteAll();
        
        // Ensure roles exist for tests
        roleRepository.save(new Role(Role.ERole.ROLE_MEMBER));
        roleRepository.save(new Role(Role.ERole.ROLE_ADMIN));
    }

    @AfterEach
    void tearDown() {
        // Clean up database after each test
        userRepository.deleteAll();
        roleRepository.deleteAll();
    }

    @Test
    void testSignup() throws Exception {
        SignupRequest signupRequest = new SignupRequest();
        signupRequest.setUsername("testuser");
        signupRequest.setEmail("testuser@example.com");
        signupRequest.setPassword("Password123");
        signupRequest.setFirstName("Test");
        signupRequest.setLastName("User");

        mockMvc.perform(post("/api/auth/signup")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(signupRequest)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("User registered successfully! Please check your email to verify your account."));
    }

    @Test
    void testLogin() throws Exception {
        // Create a pre-existing, enabled user for the login test
        User user = new User();
        user.setUsername("loginuser");
        user.setEmail("loginuser@example.com");
        // IMPORTANT: Use the password encoder to hash the password
        user.setPassword(passwordEncoder.encode("Password123"));
        user.setFirstName("Login");
        user.setLastName("User");
        // IMPORTANT: Set the user to enabled to bypass email verification for this test
        user.setEnabled(true);

        Role memberRole = roleRepository.findByName(Role.ERole.ROLE_MEMBER)
                .orElseThrow(() -> new RuntimeException("MEMBER Role not found"));
        user.setRoles(Set.of(memberRole));
        userRepository.save(user);

        LoginRequest loginRequest = new LoginRequest();
        loginRequest.setUsername("loginuser");
        loginRequest.setPassword("Password123");

        mockMvc.perform(post("/api/auth/signin")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(loginRequest)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.token").exists());
    }
}
</file>

<file path="backend/src/test/resources/application-test.properties">
# -----------------------------
# Test Database Configuration
# -----------------------------
spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# -----------------------------
# JPA/Hibernate Configuration
# -----------------------------
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect
spring.jpa.open-in-view=false

# -----------------------------
# JWT Configuration for Tests
# -----------------------------
jwt.secret=testSecretKeyForJWTTokenGenerationInTestEnvironment123456789
jwt.expiration=86400000

# -----------------------------
# CORS Configuration for Tests
# -----------------------------
cors.allowed-origins=http://localhost:3000,http://localhost:5173

# -----------------------------
# Server Configuration for Tests
# -----------------------------
# Use port 0 so Spring Boot picks a random free port
server.port=0

# -----------------------------
# Swagger/OpenAPI Configuration
# -----------------------------
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method

# -----------------------------
# Jackson Configuration
# -----------------------------
spring.jackson.serialization.fail-on-empty-beans=false

# -----------------------------
# File Upload Configuration
# -----------------------------
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
file.upload-dir=uploads

# -----------------------------
# Email Configuration (disabled for tests)
# -----------------------------
spring.mail.host=
spring.mail.port=
spring.mail.username=
spring.mail.password=
spring.mail.properties.mail.smtp.auth=false
spring.mail.properties.mail.smtp.starttls.enable=false

# -----------------------------
# Logging Configuration
# -----------------------------
logging.level.com.collabris=DEBUG
logging.level.org.springframework.security=DEBUG
</file>

<file path="frontend/eslint.config.js">
import js from '@eslint/js';
import globals from 'globals';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  }
);
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Collabris</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="frontend/src/components/Common/LoadingSpinner.tsx">
import React from 'react';
import { Box, CircularProgress, Typography } from '@mui/material';

interface LoadingSpinnerProps {
  message?: string;
  size?: number;
}

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ 
  message = 'Loading...', 
  size = 40 
}) => {
  return (
    <Box
      display="flex"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      minHeight="200px"
      className="animate-fade-in"
    >
      <CircularProgress size={size} sx={{ mb: 2 }} />
      <Typography variant="body2" color="text.secondary">
        {message}
      </Typography>
    </Box>
  );
};

export default LoadingSpinner;
</file>

<file path="frontend/src/components/Common/StatsCard.jsx">
import React from 'react';
import { Card, CardContent, Typography, Box, Avatar } from '@mui/material';
import { motion } from 'framer-motion';

const StatsCard = ({ title, value, icon, color = 'primary', trend }) => {
  return (
    <motion.div
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      transition={{ duration: 0.2 }}
    >
      <Card
        sx={{
          height: '100%',
          background: (theme) =>
            `linear-gradient(135deg, ${theme.palette[color].main}15 0%, ${theme.palette[color].main}05 100%)`,
          border: (theme) => `1px solid ${theme.palette[color].main}20`,
        }}
      >
        <CardContent>
          <Box display="flex" alignItems="center" justifyContent="space-between">
            <Box>
              <Typography variant="h4" fontWeight="bold" color={`${color}.main`}>
                {value}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                {title}
              </Typography>
              {trend && (
                <Typography
                  variant="caption"
                  color={trend > 0 ? 'success.main' : 'error.main'}
                  sx={{ mt: 1, display: 'block' }}
                >
                  {trend > 0 ? '+' : ''}{trend}% from last month
                </Typography>
              )}
            </Box>
            <Avatar
              sx={{
                bgcolor: `${color}.main`,
                width: 56,
                height: 56,
              }}
            >
              {icon}
            </Avatar>
          </Box>
        </CardContent>
      </Card>
    </motion.div>
  );
};

export default StatsCard;
</file>

<file path="frontend/src/components/Layout/Layout.tsx">
import React from 'react';
import {
  Box,
  Drawer,
  AppBar,
  Toolbar,
  List,
  Typography,
  Divider,
  IconButton,
  Avatar,
  Menu,
  MenuItem,
  useTheme,
  useMediaQuery,
  Badge,
  alpha,
} from '@mui/material';
import {
  Menu as MenuIcon,
  Dashboard as DashboardIcon,
  People as PeopleIcon,
  Assignment as ProjectIcon,
  Chat as ChatIcon,
  Settings as SettingsIcon,
  Person as PersonIcon,
  Logout as LogoutIcon,
  Notifications as NotificationsIcon,
  Brightness4 as DarkModeIcon,
  Brightness7 as LightModeIcon,
  AdminPanelSettings as AdminIcon,
} from '@mui/icons-material';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAppSelector, useAppDispatch } from '../../store/store';
import { selectUser, selectIsAdmin, logout } from '../../store/slices/authSlice';
import { selectEffectiveTheme, toggleTheme } from '../../store/slices/themeSlice';
import { toggleSidebar, selectSidebarOpen, selectMobileSidebarOpen, toggleMobileSidebar } from '../../store/slices/uiSlice';
import NavigationItem from './NavigationItem';

const drawerWidth = 280;

interface LayoutProps {
  children: React.ReactNode;
}

const Layout: React.FC<LayoutProps> = ({ children }) => {
  const theme = useTheme();
  const navigate = useNavigate();
  const location = useLocation();
  const dispatch = useAppDispatch();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  
  const user = useAppSelector(selectUser);
  const isAdmin = useAppSelector(selectIsAdmin);
  const currentTheme = useAppSelector(selectEffectiveTheme);
  const sidebarOpen = useAppSelector(selectSidebarOpen);
  const mobileSidebarOpen = useAppSelector(selectMobileSidebarOpen);
  
  const [anchorEl, setAnchorEl] = React.useState<null | HTMLElement>(null);
  
  const handleProfileMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };
  
  const handleMenuClose = () => {
    setAnchorEl(null);
  };
  
  const handleLogout = () => {
    dispatch(logout());
    navigate('/login');
  };
  
  const handleDrawerToggle = () => {
    if (isMobile) {
      dispatch(toggleMobileSidebar());
    } else {
      dispatch(toggleSidebar());
    }
  };
  
  const handleThemeToggle = () => {
    dispatch(toggleTheme());
  };
  
  const navigationItems = [
    {
      text: 'Dashboard',
      icon: <DashboardIcon />,
      path: '/dashboard',
      active: location.pathname === '/dashboard',
    },
    {
      text: 'Teams',
      icon: <PeopleIcon />,
      path: '/teams',
      active: location.pathname.startsWith('/teams'),
    },
    {
      text: 'Projects', 
      icon: <ProjectIcon />,
      path: '/projects',
      active: location.pathname.startsWith('/projects'),
    },
    {
      text: 'Chat',
      icon: <ChatIcon />,
      path: '/chat',
      active: location.pathname.startsWith('/chat'),
    },
    ...(isAdmin ? [{
      text: 'Admin Panel',
      icon: <AdminIcon />,
      path: '/admin/dashboard',
      active: location.pathname.startsWith('/admin'),
    }] : []),
  ];
  
  const userMenuItems = [
    {
      text: 'Profile',
      icon: <PersonIcon />,
      onClick: () => navigate('/profile'),
    },
    {
      text: 'Settings',
      icon: <SettingsIcon />,
      onClick: () => navigate('/settings'),
    },
    {
      text: 'Logout',
      icon: <LogoutIcon />,
      onClick: handleLogout,
    },
  ];
  
  const drawer = (
    <Box
      sx={{
        height: '100%',
        background: theme.palette.mode === 'light' 
          ? 'linear-gradient(180deg, #f8fafc 0%, #f1f5f9 100%)'
          : 'linear-gradient(180deg, #1e293b 0%, #0f172a 100%)',
        backdropFilter: 'blur(20px)',
      }}
    >
      {/* Logo */}
      <Box
        sx={{
          p: 3,
          borderBottom: `1px solid ${alpha(theme.palette.divider, 0.1)}`,
        }}
      >
        <Typography
          variant="h5"
          sx={{
            fontWeight: 700,
            background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent',
            backgroundClip: 'text',
          }}
        >
          Collabris
        </Typography>
        <Typography
          variant="body2"
          sx={{
            color: theme.palette.text.secondary,
            mt: 0.5,
          }}
        >
          Collaboration Platform
        </Typography>
      </Box>
      
      {/* Navigation */}
      <List sx={{ px: 2, py: 2 }}>
        {navigationItems.map((item) => (
          <NavigationItem
            key={item.text}
            {...item}
            onClick={() => navigate(item.path)}
          />
        ))}
      </List>
      
      <Divider sx={{ mx: 2, opacity: 0.1 }} />
      
      {/* User Info */}
      <Box sx={{ p: 2, mt: 'auto' }}>
        <Box
          sx={{
            p: 2,
            borderRadius: 2,
            background: alpha(theme.palette.primary.main, 0.1),
            border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
          }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
            <Avatar
              sx={{
                width: 32,
                height: 32,
                mr: 1.5,
                background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)',
                fontSize: '0.875rem',
              }}
            >
              {user?.firstName?.charAt(0) || user?.username?.charAt(0) || 'U'}
            </Avatar>
            <Box sx={{ flex: 1, minWidth: 0 }}>
              <Typography
                variant="subtitle2"
                sx={{
                  fontWeight: 600,
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  whiteSpace: 'nowrap',
                }}
              >
                {user?.firstName && user?.lastName 
                  ? `${user.firstName} ${user.lastName}`
                  : user?.username || 'User'
                }
              </Typography>
              <Typography
                variant="caption"
                sx={{
                  color: theme.palette.text.secondary,
                  overflow: 'hidden',
                  textOverflow: 'ellipsis',
                  whiteSpace: 'nowrap',
                  display: 'block',
                }}
              >
                {user?.roles?.[0]?.name?.replace('ROLE_', '') || 'Member'}
              </Typography>
            </Box>
          </Box>
        </Box>
      </Box>
    </Box>
  );
  
  return (
    <Box sx={{ display: 'flex', minHeight: '100vh' }}>
      {/* App Bar */}
      <AppBar
        position="fixed"
        elevation={0}
        sx={{
          width: { md: `calc(100% - ${sidebarOpen ? drawerWidth : 0}px)` },
          ml: { md: sidebarOpen ? `${drawerWidth}px` : 0 },
          backgroundColor: alpha(theme.palette.background.paper, 0.8),
          backdropFilter: 'blur(20px)',
          borderBottom: `1px solid ${alpha(theme.palette.divider, 0.1)}`,
          color: theme.palette.text.primary,
        }}
      >
        <Toolbar>
          <IconButton
            color="inherit"
            edge="start"
            onClick={handleDrawerToggle}
            sx={{ mr: 2 }}
          >
            <MenuIcon />
          </IconButton>
          
          <Typography variant="h6" noWrap sx={{ flexGrow: 1, fontWeight: 600 }}>
            {navigationItems.find(item => item.active)?.text || 'Dashboard'}
          </Typography>
          
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <IconButton color="inherit" onClick={handleThemeToggle}>
              {currentTheme === 'dark' ? <LightModeIcon /> : <DarkModeIcon />}
            </IconButton>
            
            <IconButton color="inherit">
              <Badge badgeContent={3} color="error">
                <NotificationsIcon />
              </Badge>
            </IconButton>
            
            <IconButton
              edge="end"
              onClick={handleProfileMenuOpen}
              color="inherit"
            >
              <Avatar
                sx={{
                  width: 36,
                  height: 36,
                  background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)',
                  fontSize: '0.875rem',
                }}
              >
                {user?.firstName?.charAt(0) || user?.username?.charAt(0) || 'U'}
              </Avatar>
            </IconButton>
          </Box>
        </Toolbar>
      </AppBar>
      
      {/* Profile Menu */}
      <Menu
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleMenuClose}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
        PaperProps={{
          sx: {
            mt: 1,
            minWidth: 200,
            borderRadius: 2,
            boxShadow: '0 8px 32px rgba(0,0,0,0.12)',
          },
        }}
      >
        {userMenuItems.map((item) => (
          <MenuItem
            key={item.text}
            onClick={() => {
              handleMenuClose();
              item.onClick();
            }}
            sx={{ py: 1.5, px: 2 }}
          >
            <Box sx={{ mr: 2, color: 'action.active' }}>
              {item.icon}
            </Box>
            {item.text}
          </MenuItem>
        ))}
      </Menu>
      
      {/* Navigation Drawer */}
      <Box
        component="nav"
        sx={{ width: { md: sidebarOpen ? drawerWidth : 0 }, flexShrink: { md: 0 } }}
      >
        <Drawer
          variant={isMobile ? 'temporary' : 'persistent'}
          open={isMobile ? mobileSidebarOpen : sidebarOpen}
          onClose={handleDrawerToggle}
          ModalProps={{
            keepMounted: true, // Better mobile performance
          }}
          sx={{
            '& .MuiDrawer-paper': {
              boxSizing: 'border-box',
              width: drawerWidth,
              border: 'none',
              boxShadow: '4px 0 20px rgba(0,0,0,0.08)',
            },
          }}
        >
          {drawer}
        </Drawer>
      </Box>
      
      {/* Main Content */}
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          width: { md: `calc(100% - ${sidebarOpen ? drawerWidth : 0}px)` },
          minHeight: '100vh',
          background: theme.palette.mode === 'light'
            ? 'linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%)'
            : 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)',
        }}
      >
        <Toolbar />
        <Box sx={{ p: { xs: 2, md: 3 } }}>
          {children}
        </Box>
      </Box>
    </Box>
  );
};

export default Layout;
</file>

<file path="frontend/src/components/Layout/Navbar.jsx">
import React, { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { useNavigate, Link } from 'react-router-dom';
import {
  AppBar,
  Toolbar,
  Typography,
  Button,
  IconButton,
  Menu,
  MenuItem,
  Avatar,
  Box,
  Switch,
  Tooltip,
} from '@mui/material';
import {
  AccountCircle,
  Settings,
  Logout,
  Dashboard,
  People,
  DarkMode,
  LightMode,
  Menu as MenuIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import { logout } from '../../store/slices/authSlice';
import { toggleDarkMode } from '../../store/slices/themeSlice';

const Navbar = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const { user, isAuthenticated } = useSelector((state) => state.auth);
  const { darkMode } = useSelector((state) => state.theme);
  
  const [anchorEl, setAnchorEl] = useState(null);
  const [mobileMenuAnchor, setMobileMenuAnchor] = useState(null);

  const handleProfileMenuOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  const handleMobileMenuOpen = (event) => {
    setMobileMenuAnchor(event.currentTarget);
  };

  const handleMobileMenuClose = () => {
    setMobileMenuAnchor(null);
  };

  const handleLogout = () => {
    dispatch(logout());
    navigate('/login');
    handleMenuClose();
  };

  const handleThemeToggle = () => {
    dispatch(toggleDarkMode());
  };

  const isAdmin = user?.roles?.includes('ROLE_ADMIN');

  const menuItems = [
    { label: 'Dashboard', path: isAdmin ? '/admin' : '/dashboard', icon: <Dashboard /> },
    ...(isAdmin ? [{ label: 'Users', path: '/admin/users', icon: <People /> }] : []),
    { label: 'Profile', path: '/profile', icon: <AccountCircle /> },
    { label: 'Settings', path: '/settings', icon: <Settings /> },
  ];

  return (
    <AppBar position="sticky" elevation={0} sx={{ backdropFilter: 'blur(10px)' }}>
      <Toolbar>
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.5 }}
        >
          <Typography
            variant="h6"
            component={Link}
            to={isAuthenticated ? (isAdmin ? '/admin' : '/dashboard') : '/'}
            sx={{
              flexGrow: 1,
              textDecoration: 'none',
              color: 'inherit',
              fontWeight: 700,
              background: 'linear-gradient(45deg, #18BC9C, #2C3E50)',
              backgroundClip: 'text',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
            }}
          >
            Collabris
          </Typography>
        </motion.div>

        <Box sx={{ flexGrow: 1 }} />

        {isAuthenticated && (
          <>
            {/* Desktop Menu */}
            <Box sx={{ display: { xs: 'none', md: 'flex' }, alignItems: 'center', gap: 1 }}>
              {menuItems.map((item) => (
                <Button
                  key={item.path}
                  component={Link}
                  to={item.path}
                  startIcon={item.icon}
                  color="inherit"
                  sx={{ mx: 1 }}
                >
                  {item.label}
                </Button>
              ))}
              
              <Tooltip title="Toggle theme">
                <IconButton onClick={handleThemeToggle} color="inherit">
                  {darkMode ? <LightMode /> : <DarkMode />}
                </IconButton>
              </Tooltip>

              <IconButton onClick={handleProfileMenuOpen} color="inherit">
                <Avatar
                  src={user?.profilePicture}
                  alt={user?.username}
                  sx={{ width: 32, height: 32 }}
                >
                  {user?.username?.charAt(0).toUpperCase()}
                </Avatar>
              </IconButton>
            </Box>

            {/* Mobile Menu */}
            <Box sx={{ display: { xs: 'flex', md: 'none' } }}>
              <IconButton onClick={handleMobileMenuOpen} color="inherit">
                <MenuIcon />
              </IconButton>
            </Box>
          </>
        )}

        {!isAuthenticated && (
          <Box sx={{ display: 'flex', gap: 1 }}>
            <Button component={Link} to="/login" color="inherit">
              Login
            </Button>
            <Button component={Link} to="/register" variant="outlined" color="inherit">
              Register
            </Button>
          </Box>
        )}

        {/* Profile Menu */}
        <Menu
          anchorEl={anchorEl}
          open={Boolean(anchorEl)}
          onClose={handleMenuClose}
          transformOrigin={{ horizontal: 'right', vertical: 'top' }}
          anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
        >
          <MenuItem onClick={() => { navigate('/profile'); handleMenuClose(); }}>
            <AccountCircle sx={{ mr: 1 }} />
            Profile
          </MenuItem>
          <MenuItem onClick={() => { navigate('/settings'); handleMenuClose(); }}>
            <Settings sx={{ mr: 1 }} />
            Settings
          </MenuItem>
          <MenuItem onClick={handleLogout}>
            <Logout sx={{ mr: 1 }} />
            Logout
          </MenuItem>
        </Menu>

        {/* Mobile Menu */}
        <Menu
          anchorEl={mobileMenuAnchor}
          open={Boolean(mobileMenuAnchor)}
          onClose={handleMobileMenuClose}
          transformOrigin={{ horizontal: 'right', vertical: 'top' }}
          anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
        >
          {menuItems.map((item) => (
            <MenuItem
              key={item.path}
              onClick={() => {
                navigate(item.path);
                handleMobileMenuClose();
              }}
            >
              {item.icon}
              <Typography sx={{ ml: 1 }}>{item.label}</Typography>
            </MenuItem>
          ))}
          <MenuItem onClick={handleThemeToggle}>
            {darkMode ? <LightMode /> : <DarkMode />}
            <Typography sx={{ ml: 1 }}>
              {darkMode ? 'Light Mode' : 'Dark Mode'}
            </Typography>
          </MenuItem>
          <MenuItem onClick={handleLogout}>
            <Logout />
            <Typography sx={{ ml: 1 }}>Logout</Typography>
          </MenuItem>
        </Menu>
      </Toolbar>
    </AppBar>
  );
};

export default Navbar;
</file>

<file path="frontend/src/components/Layout/NavigationItem.tsx">
import React from 'react';
import {
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  useTheme,
  alpha,
} from '@mui/material';

interface NavigationItemProps {
  text: string;
  icon: React.ReactNode;
  active: boolean;
  onClick: () => void;
}

const NavigationItem: React.FC<NavigationItemProps> = ({
  text,
  icon,
  active,
  onClick,
}) => {
  const theme = useTheme();

  return (
    <ListItem disablePadding sx={{ mb: 0.5 }}>
      <ListItemButton
        onClick={onClick}
        sx={{
          borderRadius: 2,
          py: 1.5,
          px: 2,
          minHeight: 48,
          backgroundColor: active
            ? alpha(theme.palette.primary.main, 0.15)
            : 'transparent',
          border: active 
            ? `1px solid ${alpha(theme.palette.primary.main, 0.3)}`
            : '1px solid transparent',
          color: active 
            ? theme.palette.primary.main
            : theme.palette.text.primary,
          '&:hover': {
            backgroundColor: active
              ? alpha(theme.palette.primary.main, 0.2)
              : alpha(theme.palette.action.hover, 0.08),
            transform: 'translateX(4px)',
            transition: 'all 0.2s ease-in-out',
          },
          '&:before': active ? {
            content: '""',
            position: 'absolute',
            left: 0,
            top: '50%',
            transform: 'translateY(-50%)',
            width: 3,
            height: '60%',
            backgroundColor: theme.palette.primary.main,
            borderRadius: '0 2px 2px 0',
          } : {},
          transition: 'all 0.2s ease-in-out',
        }}
      >
        <ListItemIcon
          sx={{
            minWidth: 40,
            color: 'inherit',
            '& svg': {
              fontSize: '1.25rem',
            },
          }}
        >
          {icon}
        </ListItemIcon>
        <ListItemText
          primary={text}
          sx={{
            '& .MuiListItemText-primary': {
              fontSize: '0.875rem',
              fontWeight: active ? 600 : 500,
              letterSpacing: '0.025em',
            },
          }}
        />
      </ListItemButton>
    </ListItem>
  );
};

export default NavigationItem;
</file>

<file path="frontend/src/config/environment.ts">
export const config = {
  apiBaseUrl: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8080',
  wsBaseUrl: import.meta.env.VITE_WS_BASE_URL || 'http://localhost:8080',
  isDevelopment: import.meta.env.DEV,
  isProduction: import.meta.env.PROD,
};

export const endpoints = {
  // Auth endpoints
  auth: {
    signup: '/api/auth/signup',
    signin: '/api/auth/signin',
  },
  // User endpoints
  users: {
    getAll: '/api/users',
    getById: (id: string | number) => `/api/users/${id}`,
    update: (id: string | number) => `/api/users/${id}`,
    delete: (id: string | number) => `/api/users/${id}`,
    uploadAvatar: (id: string | number) => `/api/users/${id}/avatar`,
  },
  // Team endpoints
  teams: {
    getAll: '/api/teams',
    create: '/api/teams',
    getById: (id: string | number) => `/api/teams/${id}`,
    update: (id: string | number) => `/api/teams/${id}`,
    delete: (id: string | number) => `/api/teams/${id}`,
    addMember: (teamId: string | number, userId: string | number) => `/api/teams/${teamId}/members/${userId}`,
    removeMember: (teamId: string | number, userId: string | number) => `/api/teams/${teamId}/members/${userId}`,
  },
  // Project endpoints
  projects: {
    getAll: '/api/projects',
    create: '/api/projects',
    getById: (id: string | number) => `/api/projects/${id}`,
    update: (id: string | number) => `/api/projects/${id}`,
    delete: (id: string | number) => `/api/projects/${id}`,
    addMember: (projectId: string | number, userId: string | number) => `/api/projects/${projectId}/members/${userId}`,
    removeMember: (projectId: string | number, userId: string | number) => `/api/projects/${projectId}/members/${userId}`,
  },
  // Chat endpoints
  chat: {
    getRooms: '/api/chat/rooms',
    createRoom: '/api/chat/rooms',
    getMessages: (roomId: string | number) => `/api/chat/rooms/${roomId}/messages`,
    sendMessage: '/api/chat/messages',
  },
  // WebSocket endpoints
  websocket: {
    connect: '/ws',
    sendMessage: '/app/chat.sendMessage',
    subscribe: (roomId: string | number) => `/topic/chat/${roomId}`,
  },
} as const;
</file>

<file path="frontend/src/index.css">
/* Import fonts first */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

/* Tailwind layers */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Reset */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Body font */
body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
}
::-webkit-scrollbar-track {
  background: #f1f1f1;
}
::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

/* Animations */
.fade-in {
  animation: fadeIn 0.5s ease-in;
}
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to   { opacity: 1; transform: translateY(0); }
}

.slide-in {
  animation: slideIn 0.3s ease-out;
}
@keyframes slideIn {
  from { transform: translateX(-100%); }
  to   { transform: translateX(0); }
}
</file>

<file path="frontend/src/pages/Auth/ForgotPassword.tsx">
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Typography,
  Alert,
  useTheme,
} from '@mui/material';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { forgotPassword } from '../../services/authService';
import toast from 'react-hot-toast';

const schema = yup.object().shape({
  email: yup.string().email('Invalid email address').required('Email is required'),
});

const ForgotPassword = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const theme = useTheme();
  const navigate = useNavigate();

  const { control, handleSubmit, formState: { errors } } = useForm<{ email: string }>({
    resolver: yupResolver(schema),
  });

  const onSubmit = async (data: { email: string }) => {
    setIsLoading(true);
    setError(null);
    try {
      await forgotPassword(data);
      toast.success('If an account exists, a reset code has been sent to your email.');
      navigate('/reset-password', { state: { email: data.email } });
    } catch (err: any) {
      setError(err.message || 'An unexpected error occurred.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: theme.palette.mode === 'light'
          ? 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
          : 'linear-gradient(135deg, #2D3748 0%, #4A5568 100%)',
      }}
    >
      <Card sx={{ maxWidth: 400, width: '100%', mx: 2, p: 2 }}>
        <CardContent>
          <Typography variant="h5" component="h1" sx={{ fontWeight: 700, textAlign: 'center', mb: 2 }}>
            Forgot Password
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', mb: 3 }}>
            Enter your email and we'll send you a code to reset your password.
          </Typography>

          {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}

          <Box component="form" onSubmit={handleSubmit(onSubmit)}>
            <Controller
              name="email"
              control={control}
              render={({ field }) => (
                <TextField
                  {...field}
                  fullWidth
                  label="Email Address"
                  type="email"
                  error={!!errors.email}
                  helperText={errors.email?.message}
                  sx={{ mb: 2 }}
                />
              )}
            />
            <Button type="submit" fullWidth variant="contained" size="large" disabled={isLoading}>
              {isLoading ? 'Sending...' : 'Send Reset Code'}
            </Button>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
};

export default ForgotPassword;
</file>

<file path="frontend/src/pages/Auth/ResetPassword.tsx">
import React, { useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Typography,
  Alert,
  useTheme,
} from '@mui/material';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { resetPassword } from '../../services/authService';
import toast from 'react-hot-toast';

const schema = yup.object().shape({
  code: yup.string().length(6, 'Code must be 6 characters').required('Verification code is required'),
  newPassword: yup.string().min(6, 'Password must be at least 6 characters').required('New password is required'),
  confirmPassword: yup.string().oneOf([yup.ref('newPassword')], 'Passwords must match').required('Please confirm your password'),
});

const ResetPassword = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const theme = useTheme();
  const navigate = useNavigate();
  const location = useLocation();
  const email = location.state?.email;

  const { control, handleSubmit, formState: { errors } } = useForm({
    resolver: yupResolver(schema),
    defaultValues: { code: '', newPassword: '', confirmPassword: '' }
  });

  const onSubmit = async (data: any) => {
    if (!email) {
      setError("Email not found. Please start the process again.");
      return;
    }
    setIsLoading(true);
    setError(null);
    try {
      await resetPassword({ email, code: data.code, newPassword: data.newPassword });
      toast.success('Password has been reset successfully. Please log in.');
      navigate('/login');
    } catch (err: any) {
      setError(err.message || 'Failed to reset password.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: theme.palette.mode === 'light'
          ? 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
          : 'linear-gradient(135deg, #2D3748 0%, #4A5568 100%)',
      }}
    >
      <Card sx={{ maxWidth: 400, width: '100%', mx: 2, p: 2 }}>
        <CardContent>
          <Typography variant="h5" component="h1" sx={{ fontWeight: 700, textAlign: 'center', mb: 2 }}>
            Reset Your Password
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', mb: 3 }}>
            Enter the code sent to your email and your new password.
          </Typography>

          {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
          {!email && <Alert severity="warning" sx={{ mb: 2 }}>No email provided. Please start from the 'Forgot Password' page.</Alert>}

          <Box component="form" onSubmit={handleSubmit(onSubmit)}>
            <Controller name="code" control={control} render={({ field }) => (
                <TextField {...field} fullWidth label="Reset Code" error={!!errors.code} helperText={errors.code?.message} sx={{ mb: 2 }} />
            )}/>
            <Controller name="newPassword" control={control} render={({ field }) => (
                <TextField {...field} fullWidth type="password" label="New Password" error={!!errors.newPassword} helperText={errors.newPassword?.message} sx={{ mb: 2 }} />
            )}/>
            <Controller name="confirmPassword" control={control} render={({ field }) => (
                <TextField {...field} fullWidth type="password" label="Confirm New Password" error={!!errors.confirmPassword} helperText={errors.confirmPassword?.message} sx={{ mb: 2 }} />
            )}/>
            
            <Button type="submit" fullWidth variant="contained" size="large" disabled={isLoading || !email}>
              {isLoading ? 'Resetting...' : 'Reset Password'}
            </Button>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
};

export default ResetPassword;
</file>

<file path="frontend/src/pages/Auth/VerifyEmail.tsx">
import React, { useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Typography,
  Alert,
  useTheme,
} from '@mui/material';
import { useAppDispatch } from '../../store/store';
import { verifyEmail, resendVerificationEmail } from '../../services/authService';
import { showSuccessNotification, showErrorNotification } from '../../store/slices/uiSlice';
import toast from 'react-hot-toast';

const VerifyEmail: React.FC = () => {
  const [code, setCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [resendLoading, setResendLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const theme = useTheme();
  const navigate = useNavigate();
  const dispatch = useAppDispatch();
  const location = useLocation();
  const email = location.state?.email;

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    if (code.length !== 6) {
      setError('Verification code must be 6 characters long.');
      return;
    }
    setIsLoading(true);
    setError(null);
    try {
      await verifyEmail({ code });
      dispatch(showSuccessNotification('Success!', 'Your email has been verified. Please log in.'));
      navigate('/login');
    } catch (err: any) {
      setError(err.message || 'Verification failed. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleResendCode = async () => {
    if (!email) {
        toast.error("Could not find an email to resend the code to. Please try registering again.");
        return;
    }
    setResendLoading(true);
    try {
        await resendVerificationEmail({ email });
        toast.success("A new verification code has been sent to your email.");
    } catch (err: any) {
        toast.error(err.message || "Failed to resend verification code.");
    } finally {
        setResendLoading(false);
    }
  };

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: theme.palette.mode === 'light'
          ? 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
          : 'linear-gradient(135deg, #2D3748 0%, #4A5568 100%)',
      }}
    >
      <Card sx={{ maxWidth: 400, width: '100%', mx: 2, p: 2 }}>
        <CardContent>
          <Typography variant="h5" component="h1" sx={{ fontWeight: 700, textAlign: 'center', mb: 2 }}>
            Verify Your Email
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', mb: 3 }}>
            A 6-character verification code has been sent to your email address.
          </Typography>

          {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}

          <Box component="form" onSubmit={handleSubmit}>
            <TextField
              fullWidth
              label="Verification Code"
              value={code}
              onChange={(e) => setCode(e.target.value.toUpperCase())}
              inputProps={{ maxLength: 6, style: { textAlign: 'center', letterSpacing: '0.5rem' } }}
              sx={{ mb: 2 }}
            />
            <Button type="submit" fullWidth variant="contained" size="large" disabled={isLoading}>
              {isLoading ? 'Verifying...' : 'Verify Account'}
            </Button>
            <Button fullWidth onClick={handleResendCode} disabled={resendLoading} sx={{ mt: 1 }}>
                {resendLoading ? 'Sending...' : 'Resend Code'}
            </Button>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
};

export default VerifyEmail;
</file>

<file path="frontend/src/services/chatService.ts">
import apiClient from './apiClient';
import { endpoints, config } from '../config/environment';
import { ChatRoom, ChatMessage, ChatRoomRequest, ChatMessageRequest, PaginationParams, PaginatedResponse } from '../types';

// WebSocket and STOMP for real-time messaging
let stompClient: any = null;
let socket: any = null;

// Chat API operations
export const getChatRooms = async (params?: PaginationParams): Promise<PaginatedResponse<ChatRoom>> => {
  const queryParams = new URLSearchParams();
  if (params?.page) queryParams.append('page', params.page.toString());
  if (params?.size) queryParams.append('size', params.size.toString());

  const url = `${endpoints.chat.getRooms}?${queryParams.toString()}`;
  const response = await apiClient.get<PaginatedResponse<ChatRoom>>(url);
  return response;
};

export const getChatRoomById = async (roomId: number): Promise<ChatRoom> => {
  const response = await apiClient.get<ChatRoom>(`/api/chat/rooms/${roomId}`);
  return response;
};

export const createChatRoom = async (roomData: ChatRoomRequest): Promise<ChatRoom> => {
  const response = await apiClient.post<ChatRoom>(endpoints.chat.createRoom, roomData);
  return response;
};

export const getMessages = async (roomId: number, params?: PaginationParams): Promise<PaginatedResponse<ChatMessage>> => {
  const queryParams = new URLSearchParams();
  if (params?.page) queryParams.append('page', params.page.toString());
  if (params?.size) queryParams.append('size', params.size.toString());

  const url = `${endpoints.chat.getMessages(roomId)}?${queryParams.toString()}`;
  const response = await apiClient.get<PaginatedResponse<ChatMessage>>(url);
  return response;
};

export const sendMessage = async (messageData: ChatMessageRequest): Promise<ChatMessage> => {
  const response = await apiClient.post<ChatMessage>(endpoints.chat.sendMessage, messageData);
  return response;
};

export const deleteMessage = async (messageId: number): Promise<void> => {
  await apiClient.delete(`/api/chat/messages/${messageId}`);
};

export const editMessage = async (messageId: number, content: string): Promise<ChatMessage> => {
  const response = await apiClient.put<ChatMessage>(`/api/chat/messages/${messageId}`, { content });
  return response;
};

export const markMessageAsRead = async (messageId: number): Promise<void> => {
  await apiClient.patch(`/api/chat/messages/${messageId}/read`);
};

export const getUserChatRooms = async (): Promise<ChatRoom[]> => {
  const response = await apiClient.get<ChatRoom[]>('/api/chat/rooms/my');
  return response;
};

export const addRoomMember = async (roomId: number, userId: number): Promise<void> => {
  await apiClient.post(`/api/chat/rooms/${roomId}/members/${userId}`);
};

export const removeRoomMember = async (roomId: number, userId: number): Promise<void> => {
  await apiClient.delete(`/api/chat/rooms/${roomId}/members/${userId}`);
};

export const leaveRoom = async (roomId: number): Promise<void> => {
  await apiClient.post(`/api/chat/rooms/${roomId}/leave`);
};

// WebSocket operations
export const connectToChat = (onMessageReceived: (message: any) => void): Promise<void> => {
  return new Promise((resolve, reject) => {
    try {
      // For now, we'll use a simple WebSocket implementation
      // In production, you'd want to use SockJS and STOMP
      const token = localStorage.getItem('token');
      if (!token) {
        reject(new Error('No authentication token found'));
        return;
      }

      const wsUrl = `${config.wsBaseUrl.replace('http', 'ws')}/ws?token=${token}`;
      socket = new WebSocket(wsUrl);

      socket.onopen = () => {
        console.log('WebSocket connected');
        resolve();
      };

      socket.onmessage = (event: MessageEvent) => {
        try {
          const data = JSON.parse(event.data);
          onMessageReceived(data);
        } catch (error) {
          console.error('Error parsing message:', error);
        }
      };

      socket.onclose = () => {
        console.log('WebSocket disconnected');
      };

      socket.onerror = (error: Event) => {
        console.error('WebSocket error:', error);
        reject(error);
      };
    } catch (error) {
      reject(error);
    }
  });
};

export const disconnectFromChat = (): void => {
  if (socket) {
    socket.close();
    socket = null;
  }
  if (stompClient) {
    stompClient.disconnect();
    stompClient = null;
  }
};

export const subscribeToRoom = (roomId: number, callback: (message: ChatMessage) => void): void => {
  if (socket && socket.readyState === WebSocket.OPEN) {
    // Send subscription message
    socket.send(JSON.stringify({
      action: 'subscribe',
      roomId: roomId
    }));
  }
};

export const unsubscribeFromRoom = (roomId: number): void => {
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({
      action: 'unsubscribe',
      roomId: roomId
    }));
  }
};

export const sendMessageViaWebSocket = (roomId: number, content: string, messageType: 'TEXT' | 'IMAGE' | 'FILE' = 'TEXT'): void => {
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({
      action: 'sendMessage',
      roomId: roomId,
      content: content,
      messageType: messageType
    }));
  }
};

export const uploadChatFile = async (roomId: number, file: File, onProgress?: (progress: number) => void): Promise<ChatMessage> => {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('roomId', roomId.toString());
  formData.append('messageType', 'FILE');

  const response = await apiClient.upload('/api/chat/upload', formData, onProgress);
  return response;
};

export const searchMessages = async (query: string, roomId?: number): Promise<ChatMessage[]> => {
  const params = new URLSearchParams();
  params.append('q', query);
  if (roomId) params.append('roomId', roomId.toString());

  const response = await apiClient.get<ChatMessage[]>(`/api/chat/messages/search?${params.toString()}`);
  return response;
};
</file>

<file path="frontend/src/services/dashboardService.ts">
import apiClient from './apiClient';
import { DashboardStats, Activity } from '../types';

export const getDashboardStats = async (): Promise<DashboardStats> => {
  const response = await apiClient.get<DashboardStats>('/api/dashboard/stats');
  return response;
};

export const getAdminDashboardStats = async (): Promise<DashboardStats & {
  systemHealth: {
    uptime: number;
    memoryUsage: number;
    cpuUsage: number;
    diskUsage: number;
  };
  recentActivities: Activity[];
  topPerformers: {
    userId: number;
    name: string;
    score: number;
  }[];
}> => {
  const response = await apiClient.get('/api/dashboard/admin/stats');
  return response;
};

export const getUserDashboardStats = async (): Promise<{
  myProjects: number;
  myTasks: number;
  completedTasks: number;
  myTeams: number;
  unreadMessages: number;
  upcomingDeadlines: {
    projectId: number;
    projectName: string;
    deadline: string;
  }[];
  recentActivities: Activity[];
}> => {
  const response = await apiClient.get('/api/dashboard/user/stats');
  return response;
};

export const getRecentActivities = async (limit: number = 10): Promise<Activity[]> => {
  const response = await apiClient.get<Activity[]>(`/api/dashboard/activities?limit=${limit}`);
  return response;
};

export const getSystemHealth = async (): Promise<{
  status: 'healthy' | 'warning' | 'critical';
  uptime: number;
  memoryUsage: number;
  cpuUsage: number;
  diskUsage: number;
  activeUsers: number;
  requestsPerMinute: number;
}> => {
  const response = await apiClient.get('/api/dashboard/system/health');
  return response;
};

export const getAnalytics = async (timeRange: '7d' | '30d' | '90d' | '1y' = '30d'): Promise<{
  userGrowth: { date: string; count: number }[];
  projectProgress: { date: string; completed: number; created: number }[];
  teamActivity: { date: string; messages: number; tasks: number }[];
  systemUsage: { date: string; activeUsers: number; requests: number }[];
}> => {
  const response = await apiClient.get(`/api/dashboard/analytics?range=${timeRange}`);
  return response;
};

export const getUserPerformance = async (userId?: number): Promise<{
  tasksCompleted: number;
  averageCompletionTime: number;
  projectsContributed: number;
  messagesPosted: number;
  performanceScore: number;
  productivityTrend: { date: string; score: number }[];
}> => {
  const url = userId ? `/api/dashboard/performance/${userId}` : '/api/dashboard/performance/me';
  const response = await apiClient.get(url);
  return response;
};

export const getTeamPerformance = async (teamId: number): Promise<{
  teamId: number;
  teamName: string;
  totalMembers: number;
  activeMembers: number;
  projectsCompleted: number;
  averageProjectDuration: number;
  teamProductivity: number;
  memberPerformance: {
    userId: number;
    name: string;
    productivity: number;
    tasksCompleted: number;
  }[];
}> => {
  const response = await apiClient.get(`/api/dashboard/team/${teamId}/performance`);
  return response;
};

export const exportDashboardData = async (type: 'stats' | 'activities' | 'analytics', format: 'csv' | 'xlsx'): Promise<Blob> => {
  const response = await apiClient.get(`/api/dashboard/export/${type}?format=${format}`, {
    responseType: 'blob',
  });
  return response;
};

export const getNotifications = async (limit: number = 5): Promise<{
  id: number;
  type: 'info' | 'warning' | 'error' | 'success';
  title: string;
  message: string;
  read: boolean;
  createdAt: string;
}[]> => {
  const response = await apiClient.get(`/api/dashboard/notifications?limit=${limit}`);
  return response;
};

export const markNotificationAsRead = async (notificationId: number): Promise<void> => {
  await apiClient.patch(`/api/dashboard/notifications/${notificationId}/read`);
};

export const getUpcomingEvents = async (limit: number = 5): Promise<{
  id: number;
  title: string;
  type: 'meeting' | 'deadline' | 'milestone';
  date: string;
  projectId?: number;
  projectName?: string;
}[]> => {
  const response = await apiClient.get(`/api/dashboard/events/upcoming?limit=${limit}`);
  return response;
};
</file>

<file path="frontend/src/services/userService.ts">
import apiClient from './apiClient';
import { endpoints } from '../config/environment';
import { User, PaginationParams, PaginatedResponse } from '../types';

export const getAllUsers = async (params?: PaginationParams): Promise<PaginatedResponse<User>> => {
  const queryParams = new URLSearchParams();
  if (params?.page) queryParams.append('page', params.page.toString());
  if (params?.size) queryParams.append('size', params.size.toString());
  if (params?.sort) queryParams.append('sort', params.sort);
  if (params?.direction) queryParams.append('direction', params.direction);

  const url = `${endpoints.users.getAll}?${queryParams.toString()}`;
  const response = await apiClient.get<PaginatedResponse<User>>(url);
  return response;
};

export const getUserById = async (id: number): Promise<User> => {
  const response = await apiClient.get<User>(endpoints.users.getById(id));
  return response;
};

export const updateUser = async (id: number, userData: Partial<User>): Promise<User> => {
  const response = await apiClient.put<User>(endpoints.users.update(id), userData);
  return response;
};

export const deleteUser = async (id: number): Promise<void> => {
  await apiClient.delete(endpoints.users.delete(id));
};

export const uploadUserAvatar = async (id: number, file: File, onProgress?: (progress: number) => void): Promise<string> => {
  const formData = new FormData();
  formData.append('avatar', file);
  
  const response = await apiClient.upload(endpoints.users.uploadAvatar(id), formData, onProgress);
  return response.avatarUrl || response.url;
};

export const searchUsers = async (query: string, params?: PaginationParams): Promise<PaginatedResponse<User>> => {
  const queryParams = new URLSearchParams();
  queryParams.append('q', query);
  if (params?.page) queryParams.append('page', params.page.toString());
  if (params?.size) queryParams.append('size', params.size.toString());

  const url = `${endpoints.users.getAll}/search?${queryParams.toString()}`;
  const response = await apiClient.get<PaginatedResponse<User>>(url);
  return response;
};

export const getUserStats = async (): Promise<{
  totalUsers: number;
  activeUsers: number;
  newUsersThisMonth: number;
  usersByRole: { role: string; count: number }[];
}> => {
  const response = await apiClient.get('/api/users/stats');
  return response;
};

export const bulkUpdateUsers = async (userIds: number[], updates: Partial<User>): Promise<void> => {
  await apiClient.put('/api/users/bulk', { userIds, updates });
};

export const exportUsers = async (format: 'csv' | 'xlsx'): Promise<Blob> => {
  const response = await apiClient.get(`/api/users/export?format=${format}`, {
    responseType: 'blob',
  });
  return response;
};
</file>

<file path="frontend/src/store/slices/themeSlice.ts">
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { ThemeMode } from '../../types';

interface ThemeState {
  mode: ThemeMode;
  systemPrefersDark: boolean;
}

// Get initial theme from localStorage or system preference
const getInitialTheme = (): ThemeMode => {
  const saved = localStorage.getItem('themeMode') as ThemeMode;
  if (saved && ['light', 'dark', 'system'].includes(saved)) {
    return saved;
  }
  return 'system';
};

const initialState: ThemeState = {
  mode: getInitialTheme(),
  systemPrefersDark: window.matchMedia('(prefers-color-scheme: dark)').matches,
};

const themeSlice = createSlice({
  name: 'theme',
  initialState,
  reducers: {
    setThemeMode: (state, action: PayloadAction<ThemeMode>) => {
      state.mode = action.payload;
      localStorage.setItem('themeMode', action.payload);
    },
    setSystemPrefersDark: (state, action: PayloadAction<boolean>) => {
      state.systemPrefersDark = action.payload;
    },
    toggleTheme: (state) => {
      if (state.mode === 'light') {
        state.mode = 'dark';
      } else if (state.mode === 'dark') {
        state.mode = 'light';
      } else {
        // If system, toggle to opposite of current system preference
        state.mode = state.systemPrefersDark ? 'light' : 'dark';
      }
      localStorage.setItem('themeMode', state.mode);
    },
  },
});

export const { setThemeMode, setSystemPrefersDark, toggleTheme } = themeSlice.actions;

// Selectors
export const selectTheme = (state: { theme: ThemeState }) => state.theme;
export const selectThemeMode = (state: { theme: ThemeState }) => state.theme.mode;
export const selectEffectiveTheme = (state: { theme: ThemeState }) => {
  if (state.theme.mode === 'system') {
    return state.theme.systemPrefersDark ? 'dark' : 'light';
  }
  return state.theme.mode;
};

export default themeSlice.reducer;
</file>

<file path="frontend/src/store/slices/uiSlice.ts">
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { LoadingState, ErrorState, Notification } from '../../types';

interface UiState {
  loading: LoadingState;
  errors: ErrorState;
  notifications: Notification[];
  sidebarOpen: boolean;
  mobileSidebarOpen: boolean;
  pageTitle: string;
  breadcrumbs: BreadcrumbItem[];
}

interface BreadcrumbItem {
  label: string;
  path?: string;
  icon?: string;
}

const initialState: UiState = {
  loading: {},
  errors: {},
  notifications: [],
  sidebarOpen: true,
  mobileSidebarOpen: false,
  pageTitle: 'Collabris',
  breadcrumbs: [],
};

const uiSlice = createSlice({
  name: 'ui',
  initialState,
  reducers: {
    setLoading: (state, action: PayloadAction<{ key: string; value: boolean }>) => {
      state.loading[action.payload.key] = action.payload.value;
    },
    clearLoading: (state, action: PayloadAction<string>) => {
      delete state.loading[action.payload];
    },
    setError: (state, action: PayloadAction<{ key: string; value: string | null }>) => {
      state.errors[action.payload.key] = action.payload.value;
    },
    clearError: (state, action: PayloadAction<string>) => {
      delete state.errors[action.payload];
    },
    clearAllErrors: (state) => {
      state.errors = {};
    },
    addNotification: (state, action: PayloadAction<Omit<Notification, 'id'>>) => {
      const notification: Notification = {
        ...action.payload,
        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
      };
      state.notifications.push(notification);
    },
    removeNotification: (state, action: PayloadAction<string>) => {
      state.notifications = state.notifications.filter(n => n.id !== action.payload);
    },
    clearAllNotifications: (state) => {
      state.notifications = [];
    },
    toggleSidebar: (state) => {
      state.sidebarOpen = !state.sidebarOpen;
    },
    setSidebarOpen: (state, action: PayloadAction<boolean>) => {
      state.sidebarOpen = action.payload;
    },
    toggleMobileSidebar: (state) => {
      state.mobileSidebarOpen = !state.mobileSidebarOpen;
    },
    setMobileSidebarOpen: (state, action: PayloadAction<boolean>) => {
      state.mobileSidebarOpen = action.payload;
    },
    setPageTitle: (state, action: PayloadAction<string>) => {
      state.pageTitle = action.payload;
    },
    setBreadcrumbs: (state, action: PayloadAction<BreadcrumbItem[]>) => {
      state.breadcrumbs = action.payload;
    },
  },
});

export const {
  setLoading,
  clearLoading,
  setError,
  clearError,
  clearAllErrors,
  addNotification,
  removeNotification,
  clearAllNotifications,
  toggleSidebar,
  setSidebarOpen,
  toggleMobileSidebar,
  setMobileSidebarOpen,
  setPageTitle,
  setBreadcrumbs,
} = uiSlice.actions;

// Selectors
export const selectUi = (state: { ui: UiState }) => state.ui;
export const selectLoading = (key: string) => (state: { ui: UiState }) => state.ui.loading[key] || false;
export const selectError = (key: string) => (state: { ui: UiState }) => state.ui.errors[key] || null;
export const selectNotifications = (state: { ui: UiState }) => state.ui.notifications;
export const selectSidebarOpen = (state: { ui: UiState }) => state.ui.sidebarOpen;
export const selectMobileSidebarOpen = (state: { ui: UiState }) => state.ui.mobileSidebarOpen;
export const selectPageTitle = (state: { ui: UiState }) => state.ui.pageTitle;
export const selectBreadcrumbs = (state: { ui: UiState }) => state.ui.breadcrumbs;

// Helper action creators
export const showNotification = (notification: Omit<Notification, 'id'>) => addNotification(notification);
export const showSuccessNotification = (title: string, message: string) => 
  addNotification({ type: 'success', title, message });
export const showErrorNotification = (title: string, message: string) => 
  addNotification({ type: 'error', title, message });
export const showWarningNotification = (title: string, message: string) => 
  addNotification({ type: 'warning', title, message });
export const showInfoNotification = (title: string, message: string) => 
  addNotification({ type: 'info', title, message });

export type { BreadcrumbItem };
export default uiSlice.reducer;
</file>

<file path="frontend/src/store/slices/userSlice.ts">
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { User, PaginatedResponse } from '../../types';
import * as userService from '../../services/userService';
import { RootState } from '../store';

interface UserState {
  users: User[];
  selectedUser: User | null;
  isLoading: boolean;
  error: string | null;
}

const initialState: UserState = {
  users: [],
  selectedUser: null,
  isLoading: false,
  error: null,
};

// Async thunks
export const fetchUsers = createAsyncThunk<User[], void, { rejectValue: string }>(
  'users/fetchAll',
  async (_, { rejectWithValue }) => {
    try {
      // The service returns a PaginatedResponse, so we extract the content
      const response: PaginatedResponse<User> = await userService.getAllUsers();
      return response.content;
    } catch (error: any) {
      return rejectWithValue(error.message || 'Failed to fetch users');
    }
  }
);

export const updateUserProfile = createAsyncThunk<User, { id: number; userData: Partial<User> }, { rejectValue: string }>(
  'users/updateProfile',
  async ({ id, userData }, { rejectWithValue }) => {
    try {
      const updatedUser = await userService.updateUser(id, userData);
      return updatedUser;
    } catch (error: any) {
      return rejectWithValue(error.message || 'Failed to update user profile');
    }
  }
);

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    // Fetch all users
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action: PayloadAction<User[]>) => {
        state.isLoading = false;
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });

    // Update user profile
    builder
      .addCase(updateUserProfile.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(updateUserProfile.fulfilled, (state, action: PayloadAction<User>) => {
        state.isLoading = false;
        const index = state.users.findIndex(u => u.id === action.payload.id);
        if (index !== -1) {
          state.users[index] = action.payload;
        }
        if (state.selectedUser && state.selectedUser.id === action.payload.id) {
            state.selectedUser = action.payload;
        }
      })
      .addCase(updateUserProfile.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
  },
});

export const { clearError } = userSlice.actions;

// Selectors
export const selectAllUsers = (state: RootState) => state.user.users;
export const selectUserLoading = (state: RootState) => state.user.isLoading;
export const selectUserError = (state: RootState) => state.user.error;

export default userSlice.reducer;
</file>

<file path="frontend/src/theme/customStyles.css">
/* Google Fonts Import */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

/* Custom animations */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideInLeft {
  from {
    opacity: 0;
    transform: translateX(-30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
}

@keyframes shimmer {
  0% {
    background-position: -200px 0;
  }
  100% {
    background-position: calc(200px + 100%) 0;
  }
}

/* Utility classes */
.animate-fade-in {
  animation: fadeIn 0.6s ease-out;
}

.animate-slide-right {
  animation: slideInRight 0.5s ease-out;
}

.animate-slide-left {
  animation: slideInLeft 0.5s ease-out;
}

.animate-pulse {
  animation: pulse 2s infinite;
}

/* Loading skeleton */
.skeleton {
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200px 100%;
  animation: shimmer 1.5s infinite;
}

.skeleton-dark {
  background: linear-gradient(90deg, #2d3748 25%, #4a5568 50%, #2d3748 75%);
  background-size: 200px 100%;
  animation: shimmer 1.5s infinite;
}

/* Custom scrollbar */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.1);
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.2);
}

/* Gradient backgrounds */
.gradient-bg-primary {
  background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
}

.gradient-bg-secondary {
  background: linear-gradient(135deg, #7c3aed 0%, #ec4899 100%);
}

.gradient-bg-success {
  background: linear-gradient(135deg, #059669 0%, #22c55e 100%);
}

.gradient-text-primary {
  background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* Glass morphism effect */
.glass-effect {
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.glass-effect-dark {
  background: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

/* Hover effects */
.hover-lift {
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.hover-lift:hover {
  transform: translateY(-2px);
  box-shadow: 0px 10px 15px -3px rgba(0, 0, 0, 0.1), 0px 4px 6px -2px rgba(0, 0, 0, 0.05);
}

.hover-scale {
  transition: transform 0.2s ease-in-out;
}

.hover-scale:hover {
  transform: scale(1.02);
}

/* Image overlay effects */
.image-overlay {
  position: relative;
  overflow: hidden;
}

.image-overlay::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(135deg, rgba(37, 99, 235, 0.8) 0%, rgba(124, 58, 237, 0.8) 100%);
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}

.image-overlay:hover::after {
  opacity: 1;
}

/* Custom button styles */
.btn-gradient {
  background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
  border: none;
  color: white;
  transition: all 0.3s ease;
}

.btn-gradient:hover {
  background: linear-gradient(135deg, #1d4ed8 0%, #6d28d9 100%);
  transform: translateY(-1px);
  box-shadow: 0px 8px 15px rgba(37, 99, 235, 0.3);
}

/* Chat bubble animations */
.chat-message {
  animation: fadeIn 0.3s ease-out;
}

.chat-message.own {
  animation: slideInRight 0.3s ease-out;
}

.chat-message.other {
  animation: slideInLeft 0.3s ease-out;
}

/* Notification animations */
.notification-enter {
  opacity: 0;
  transform: translateY(-50px) scale(0.8);
}

.notification-enter-active {
  opacity: 1;
  transform: translateY(0) scale(1);
  transition: all 0.3s ease-out;
}

.notification-exit {
  opacity: 1;
  transform: translateY(0) scale(1);
}

.notification-exit-active {
  opacity: 0;
  transform: translateY(-50px) scale(0.8);
  transition: all 0.3s ease-in;
}

/* Page transition styles */
.page-transition-enter {
  opacity: 0;
  transform: translateY(20px);
}

.page-transition-enter-active {
  opacity: 1;
  transform: translateY(0);
  transition: all 0.4s ease-out;
}

.page-transition-exit {
  opacity: 1;
  transform: translateY(0);
}

.page-transition-exit-active {
  opacity: 0;
  transform: translateY(-20px);
  transition: all 0.3s ease-in;
}

/* Responsive utilities */
@media (max-width: 640px) {
  .mobile-hidden {
    display: none !important;
  }
}

@media (min-width: 641px) {
  .mobile-only {
    display: none !important;
  }
}

/* Print styles */
@media print {
  .no-print {
    display: none !important;
  }
}
</file>

<file path="frontend/src/theme/theme.ts">
import { createTheme, ThemeOptions } from '@mui/material/styles';
import { PaletteMode } from '@mui/material';

// Collabris color palette
const collabrisColors = {
  primary: {
    main: '#2563eb', // Blue
    light: '#3b82f6',
    dark: '#1d4ed8',
    contrastText: '#ffffff',
  },
  secondary: {
    main: '#7c3aed', // Purple
    light: '#8b5cf6',
    dark: '#6d28d9',
    contrastText: '#ffffff',
  },
  accent: {
    main: '#059669', // Green
    light: '#10b981',
    dark: '#047857',
  },
  warning: {
    main: '#f59e0b',
    light: '#fbbf24',
    dark: '#d97706',
  },
  error: {
    main: '#ef4444',
    light: '#f87171',
    dark: '#dc2626',
  },
  success: {
    main: '#22c55e',
    light: '#4ade80',
    dark: '#16a34a',
  },
};

const getDesignTokens = (mode: PaletteMode): ThemeOptions => ({
  palette: {
    mode,
    primary: collabrisColors.primary,
    secondary: collabrisColors.secondary,
    error: collabrisColors.error,
    warning: collabrisColors.warning,
    success: collabrisColors.success,
    ...(mode === 'light'
      ? {
          // Light mode
          background: {
            default: '#f8fafc',
            paper: '#ffffff',
          },
          text: {
            primary: '#1e293b',
            secondary: '#64748b',
          },
          divider: '#e2e8f0',
        }
      : {
          // Dark mode
          background: {
            default: '#0f172a',
            paper: '#1e293b',
          },
          text: {
            primary: '#f1f5f9',
            secondary: '#94a3b8',
          },
          divider: '#334155',
        }),
  },
  typography: {
    fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontWeight: 700,
      fontSize: '2.5rem',
      lineHeight: 1.2,
    },
    h2: {
      fontWeight: 600,
      fontSize: '2rem',
      lineHeight: 1.3,
    },
    h3: {
      fontWeight: 600,
      fontSize: '1.5rem',
      lineHeight: 1.4,
    },
    h4: {
      fontWeight: 600,
      fontSize: '1.25rem',
      lineHeight: 1.4,
    },
    h5: {
      fontWeight: 600,
      fontSize: '1.125rem',
      lineHeight: 1.5,
    },
    h6: {
      fontWeight: 600,
      fontSize: '1rem',
      lineHeight: 1.5,
    },
    body1: {
      fontSize: '1rem',
      lineHeight: 1.6,
    },
    body2: {
      fontSize: '0.875rem',
      lineHeight: 1.5,
    },
    button: {
      textTransform: 'none',
      fontWeight: 500,
    },
  },
  shape: {
    borderRadius: 12,
  },
  shadows: [
    'none',
    '0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.06)',
    '0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -1px rgba(0, 0, 0, 0.06)',
    '0px 10px 15px -3px rgba(0, 0, 0, 0.1), 0px 4px 6px -2px rgba(0, 0, 0, 0.05)',
    '0px 20px 25px -5px rgba(0, 0, 0, 0.1), 0px 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '0px 25px 50px -12px rgba(0, 0, 0, 0.25)',
    '0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.06)',
    '0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -1px rgba(0, 0, 0, 0.06)',
    '0px 10px 15px -3px rgba(0, 0, 0, 0.1), 0px 4px 6px -2px rgba(0, 0, 0, 0.05)',
    '0px 20px 25px -5px rgba(0, 0, 0, 0.1), 0px 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '0px 25px 50px -12px rgba(0, 0, 0, 0.25)',
    '0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.06)',
    '0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -1px rgba(0, 0, 0, 0.06)',
    '0px 10px 15px -3px rgba(0, 0, 0, 0.1), 0px 4px 6px -2px rgba(0, 0, 0, 0.05)',
    '0px 20px 25px -5px rgba(0, 0, 0, 0.1), 0px 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '0px 25px 50px -12px rgba(0, 0, 0, 0.25)',
    '0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.06)',
    '0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -1px rgba(0, 0, 0, 0.06)',
    '0px 10px 15px -3px rgba(0, 0, 0, 0.1), 0px 4px 6px -2px rgba(0, 0, 0, 0.05)',
    '0px 20px 25px -5px rgba(0, 0, 0, 0.1), 0px 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '0px 25px 50px -12px rgba(0, 0, 0, 0.25)',
    '0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.06)',
    '0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -1px rgba(0, 0, 0, 0.06)',
    '0px 10px 15px -3px rgba(0, 0, 0, 0.1), 0px 4px 6px -2px rgba(0, 0, 0, 0.05)',
    '0px 20px 25px -5px rgba(0, 0, 0, 0.1), 0px 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '0px 25px 50px -12px rgba(0, 0, 0, 0.25)',
  ],
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          textTransform: 'none',
          fontWeight: 500,
          padding: '8px 16px',
          boxShadow: 'none',
          '&:hover': {
            boxShadow: '0px 4px 6px -1px rgba(0, 0, 0, 0.1), 0px 2px 4px -1px rgba(0, 0, 0, 0.06)',
          },
        },
        containedPrimary: {
          background: `linear-gradient(135deg, ${collabrisColors.primary.main} 0%, ${collabrisColors.primary.dark} 100%)`,
          '&:hover': {
            background: `linear-gradient(135deg, ${collabrisColors.primary.dark} 0%, ${collabrisColors.primary.main} 100%)`,
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 16,
          border: mode === 'light' ? '1px solid #e2e8f0' : '1px solid #334155',
        },
      },
    },
    MuiTextField: {
      styleOverrides: {
        root: {
          '& .MuiOutlinedInput-root': {
            borderRadius: 8,
          },
        },
      },
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          borderRight: mode === 'light' ? '1px solid #e2e8f0' : '1px solid #334155',
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: mode === 'light' ? '#ffffff' : '#1e293b',
          color: mode === 'light' ? '#1e293b' : '#f1f5f9',
          boxShadow: '0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px rgba(0, 0, 0, 0.06)',
        },
      },
    },
  },
});

export const createCollabrisTheme = (mode: PaletteMode) => {
  return createTheme(getDesignTokens(mode));
};

export { collabrisColors };
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,jsx,ts,tsx}",   // all your component files
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Complete Spring Boot Backend for Collabris</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "vite-react-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.57.4",
    "lucide-react": "^0.344.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.18",
    "eslint": "^9.9.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.11",
    "globals": "^15.9.0",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.3.0",
    "vite": "^5.4.2"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="README.md">
# Collabris
</file>

<file path="src/App.tsx">
import React from 'react';

function App() {
  return (
    <div className="min-h-screen bg-gray-100 flex items-center justify-center">
      <p>Start prompting (or editing) to see magic happen :)</p>
    </div>
  );
}

export default App;
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="src/main.tsx">
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {},
  },
  plugins: [],
};
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="WARP.md">
# WARP.md

This file provides guidance to WARP (warp.dev) when working with code in this repository.

## Project Overview

Collabris is a full-stack collaboration application built with:
- **Backend**: Spring Boot 3.2.0 with Java 17, PostgreSQL, JWT authentication, WebSocket messaging
- **Frontend**: React 18 with TypeScript, Vite, TailwindCSS, Material-UI, Redux Toolkit

The application features team management, project collaboration, real-time chat, role-based access control, and comprehensive API documentation.

## Development Commands

### Backend (Spring Boot)
```bash
# Navigate to backend directory
cd backend

# Run the application
mvn spring-boot:run

# Run tests
mvn test

# Clean and build
mvn clean package

# Skip tests during build
mvn clean package -DskipTests
```

### Frontend (React + Vite)
```bash
# Navigate to frontend directory
cd frontend

# Install dependencies
npm install

# Run development server
npm run dev

# Build for production
npm run build

# Run linter
npm run lint

# Preview production build
npm run preview
```

### Root-level Frontend Commands
The root directory also contains a simplified React setup:
```bash
# Run development server (root)
npm run dev

# Build (root)
npm run build

# Lint (root)
npm run lint
```

## Architecture Overview

### Backend Structure (`backend/src/main/java/com/collabris/`)
- **`config/`**: Security, WebSocket, Swagger configuration, data initialization
- **`controller/`**: REST API endpoints (Auth, Chat, Project, Team, User)
- **`dto/`**: Data Transfer Objects for requests and responses
- **`entity/`**: JPA entities (User, Team, Project, ChatRoom, ChatMessage, Role)
- **`security/`**: JWT authentication and authorization components
- **`service/`**: Business logic services
- **`repository/`**: Data access layer using Spring Data JPA
- **`exception/`**: Global exception handling

### Frontend Structure (`frontend/src/`)
- **`components/`**: Reusable React components organized by feature
  - `Auth/`: Authentication components and protected routes
  - `Common/`: Shared utility components (LoadingSpinner, StatsCard)
  - `Layout/`: Layout components (Navbar, main Layout)
- **`pages/`**: Route-based page components
  - `Auth/`: Login and registration pages
  - `Dashboard/`: Admin and user dashboard views
  - `Profile/`, `Settings/`: User management pages
- **`services/`**: API integration and service layers
- **`store/`**: Redux Toolkit store with feature slices (auth, theme, user)
- **`theme/`**: Material-UI theme configuration

## Key Configuration Files

### Backend Configuration
- **`application.properties`**: Database, JWT, CORS, file upload, email settings
- **`pom.xml`**: Maven dependencies including Spring Boot starters, PostgreSQL, JWT, Swagger

### Frontend Configuration  
- **`package.json`**: React, TypeScript, Material-UI, Redux Toolkit, React Router dependencies
- **`vite.config.ts`**: Vite configuration with React plugin
- **`tailwind.config.js`**: TailwindCSS styling configuration
- **`tsconfig.json`**: TypeScript compiler configuration

## Database Setup

The application uses PostgreSQL with connection details in `application.properties`. The current setup uses a Neon database instance. For local development:

1. Install PostgreSQL
2. Create database: `collabris_db`
3. Update connection settings in `application.properties`
4. Application will auto-create tables via Hibernate DDL

## API Documentation

When the backend is running, access Swagger documentation at:
- **Swagger UI**: http://localhost:8080/swagger-ui.html
- **API Docs**: http://localhost:8080/v3/api-docs

## Authentication

The application uses JWT-based authentication with role-based access control:
- **ADMIN**: Full system access
- **MANAGER**: Team and project management
- **MEMBER**: Basic user access

Include JWT token in requests: `Authorization: Bearer <token>`

## Real-time Features

WebSocket messaging is implemented using STOMP protocol:
- **Connection endpoint**: `/ws`
- **Send messages**: `/app/chat.sendMessage`
- **Subscribe to room**: `/topic/chat/{roomId}`

## Testing

### Backend Tests
```bash
cd backend
mvn test
```
Includes unit tests, integration tests, and security tests with H2 in-memory database for testing.

### Frontend Testing
Currently no test configuration is set up in the frontend package.json.

## Development Workflow

1. **Backend Development**: Start with entity design, then repository, service, and controller layers
2. **Frontend Development**: Use Redux slices for state management, Material-UI for components
3. **API Integration**: Services in `frontend/src/services/` handle API calls to backend
4. **Authentication Flow**: JWT tokens managed in Redux auth slice with persistent storage

## Port Configuration

- **Backend**: http://localhost:8080
- **Frontend**: http://localhost:5173 (Vite dev server)
- **CORS**: Backend allows origin `http://localhost:5173`

## Key Dependencies

### Backend
- Spring Boot 3.2.0 (Web, Security, Data JPA, WebSocket, Validation)
- PostgreSQL driver
- JWT (jjwt 0.12.3)
- SpringDoc OpenAPI 3.0

### Frontend
- React 18.3.1 with TypeScript
- Material-UI 5.15.1 for components
- Redux Toolkit for state management
- React Router 6.20.1 for routing
- Axios for API calls
- React Hook Form with Yup validation

## File Structure Notes

- Dual frontend setup: Root-level basic React app and `frontend/` directory with full application
- Backend follows standard Spring Boot Maven structure
- Configuration files are environment-specific via Spring profiles
</file>

<file path="backend/src/main/java/com/collabris/config/AdminUserInitializer.java">
package com.collabris.config;

import com.collabris.entity.Role;
import com.collabris.entity.User;
import com.collabris.repository.RoleRepository;
import com.collabris.repository.UserRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.HashSet;
import java.util.Set;
import java.util.Optional;

@Component
@Order(2) // Run after DataInitializer
public class AdminUserInitializer implements CommandLineRunner {

    private static final Logger logger = LoggerFactory.getLogger(AdminUserInitializer.class);

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    // Admin user credentials
    private static final String ADMIN_USERNAME = "Elissa";
    private static final String ADMIN_EMAIL = "sibomanaelissa71@gmail.com";
    private static final String ADMIN_PASSWORD = "Admin@2025";
    private static final String ADMIN_FIRST_NAME = "Elissa";
    private static final String ADMIN_LAST_NAME = "Sibomana";

    @Override
    public void run(String... args) throws Exception {
        try {
            createAdminUser();
        } catch (Exception e) {
            logger.error("Error occurred while creating admin user: {}", e.getMessage(), e);
        }
    }

    private void createAdminUser() {
        if (userRepository.existsByUsername(ADMIN_USERNAME)) {
            logger.info("Admin user with username '{}' already exists. Skipping creation.", ADMIN_USERNAME);
            return;
        }

        Optional<Role> adminRole = roleRepository.findByName(Role.ERole.ADMIN);
        if (adminRole.isEmpty()) {
            logger.warn("Admin role not found. Ensure DataInitializer runs first or create the role.");
            return;
        }

        User adminUser = new User(ADMIN_USERNAME, ADMIN_EMAIL, passwordEncoder.encode(ADMIN_PASSWORD));
        adminUser.setFirstName(ADMIN_FIRST_NAME);
        adminUser.setLastName(ADMIN_LAST_NAME);
        adminUser.setEnabled(true);

        Set<Role> roles = new HashSet<>();
        roles.add(adminRole.get());
        adminUser.setRoles(roles);

        User savedAdmin = userRepository.save(adminUser);
        logger.info("Admin user created with id: {}", savedAdmin.getId());
    }
}
</file>

<file path="backend/src/main/java/com/collabris/controller/TeamController.java">
package com.collabris.controller;

import com.collabris.dto.TeamRequestDto;
import com.collabris.dto.TeamResponseDto;
import com.collabris.service.TeamService;
import io.swagger.v3.oas.annotations.Operation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize; 
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/teams")
public class TeamController {

    @Autowired
    private TeamService teamService;

    @PostMapping
    @Operation(summary = "Create a new team", description = "Creates a new team and assigns the current user as the owner.")
    // Any authenticated user can create a team.
    public ResponseEntity<TeamResponseDto> createTeam(@RequestBody TeamRequestDto teamRequestDto) {
        TeamResponseDto createdTeam = teamService.createTeam(teamRequestDto);
        return new ResponseEntity<>(createdTeam, HttpStatus.CREATED);
    }

    @GetMapping
    @Operation(summary = "Get all teams for the current user", description = "Returns a list of all teams the current user is a member of.")
    public ResponseEntity<List<TeamResponseDto>> getAllTeamsForCurrentUser() {
        List<TeamResponseDto> teams = teamService.getAllTeamsForCurrentUser();
        return ResponseEntity.ok(teams);
    }

    @GetMapping("/{teamId}")
    @Operation(summary = "Get team by ID", description = "Returns a specific team by its ID, if the user is a member.")
    public ResponseEntity<TeamResponseDto> getTeamById(@PathVariable Long teamId) {
        TeamResponseDto team = teamService.getTeamById(teamId);
        return ResponseEntity.ok(team);
    }

    @PutMapping("/{teamId}")
    @Operation(summary = "Update a team", description = "Updates a team's details. Requires ADMIN, MANAGER, or Owner role.")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER') or @teamRepository.findById(#teamId).get().getOwner().getUsername() == authentication.name")
    public ResponseEntity<TeamResponseDto> updateTeam(@PathVariable Long teamId, @RequestBody TeamRequestDto teamRequestDto) {
        TeamResponseDto updatedTeam = teamService.updateTeam(teamId, teamRequestDto);
        return ResponseEntity.ok(updatedTeam);
    }

    @DeleteMapping("/{teamId}")
    @Operation(summary = "Delete a team", description = "Deletes a team. Requires ADMIN, MANAGER, or Owner role.")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER') or @teamRepository.findById(#teamId).get().getOwner().getUsername() == authentication.name")
    public ResponseEntity<Void> deleteTeam(@PathVariable Long teamId) {
        teamService.deleteTeam(teamId);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/{teamId}/members/{userId}")
    @Operation(summary = "Add a member to a team", description = "Adds a user to a team. Requires ADMIN, MANAGER, or Owner role.")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER') or @teamRepository.findById(#teamId).get().getOwner().getUsername() == authentication.name")
    public ResponseEntity<TeamResponseDto> addMemberToTeam(@PathVariable Long teamId, @PathVariable Long userId) {
        TeamResponseDto team = teamService.addMemberToTeam(teamId, userId);
        return ResponseEntity.ok(team);
    }

    @DeleteMapping("/{teamId}/members/{userId}")
    @Operation(summary = "Remove a member from a team", description = "Removes a user from a team. Requires ADMIN, MANAGER, or Owner role.")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER') or @teamRepository.findById(#teamId).get().getOwner().getUsername() == authentication.name")
    public ResponseEntity<TeamResponseDto> removeMemberFromTeam(@PathVariable Long teamId, @PathVariable Long userId) {
        TeamResponseDto team = teamService.removeMemberFromTeam(teamId, userId);
        return ResponseEntity.ok(team);
    }
}
</file>

<file path="backend/src/main/java/com/collabris/controller/UserController.java">
// File Path: backend/src/main/java/com/collabris/controller/UserController.java
package com.collabris.controller;

import com.collabris.dto.UserDto;
import com.collabris.entity.User;
import com.collabris.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    // Helper method to convert a User Entity to a UserDto
    private UserDto convertToDto(User user) {
        return new UserDto(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getFirstName(),
                user.getLastName(),
                user.getCreatedAt(),
                user.getUpdatedAt(),
                user.getRoles().stream()
                   .map(role -> role.getName().toString())
                   .collect(Collectors.toSet())
        );
    }

    @GetMapping("/me")
    public ResponseEntity<UserDto> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        if (userDetails == null) {
            // This case should ideally be handled by security filters, but as a safeguard:
            return ResponseEntity.status(401).build();
        }
        // Fetch the full User entity from the database using the username from the JWT
        User user = userService.findByUsername(userDetails.getUsername())
                .orElseThrow(() -> new RuntimeException("Error: User not found."));
        
        // Convert the entity to a DTO and send it to the frontend
        return ResponseEntity.ok(convertToDto(user));
    }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/request/SignupRequest.java">
package com.collabris.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.util.Set;

public class SignupRequest {
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 20, message = "Username must be between 3 and 20 characters")
    private String username;

    @NotBlank(message = "Email is required")
    @Size(max = 50, message = "Email cannot be longer than 50 characters")
    @Email(message = "Email should be valid")
    private String email;

    private Set<String> role;

    @NotBlank(message = "Password is required")
    @Size(min = 6, max = 40, message = "Password must be between 6 and 40 characters")
    private String password;

    @NotBlank(message = "First name is required")
    private String firstName;

    @NotBlank(message = "Last name is required")
    private String lastName;

    // Getters and Setters
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }

    public Set<String> getRole() { return this.role; }
    public void setRole(Set<String> role) { this.role = role; }

    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }

    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/response/JwtResponse.java">
package com.collabris.dto.response;

import java.util.List;

public class JwtResponse {
    private String token;
    private String type = "Bearer";
    private Long id;
    private String username;
    private String email;
    private List<String> roles;

    public JwtResponse(String accessToken, Long id, String username, String email, List<String> roles) {
        this.token = accessToken;
        this.id = id;
        this.username = username;
        this.email = email;
        this.roles = roles;
    }

    // Getters and Setters
    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }

    public String getTokenType() { return type; }
    public void setTokenType(String tokenType) { this.type = tokenType; }

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public List<String> getRoles() { return roles; }
    public void setRoles(List<String> roles) { this.roles = roles; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/response/ProjectResponse.java">
package com.collabris.dto.response;

import com.collabris.entity.Project;

import java.time.LocalDateTime;
import java.util.Set;
import java.util.stream.Collectors;

public class ProjectResponse {
    private Long id;
    private String name;
    private String description;
    private Project.ProjectStatus status;
    private UserResponse owner;
    private Long teamId; // Sending teamId is simpler than the full Team object
    private Set<UserResponse> members;
    private LocalDateTime startDate;
    private LocalDateTime endDate;
    private LocalDateTime createdAt;

    public ProjectResponse(Project project) {
        this.id = project.getId();
        this.name = project.getName();
        this.description = project.getDescription();
        this.status = project.getStatus();
        this.owner = new UserResponse(project.getOwner());
        if (project.getTeam() != null) {
            this.teamId = project.getTeam().getId();
        }
        this.members = project.getMembers().stream()
                .map(UserResponse::new)
                .collect(Collectors.toSet());
        this.startDate = project.getStartDate();
        this.endDate = project.getEndDate();
        this.createdAt = project.getCreatedAt();
    }

    // Getters for all fields
    public Long getId() { return id; }
    public String getName() { return name; }
    public String getDescription() { return description; }
    public Project.ProjectStatus getStatus() { return status; }
    public UserResponse getOwner() { return owner; }
    public Long getTeamId() { return teamId; }
    public Set<UserResponse> getMembers() { return members; }
    public LocalDateTime getStartDate() { return startDate; }
    public LocalDateTime getEndDate() { return endDate; }
    public LocalDateTime getCreatedAt() { return createdAt; }
}
</file>

<file path="backend/src/main/java/com/collabris/dto/response/TeamResponse.java">
package com.collabris.dto.response;

import com.collabris.entity.Team;

import java.time.LocalDateTime;
import java.util.Set;
import java.util.stream.Collectors;

public class TeamResponse {
    private Long id;
    private String name;
    private String description;
    private UserResponse owner;
    private Set<UserResponse> members;
    private LocalDateTime createdAt;

    public TeamResponse(Team team) {
        this.id = team.getId();
        this.name = team.getName();
        this.description = team.getDescription();
        this.owner = new UserResponse(team.getOwner());
        this.members = team.getMembers().stream()
                .map(UserResponse::new)
                .collect(Collectors.toSet());
        this.createdAt = team.getCreatedAt();
    }

    // Getters for all fields
    public Long getId() { return id; }
    public String getName() { return name; }
    public String getDescription() { return description; }
    public UserResponse getOwner() { return owner; }
    public Set<UserResponse> getMembers() { return members; }
    public LocalDateTime getCreatedAt() { return createdAt; }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/User.java">
package com.collabris.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(max = 50)
    @Column(unique = true, nullable = false)
    private String username;

    @NotBlank
    @Email
    @Size(max = 100)
    @Column(unique = true, nullable = false)
    private String email;

    @NotBlank
    private String password;

    private String firstName;
    private String lastName;

    // new fields that other code expects
    @Column(name = "profile_picture")
    private String profilePicture;

    @Column(nullable = false)
    private boolean enabled = false;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id"))
    private Set<Role> roles = new HashSet<>();

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public User() {}

    // --- existing full constructor if you had one ---
    public User(String username, String email, String password, String firstName, String lastName) {
        this.username = username;
        this.email = email;
        this.password = password;
        this.firstName = firstName;
        this.lastName = lastName;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    // --- NEW convenience constructor used by AuthController in several places ---
    public User(String username, String email, String password) {
        this(username, email, password, null, null);
    }

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // Getters / Setters (only the important ones shown; include all used in the code)
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }

    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }

    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }

    public String getProfilePicture() { return profilePicture; }
    public void setProfilePicture(String profilePicture) { this.profilePicture = profilePicture; }

    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }

    public Set<Role> getRoles() { return roles; }
    public void setRoles(Set<Role> roles) { this.roles = roles; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
}
</file>

<file path="backend/src/main/java/com/collabris/exception/GlobalExceptionHandler.java">
package com.collabris.exception;

import com.collabris.dto.response.MessageResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(UsernameNotFoundException.class)
    public ResponseEntity<MessageResponse> handleUsernameNotFoundException(UsernameNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(new MessageResponse(ex.getMessage()));
    }

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<MessageResponse> handleRuntimeException(RuntimeException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new MessageResponse(ex.getMessage()));
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<MessageResponse> handleAccessDeniedException(AccessDeniedException ex) {
        return ResponseEntity.status(HttpStatus.FORBIDDEN)
                .body(new MessageResponse("Access denied: " + ex.getMessage()));
    }

    // --- NEW METHOD ADDED TO HANDLE VALIDATION ERRORS ---
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        // You might want to return a more structured response, e.g.,
        // a map of field names to error messages. For simplicity, we'll join them.
        String errorMessage = errors.values().stream().collect(Collectors.joining(", "));
        
        // For a better frontend experience, let's return the map of errors.
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errors);
    }
    // ---------------------------------------------------

    @ExceptionHandler(Exception.class)
    public ResponseEntity<MessageResponse> handleGenericException(Exception ex) {
        // Log the exception for debugging purposes
        // logger.error("An unexpected error occurred", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new MessageResponse("An unexpected error occurred: " + ex.getMessage()));
    }
}
</file>

<file path="backend/src/main/java/com/collabris/service/TeamService.java">
package com.collabris.service;

import com.collabris.dto.request.TeamRequest;
import com.collabris.dto.response.TeamResponse;
import com.collabris.entity.Team;
import com.collabris.entity.User;
import com.collabris.repository.TeamRepository;
import com.collabris.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class TeamService {
    
    @Autowired
    private TeamRepository teamRepository;
    
    @Autowired
    private UserRepository userRepository;

    public List<TeamResponse> getAllTeams() {
        return teamRepository.findAll().stream()
                .map(TeamResponse::new)
                .collect(Collectors.toList());
    }

    public TeamResponse getTeamById(Long id) {
        Team team = teamRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Team not found with id: " + id));
        return new TeamResponse(team);
    }

    public List<TeamResponse> getTeamsForUser(User user) {
        List<Team> ownedTeams = teamRepository.findByOwner(user);
        List<Team> memberTeams = teamRepository.findByMemberId(user.getId());

        return Stream.concat(ownedTeams.stream(), memberTeams.stream())
                .distinct()
                .map(TeamResponse::new)
                .collect(Collectors.toList());
    }

    public TeamResponse createTeam(TeamRequest teamRequest, User owner) {
        Team team = new Team(teamRequest.getName(), teamRequest.getDescription(), owner);
        
        if (teamRequest.getMemberIds() != null && !teamRequest.getMemberIds().isEmpty()) {
            Set<User> members = new HashSet<>(userRepository.findAllById(teamRequest.getMemberIds()));
            team.setMembers(members);
        }
        
        Team savedTeam = teamRepository.save(team);
        return new TeamResponse(savedTeam);
    }

    public TeamResponse updateTeam(Long id, TeamRequest teamRequest) {
        Team team = teamRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Team not found with id: " + id));
        
        if (teamRequest.getName() != null) team.setName(teamRequest.getName());
        if (teamRequest.getDescription() != null) team.setDescription(teamRequest.getDescription());
        
        if (teamRequest.getMemberIds() != null) {
            Set<User> members = new HashSet<>(userRepository.findAllById(teamRequest.getMemberIds()));
            team.setMembers(members);
        }
        
        Team updatedTeam = teamRepository.save(team);
        return new TeamResponse(updatedTeam);
    }

    public void deleteTeam(Long id) {
        if (!teamRepository.existsById(id)) {
            throw new RuntimeException("Team not found with id: " + id);
        }
        teamRepository.deleteById(id);
    }

    public TeamResponse addMemberToTeam(Long teamId, Long userId) {
        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new RuntimeException("Team not found with id: " + teamId));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with id: " + userId));
        
        team.getMembers().add(user);
        return new TeamResponse(teamRepository.save(team));
    }

    public TeamResponse removeMemberFromTeam(Long teamId, Long userId) {
        Team team = teamRepository.findById(teamId)
                .orElseThrow(() -> new RuntimeException("Team not found with id: " + teamId));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with id: " + userId));
        
        team.getMembers().remove(user);
        return new TeamResponse(teamRepository.save(team));
    }
}
</file>

<file path="backend/src/main/resources/templates/email-verification.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Verification - Collabris</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        .container {
            max-width: 600px;
            margin: 40px auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: 600;
        }
        .content {
            padding: 40px 30px;
            text-align: center;
        }
        .verification-code {
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            border: 2px dashed #6b7280;
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
            font-size: 32px;
            font-weight: bold;
            letter-spacing: 4px;
            color: #1f2937;
            font-family: 'Courier New', monospace;
        }
        .message {
            line-height: 1.6;
            color: #4b5563;
            margin-bottom: 30px;
        }
        .footer {
            background: #f9fafb;
            padding: 20px;
            text-align: center;
            font-size: 14px;
            color: #6b7280;
            border-top: 1px solid #e5e7eb;
        }
        .warning {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            color: #92400e;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1> Welcome to Collabris!</h1>
        </div>
        
        <div class="content">
            <p class="message">
                Hi <strong>{{firstName}}</strong>,<br><br>
                Thank you for joining Collabris! To complete your account setup, please verify your email address using the verification code below:
            </p>
            
            <div class="verification-code">
                {{verificationCode}}
            </div>
            
            <div class="warning">
                ⏰ This verification code will expire in <strong>10 minutes</strong> for security reasons.
            </div>
            
            <p class="message">
                Simply enter this code on the verification page to activate your account and start collaborating with your team!
            </p>
            
            <p class="message">
                If you didn't create an account with Collabris, please ignore this email.
            </p>
        </div>
        
        <div class="footer">
            <p>© 2024 Collabris. All rights reserved.</p>
            <p>This is an automated message, please do not reply to this email.</p>
        </div>
    </div>
</body>
</html>
</file>

<file path="frontend/package.json">
{
  "name": "collabris-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@emotion/react": "^11.11.1",
    "@emotion/styled": "^11.11.0",
    "@hookform/resolvers": "^3.3.2",
    "@mui/icons-material": "^5.15.1",
    "@mui/material": "^5.15.1",
    "@mui/x-charts": "^6.18.1",
    "@mui/x-data-grid": "^6.18.1",
    "@reduxjs/toolkit": "^2.0.1",
    "axios": "^1.6.2",
    "framer-motion": "^10.16.16",
    "lucide-react": "^0.344.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.48.2",
    "react-hot-toast": "^2.4.1",
    "react-redux": "^9.0.4",
    "react-router-dom": "^6.20.1",
    "recharts": "^2.8.0",
    "sockjs-client": "^1.6.1",
    "stompjs": "^2.3.3",
    "yup": "^1.4.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.7.0",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.9.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.11",
    "globals": "^15.9.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.3.0",
    "vite": "^5.4.20"
  }
}
</file>

<file path="frontend/src/components/Auth/ProtectedRoute.tsx">
import React, { useEffect } from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { Box, CircularProgress } from '@mui/material';
import { useAppSelector, useAppDispatch } from '../../store/store';
import { selectIsAuthenticated, selectIsLoading, selectUser, getCurrentUser } from '../../store/slices/authSlice';

interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRoles?: string[];
  fallbackPath?: string;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  requiredRoles = [], 
  fallbackPath = '/login' 
}) => {
  const dispatch = useAppDispatch();
  const location = useLocation();
  const isAuthenticated = useAppSelector(selectIsAuthenticated);
  const isLoading = useAppSelector(selectIsLoading);
  const user = useAppSelector(selectUser);

  useEffect(() => {
    if (isAuthenticated && !user) {
      dispatch(getCurrentUser());
    }
  }, [isAuthenticated, user, dispatch]);

  if (isLoading || (isAuthenticated && !user)) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="100vh">
        <CircularProgress />
      </Box>
    );
  }

  if (!isAuthenticated) {
    return <Navigate to={fallbackPath} state={{ from: location }} replace />;
  }

  // Add check for enabled user
  if (user && !user.enabled) {
    return <Navigate to="/verify-email" state={{ from: location, email: user.email }} replace />;
  }
  
  if (requiredRoles.length > 0 && user) {
    const userRoles = user.roles.map(role => role.name);
    const hasRequiredRole = requiredRoles.some(role => userRoles.includes(role as any));
    
    if (!hasRequiredRole) {
      const redirectPath = userRoles.includes('ADMIN') ? '/admin/dashboard' : '/dashboard';
      return <Navigate to={redirectPath} replace />;
    }
  }

  return <>{children}</>;
};

export default ProtectedRoute;
</file>

<file path="frontend/src/main.tsx">
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById('root')!).render(<App />);
</file>

<file path="frontend/src/pages/Dashboard.tsx">
import React, { useEffect, useState } from 'react';
import {
  Box,
  Grid,
  Card,
  CardContent,
  Typography,
  Avatar,
  LinearProgress,
  Chip,
  IconButton,
  Button,
  Paper,
  List,
  ListItem,
  ListItemAvatar,
  ListItemText,
  ListItemSecondaryAction,
  useTheme,
  alpha,
  Skeleton,
} from '@mui/material';
import {
  TrendingUp as TrendingUpIcon,
  People as PeopleIcon,
  Assignment as ProjectIcon,
  Chat as ChatIcon,
  Add as AddIcon,
  MoreVert as MoreIcon,
  Schedule as ScheduleIcon,
  CheckCircle as CheckIcon,
  Warning as WarningIcon,
  Notifications as NotificationsIcon,
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { motion } from 'framer-motion';
import { useAppSelector } from '../store/store';
import { selectUser } from '../store/slices/authSlice';
import { getUserProjects } from '../services/projectService';
import { getUserTeams } from '../services/teamService';
import { Project, Team } from '../types';

interface DashboardStats {
  totalProjects: number;
  activeTeams: number;
  completedTasks: number;
  pendingTasks: number;
}

interface RecentActivity {
  id: string;
  type: 'project' | 'team' | 'task' | 'message';
  title: string;
  description: string;
  timestamp: string;
  user?: string;
  avatar?: string;
}

// Using imported Project and Team types from '../types'

const Dashboard: React.FC = () => {
  const theme = useTheme();
  const navigate = useNavigate();
  const user = useAppSelector(selectUser);
  
  const [loading, setLoading] = useState(true);
  const [stats, setStats] = useState<DashboardStats>({
    totalProjects: 0,
    activeTeams: 0,
    completedTasks: 0,
    pendingTasks: 0,
  });
  const [recentProjects, setRecentProjects] = useState<Project[]>([]);
  const [recentTeams, setRecentTeams] = useState<Team[]>([]);
  const [recentActivity, setRecentActivity] = useState<RecentActivity[]>([]);

  useEffect(() => {
    const fetchDashboardData = async () => {
      try {
        setLoading(true);
        
        // Fetch user's projects
        const projects = await getUserProjects();
        
        // Fetch user's teams
        const teams = await getUserTeams();
        
        // Calculate stats
        const activeProjects = projects.filter((p: Project) => p.status === 'IN_PROGRESS');
        const completedProjects = projects.filter((p: Project) => p.status === 'COMPLETED');
        
        setStats({
          totalProjects: projects.length,
          activeTeams: teams.length,
          completedTasks: completedProjects.length * 5, // Estimate
          pendingTasks: activeProjects.length * 3, // Estimate
        });
        
        // Set recent data (limit to 6 items each)
        setRecentProjects(projects.slice(0, 6));
        setRecentTeams(teams.slice(0, 6));
        
        // Generate mock recent activity
        const mockActivity: RecentActivity[] = [
          {
            id: '1',
            type: 'project',
            title: 'Project Updated',
            description: `${projects[0]?.name || 'New Project'} progress updated to 75%`,
            timestamp: '2 hours ago',
            user: user?.username || 'User',
            avatar: user?.username?.charAt(0) || 'U',
          },
          {
            id: '2',
            type: 'team',
            title: 'New Team Member',
            description: `Someone joined ${teams[0]?.name || 'your team'}`,
            timestamp: '4 hours ago',
          },
          {
            id: '3',
            type: 'task',
            title: 'Task Completed',
            description: 'Database optimization task completed',
            timestamp: '1 day ago',
            user: user?.username || 'User',
          },
          {
            id: '4',
            type: 'message',
            title: 'New Message',
            description: 'New message in project chat',
            timestamp: '2 days ago',
          },
        ];
        setRecentActivity(mockActivity);
        
      } catch (error) {
        console.error('Failed to fetch dashboard data:', error);
        // Set default mock data on error
        setStats({
          totalProjects: 5,
          activeTeams: 3,
          completedTasks: 12,
          pendingTasks: 8,
        });
      } finally {
        setLoading(false);
      }
    };

    fetchDashboardData();
  }, [user]);

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'IN_PROGRESS':
        return theme.palette.success.main;
      case 'COMPLETED':
        return theme.palette.info.main;
      case 'ON_HOLD':
        return theme.palette.warning.main;
      case 'PLANNING':
        return theme.palette.info.main;
      default:
        return theme.palette.grey[500];
    }
  };

  const getActivityIcon = (type: string) => {
    switch (type) {
      case 'project':
        return <ProjectIcon sx={{ color: theme.palette.primary.main }} />;
      case 'team':
        return <PeopleIcon sx={{ color: theme.palette.success.main }} />;
      case 'task':
        return <CheckIcon sx={{ color: theme.palette.info.main }} />;
      case 'message':
        return <ChatIcon sx={{ color: theme.palette.warning.main }} />;
      default:
        return <NotificationsIcon />;
    }
  };

  const StatCard = ({ title, value, icon, trend, color }: any) => (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <Card
        sx={{
          height: '100%',
          background: `linear-gradient(135deg, ${color}15 0%, ${color}05 100%)`,
          border: `1px solid ${alpha(color, 0.2)}`,
          backdropFilter: 'blur(20px)',
          '&:hover': {
            transform: 'translateY(-4px)',
            boxShadow: `0 8px 25px ${alpha(color, 0.15)}`,
            transition: 'all 0.3s ease-in-out',
          },
        }}
      >
        <CardContent>
          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
            <Avatar
              sx={{
                bgcolor: alpha(color, 0.1),
                color: color,
                mr: 2,
              }}
            >
              {icon}
            </Avatar>
            <Box>
              <Typography variant="h4" sx={{ fontWeight: 700, color: theme.palette.text.primary }}>
                {loading ? <Skeleton width={60} /> : value}
              </Typography>
              <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>
                {title}
              </Typography>
            </Box>
          </Box>
          {trend && (
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <TrendingUpIcon sx={{ color: theme.palette.success.main, mr: 0.5, fontSize: 16 }} />
              <Typography variant="caption" sx={{ color: theme.palette.success.main }}>
                +{trend}% this month
              </Typography>
            </Box>
          )}
        </CardContent>
      </Card>
    </motion.div>
  );

  return (
    <Box sx={{ flexGrow: 1 }}>
      {/* Welcome Section */}
      <motion.div
        initial={{ opacity: 0, x: -20 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ duration: 0.6 }}
      >
        <Box
          sx={{
            mb: 4,
            p: 3,
            background: theme.palette.mode === 'light' 
              ? 'linear-gradient(135deg, rgba(37, 99, 235, 0.1) 0%, rgba(124, 58, 237, 0.1) 100%)'
              : 'linear-gradient(135deg, rgba(37, 99, 235, 0.2) 0%, rgba(124, 58, 237, 0.2) 100%)',
            borderRadius: 3,
            border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
          }}
        >
          <Typography variant="h4" sx={{ fontWeight: 700, mb: 1 }}>
            Welcome back, {user?.firstName || user?.username || 'User'}! 👋
          </Typography>
          <Typography variant="body1" sx={{ color: theme.palette.text.secondary, mb: 2 }}>
            Here's what's happening with your projects and teams today.
          </Typography>
          <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
            <Button
              variant="contained"
              startIcon={<AddIcon />}
              onClick={() => navigate('/projects/new')}
              sx={{
                background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)',
                '&:hover': {
                  background: 'linear-gradient(135deg, #1d4ed8 0%, #6d28d9 100%)',
                },
              }}
            >
              New Project
            </Button>
            <Button
              variant="outlined"
              startIcon={<PeopleIcon />}
              onClick={() => navigate('/teams')}
            >
              View Teams
            </Button>
          </Box>
        </Box>
      </motion.div>

      {/* Stats Cards */}
      <Grid container spacing={3} sx={{ mb: 4 }}>
        <Grid item xs={12} sm={6} lg={3}>
          <StatCard
            title="Total Projects"
            value={stats.totalProjects}
            icon={<ProjectIcon />}
            trend={15}
            color={theme.palette.primary.main}
          />
        </Grid>
        <Grid item xs={12} sm={6} lg={3}>
          <StatCard
            title="Active Teams"
            value={stats.activeTeams}
            icon={<PeopleIcon />}
            trend={8}
            color={theme.palette.success.main}
          />
        </Grid>
        <Grid item xs={12} sm={6} lg={3}>
          <StatCard
            title="Completed Tasks"
            value={stats.completedTasks}
            icon={<CheckIcon />}
            trend={25}
            color={theme.palette.info.main}
          />
        </Grid>
        <Grid item xs={12} sm={6} lg={3}>
          <StatCard
            title="Pending Tasks"
            value={stats.pendingTasks}
            icon={<WarningIcon />}
            color={theme.palette.warning.main}
          />
        </Grid>
      </Grid>

      {/* Main Content Grid */}
      <Grid container spacing={3}>
        {/* Recent Projects */}
        <Grid item xs={12} lg={8}>
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.6, delay: 0.2 }}
          >
            <Card sx={{ mb: 3 }}>
              <CardContent>
                <Box sx={{ display: 'flex', justifyContent: 'between', alignItems: 'center', mb: 2 }}>
                  <Typography variant="h6" sx={{ fontWeight: 600 }}>
                    Recent Projects
                  </Typography>
                  <Button
                    size="small"
                    onClick={() => navigate('/projects')}
                    sx={{ textTransform: 'none' }}
                  >
                    View All
                  </Button>
                </Box>
                
                {loading ? (
                  <Box>
                    {[1, 2, 3].map((item) => (
                      <Box key={item} sx={{ mb: 2 }}>
                        <Skeleton variant="text" width="60%" height={24} />
                        <Skeleton variant="text" width="80%" height={20} />
                        <Skeleton variant="rectangular" width="100%" height={4} sx={{ mt: 1 }} />
                      </Box>
                    ))}
                  </Box>
                ) : recentProjects.length > 0 ? (
                  <Box>
                    {recentProjects.map((project, index) => (
                      <motion.div
                        key={project.id}
                        initial={{ opacity: 0, x: -20 }}
                        animate={{ opacity: 1, x: 0 }}
                        transition={{ duration: 0.4, delay: index * 0.1 }}
                      >
                        <Box
                          sx={{
                            p: 2,
                            mb: 2,
                            border: `1px solid ${alpha(theme.palette.divider, 0.1)}`,
                            borderRadius: 2,
                            '&:hover': {
                              backgroundColor: alpha(theme.palette.action.hover, 0.05),
                              cursor: 'pointer',
                            },
                          }}
                          onClick={() => navigate(`/projects/${project.id}`)}
                        >
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                            <Typography variant="subtitle1" sx={{ fontWeight: 600 }}>
                              {project.name}
                            </Typography>
                            <Chip
                              label={project.status}
                              size="small"
                              sx={{
                                backgroundColor: alpha(getStatusColor(project.status), 0.1),
                                color: getStatusColor(project.status),
                                fontWeight: 600,
                              }}
                            />
                          </Box>
                          <Typography
                            variant="body2"
                            sx={{ color: theme.palette.text.secondary, mb: 2 }}
                          >
                            {project.description}
                          </Typography>
                          <Box sx={{ mb: 1 }}>
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                              <Typography variant="caption" sx={{ color: theme.palette.text.secondary }}>
                                Progress
                              </Typography>
                              <Typography variant="caption" sx={{ fontWeight: 600 }}>
                                {project.progress}%
                              </Typography>
                            </Box>
                            <LinearProgress
                              variant="determinate"
                              value={project.progress}
                              sx={{
                                height: 6,
                                borderRadius: 3,
                                backgroundColor: alpha(theme.palette.grey[500], 0.2),
                                '& .MuiLinearProgress-bar': {
                                  borderRadius: 3,
                                  backgroundColor: getStatusColor(project.status),
                                },
                              }}
                            />
                          </Box>
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Typography variant="caption" sx={{ color: theme.palette.text.secondary }}>
                              {project.members?.length || 0} members
                            </Typography>
                            {project.deadline && (
                              <Typography variant="caption" sx={{ color: theme.palette.text.secondary }}>
                                Due {new Date(project.deadline).toLocaleDateString()}
                              </Typography>
                            )}
                          </Box>
                        </Box>
                      </motion.div>
                    ))}
                  </Box>
                ) : (
                  <Box sx={{ textAlign: 'center', py: 4 }}>
                    <ProjectIcon sx={{ fontSize: 48, color: theme.palette.text.disabled, mb: 2 }} />
                    <Typography variant="body1" sx={{ color: theme.palette.text.secondary, mb: 2 }}>
                      No projects yet
                    </Typography>
                    <Button
                      variant="contained"
                      startIcon={<AddIcon />}
                      onClick={() => navigate('/projects/new')}
                    >
                      Create Your First Project
                    </Button>
                  </Box>
                )}
              </CardContent>
            </Card>
          </motion.div>
        </Grid>

        {/* Sidebar Content */}
        <Grid item xs={12} lg={4}>
          {/* Recent Teams */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.6, delay: 0.3 }}
          >
            <Card sx={{ mb: 3 }}>
              <CardContent>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                  <Typography variant="h6" sx={{ fontWeight: 600 }}>
                    Your Teams
                  </Typography>
                  <Button
                    size="small"
                    onClick={() => navigate('/teams')}
                    sx={{ textTransform: 'none' }}
                  >
                    View All
                  </Button>
                </Box>

                {loading ? (
                  <Box>
                    {[1, 2, 3].map((item) => (
                      <Box key={item} sx={{ mb: 2, display: 'flex', alignItems: 'center' }}>
                        <Skeleton variant="circular" width={40} height={40} sx={{ mr: 2 }} />
                        <Box sx={{ flex: 1 }}>
                          <Skeleton variant="text" width="70%" />
                          <Skeleton variant="text" width="50%" />
                        </Box>
                      </Box>
                    ))}
                  </Box>
                ) : recentTeams.length > 0 ? (
                  <List>
                    {recentTeams.slice(0, 4).map((team, index) => (
                      <motion.div
                        key={team.id}
                        initial={{ opacity: 0, x: 20 }}
                        animate={{ opacity: 1, x: 0 }}
                        transition={{ duration: 0.4, delay: index * 0.1 }}
                      >
                        <ListItem
                          sx={{
                            px: 0,
                            py: 1.5,
                            '&:hover': {
                              backgroundColor: alpha(theme.palette.action.hover, 0.05),
                              cursor: 'pointer',
                            },
                          }}
                          onClick={() => navigate(`/teams/${team.id}`)}
                        >
                          <ListItemAvatar>
                            <Avatar
                              sx={{
                                bgcolor: alpha(theme.palette.primary.main, 0.1),
                                color: theme.palette.primary.main,
                              }}
                            >
                              {team.name.charAt(0)}
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText
                            primary={team.name}
                            secondary={`${team.members?.length || 0} members • ${team.projects?.length || 0} projects`}
                            primaryTypographyProps={{ fontWeight: 600 }}
                          />
                          <ListItemSecondaryAction>
                            <IconButton edge="end" size="small">
                              <MoreIcon />
                            </IconButton>
                          </ListItemSecondaryAction>
                        </ListItem>
                      </motion.div>
                    ))}
                  </List>
                ) : (
                  <Box sx={{ textAlign: 'center', py: 3 }}>
                    <PeopleIcon sx={{ fontSize: 40, color: theme.palette.text.disabled, mb: 1 }} />
                    <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>
                      No teams yet
                    </Typography>
                  </Box>
                )}
              </CardContent>
            </Card>
          </motion.div>

          {/* Recent Activity */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.6, delay: 0.4 }}
          >
            <Card>
              <CardContent>
                <Typography variant="h6" sx={{ fontWeight: 600, mb: 2 }}>
                  Recent Activity
                </Typography>

                <List>
                  {recentActivity.map((activity, index) => (
                    <motion.div
                      key={activity.id}
                      initial={{ opacity: 0, x: 20 }}
                      animate={{ opacity: 1, x: 0 }}
                      transition={{ duration: 0.4, delay: index * 0.1 }}
                    >
                      <ListItem sx={{ px: 0, py: 1.5 }}>
                        <ListItemAvatar>
                          <Avatar sx={{ width: 32, height: 32 }}>
                            {getActivityIcon(activity.type)}
                          </Avatar>
                        </ListItemAvatar>
                        <ListItemText
                          primary={activity.title}
                          secondary={
                            <Box>
                              <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>
                                {activity.description}
                              </Typography>
                              <Typography variant="caption" sx={{ color: theme.palette.text.disabled }}>
                                {activity.timestamp}
                              </Typography>
                            </Box>
                          }
                          primaryTypographyProps={{ fontWeight: 600, fontSize: '0.875rem' }}
                        />
                      </ListItem>
                    </motion.div>
                  ))}
                </List>
              </CardContent>
            </Card>
          </motion.div>
        </Grid>
      </Grid>
    </Box>
  );
};

export default Dashboard;
</file>

<file path="frontend/src/pages/Dashboard/AdminDashboard.jsx">
import React from 'react';
import {
  Grid,
  Card,
  CardContent,
  Typography,
  Box,
  Button
} from '@mui/material';
import {
  PeopleAlt,
  FolderSpecial,
  Dns,
  Add as AddIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import { LineChart, Line, XAxis, YAxis, Tooltip, Legend, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';

import Layout from '../../components/Layout/Layout';
import StatsCard from '../../components/Common/StatsCard';

// Mock Data for Charts
const userGrowthData = [
  { name: 'Jan', users: 50 },
  { name: 'Feb', users: 65 },
  { name: 'Mar', users: 90 },
  { name: 'Apr', users: 110 },
  { name: 'May', users: 140 },
  { name: 'Jun', users: 180 },
];

const roleDistributionData = [
  { name: 'Admins', value: 2 },
  { name: 'Managers', value: 10 },
  { name: 'Members', value: 168 },
];
const COLORS = ['#FF8042', '#FFBB28', '#0088FE'];

const AdminDashboard = () => {
    return (
        <Layout>
            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }}>
                <Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
                    <Box>
                        <Typography variant="h4" fontWeight="bold" gutterBottom>
                            System Administration
                        </Typography>
                        <Typography variant="body1" color="text.secondary">
                            Manage users, monitor platform health, and view system-wide analytics.
                        </Typography>
                    </Box>
                    <Button variant="contained" startIcon={<AddIcon />}>Create New User</Button>
                </Box>

                <Grid container spacing={3}>
                    {/* Stats Cards */}
                    <Grid item xs={12} sm={4}><StatsCard title="Total Users" value="180" icon={<PeopleAlt />} color="primary" /></Grid>
                    <Grid item xs={12} sm={4}><StatsCard title="Total Projects" value="75" icon={<FolderSpecial />} color="secondary" /></Grid>
                    <Grid item xs={12} sm={4}><StatsCard title="Server Status" value="Online" icon={<Dns />} color="success" /></Grid>

                    {/* Charts */}
                    <Grid item xs={12} md={7}>
                        <Card sx={{ height: '100%' }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>User Growth (Last 6 Months)</Typography>
                                <ResponsiveContainer width="100%" height={300}>
                                    <LineChart data={userGrowthData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
                                        <XAxis dataKey="name" />
                                        <YAxis />
                                        <Tooltip />
                                        <Legend />
                                        <Line type="monotone" dataKey="users" stroke="#8884d8" activeDot={{ r: 8 }} />
                                    </LineChart>
                                </ResponsiveContainer>
                            </CardContent>
                        </Card>
                    </Grid>
                    <Grid item xs={12} md={5}>
                         <Card sx={{ height: '100%' }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>User Role Distribution</Typography>
                                <ResponsiveContainer width="100%" height={300}>
                                    <PieChart>
                                        <Pie data={roleDistributionData} cx="50%" cy="50%" labelLine={false} outerRadius={100} fill="#8884d8" dataKey="value" label={({ name, value }) => `${name}: ${value}`}>
                                            {roleDistributionData.map((entry, index) => (<Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />))}
                                        </Pie>
                                        <Tooltip />
                                    </PieChart>
                                </ResponsiveContainer>
                            </CardContent>
                        </Card>
                    </Grid>
                </Grid>
            </motion.div>
        </Layout>
    );
};

export default AdminDashboard;
</file>

<file path="frontend/src/pages/Landing/Landing.tsx">
import React from 'react';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import {
  Box,
  Container,
  Typography,
  Button,
  Grid,
  Card,
  CardContent,
  Avatar,
  useTheme,
  alpha,
  AppBar,
  Toolbar,
  IconButton,
} from '@mui/material';
import {
  ArrowForward as ArrowForwardIcon,
  People as PeopleIcon,
  Assignment as AssignmentIcon,
  Chat as ChatIcon,
  Security as SecurityIcon,
  Speed as SpeedIcon,
  Star as StarIcon,
  Brightness4 as DarkModeIcon,
  Brightness7 as LightModeIcon,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import { useAppSelector, useAppDispatch } from '../../store/store';
import { selectEffectiveTheme, toggleTheme } from '../../store/slices/themeSlice';
import '../../theme/customStyles.css';

const Landing: React.FC = () => {
  const theme = useAppTheme();
  const navigate = useNavigate();
  const dispatch = useAppDispatch();
  const currentTheme = useAppSelector(selectEffectiveTheme);

  const handleGetStarted = () => navigate('/register');
  const handleSignIn = () => navigate('/login');
  const handleThemeToggle = () => dispatch(toggleTheme());

  const features = [
    { icon: <PeopleIcon sx={{ fontSize: 40 }} />, title: 'Team Management', description: 'Organize teams, assign roles, and manage permissions with ease.' },
    { icon: <AssignmentIcon sx={{ fontSize: 40 }} />, title: 'Project Tracking', description: 'Track project progress, set deadlines, and monitor team productivity.' },
    { icon: <ChatIcon sx={{ fontSize: 40 }} />, title: 'Real-time Chat', description: 'Communicate instantly with team members through integrated messaging.' },
    { icon: <SecurityIcon sx={{ fontSize: 40 }} />, title: 'Secure & Private', description: 'Enterprise-grade security with role-based access control.' },
    { icon: <SpeedIcon sx={{ fontSize: 40 }} />, title: 'Fast & Responsive', description: 'Lightning-fast performance with modern web technologies.' },
  ];

  const testimonials = [
    { name: 'Sarah J.', role: 'Product Manager', avatar: 'SJ', rating: 5, text: 'Collabris transformed how our team collaborates. The real-time features are game-changing!' },
    { name: 'Michael C.', role: 'Software Engineer', avatar: 'MC', rating: 5, text: 'The most intuitive project management tool I\'ve used. Setup was incredibly easy.' },
    { name: 'Emily R.', role: 'Design Lead', avatar: 'ER', rating: 5, text: 'Finally, a platform that actually makes our workflow smoother.' },
  ];

  return (
    <Box sx={{ backgroundColor: theme.palette.background.default, color: theme.palette.text.primary }}>
      <AppBar position="sticky" elevation={0} sx={{ backgroundColor: alpha(theme.palette.background.paper, 0.8), backdropFilter: 'blur(20px)', borderBottom: `1px solid ${theme.palette.divider}` }}>
        <Toolbar>
          <Typography variant="h5" component="div" sx={{ flexGrow: 1, fontWeight: 700, background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', backgroundClip: 'text' }}>Collabris</Typography>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            {/* --- THIS IS THE CORRECTED LINE --- */}
            <IconButton onClick={handleThemeToggle} color="inherit">
              {currentTheme === 'dark' ? <LightModeIcon /> : <DarkModeIcon />}
            </IconButton>
            <Button color="inherit" onClick={handleSignIn} sx={{ textTransform: 'none', display: { xs: 'none', sm: 'inline-flex' } }}>Sign In</Button>
            <Button variant="contained" onClick={handleGetStarted} sx={{ textTransform: 'none', background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)', '&:hover': { background: 'linear-gradient(135deg, #1d4ed8 0%, #6d28d9 100%)' } }}>Get Started</Button>
          </Box>
        </Toolbar>
      </AppBar>

      <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.8 }}>
        <Container maxWidth="lg" sx={{ textAlign: 'center', py: { xs: 8, md: 12 } }}>
          <Typography variant="h1" component="h1" sx={{ fontSize: { xs: '2.5rem', md: '4rem' }, fontWeight: 800, mb: 2, background: `linear-gradient(135deg, ${theme.palette.primary.main} 0%, ${theme.palette.secondary.main} 100%)`, WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', backgroundClip: 'text' }}>Collaborate Smarter, Achieve More</Typography>
          <Typography variant="h5" sx={{ color: 'text.secondary', mb: 4, maxWidth: '700px', mx: 'auto' }}>The ultimate platform for modern teams. Manage projects, communicate in real-time, and drive success together.</Typography>
          <Button variant="contained" size="large" endIcon={<ArrowForwardIcon />} onClick={handleGetStarted} sx={{ px: 5, py: 1.5, fontSize: '1.1rem', background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)', '&:hover': { background: 'linear-gradient(135deg, #1d4ed8 0%, #6d28d9 100%)' } }}>Get Started for Free</Button>
        </Container>

        <Container maxWidth="lg" sx={{ py: 8 }}>
          <Grid container spacing={4}>
            {features.map((feature, index) => (
              <Grid item xs={12} md={4} key={index}>
                <motion.div initial={{ opacity: 0, y: 30 }} whileInView={{ opacity: 1, y: 0 }} transition={{ duration: 0.5, delay: index * 0.1 }} viewport={{ once: true }}>
                  <Card sx={{ height: '100%', p: 2, textAlign: 'center', border: 'none', background: 'transparent' }}>
                    <Box sx={{ width: 80, height: 80, borderRadius: '50%', background: `linear-gradient(135deg, ${alpha(theme.palette.primary.main, 0.1)} 0%, ${alpha(theme.palette.secondary.main, 0.1)} 100%)`, display: 'flex', alignItems: 'center', justifyContent: 'center', mx: 'auto', mb: 2, color: 'primary.main' }}>{feature.icon}</Box>
                    <Typography variant="h6" component="h3" sx={{ fontWeight: 600, mb: 1 }}>{feature.title}</Typography>
                    <Typography variant="body2" color="text.secondary">{feature.description}</Typography>
                  </Card>
                </motion.div>
              </Grid>
            ))}
          </Grid>
        </Container>

        <Box sx={{ backgroundColor: alpha(theme.palette.primary.main, 0.05), py: 8 }}>
          <Container maxWidth="lg">
            <Typography variant="h2" component="h2" sx={{ fontWeight: 700, mb: 6, textAlign: 'center' }}>Loved by Teams Worldwide</Typography>
            <Grid container spacing={4}>
              {testimonials.map((testimonial, index) => (
                <Grid item xs={12} md={4} key={index}>
                  <Card sx={{ height: '100%', p: 3, display: 'flex', flexDirection: 'column' }}>
                    <Box sx={{ mb: 2 }}>{[...Array(5)].map((_, i) => <StarIcon key={i} sx={{ color: '#fbbf24', fontSize: 20 }} />)}</Box>
                    <Typography variant="body1" sx={{ fontStyle: 'italic', flexGrow: 1, mb: 2 }}>"{testimonial.text}"</Typography>
                    <Box sx={{ display: 'flex', alignItems: 'center', mt: 'auto' }}>
                      <Avatar sx={{ width: 48, height: 48, mr: 2, background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)' }}>{testimonial.avatar}</Avatar>
                      <Box>
                        <Typography variant="subtitle2" sx={{ fontWeight: 600 }}>{testimonial.name}</Typography>
                        <Typography variant="body2" color="text.secondary">{testimonial.role}</Typography>
                      </Box>
                    </Box>
                  </Card>
                </Grid>
              ))}
            </Grid>
          </Container>
        </Box>

        <Container maxWidth="md" sx={{ textAlign: 'center', py: 12 }}>
          <Typography variant="h2" component="h2" sx={{ fontWeight: 700, mb: 2 }}>Ready to Transform Your Team?</Typography>
          <Typography variant="h6" sx={{ color: 'text.secondary', mb: 4 }}>Join thousands of teams collaborating more effectively with Collabris.</Typography>
          <Button variant="contained" size="large" endIcon={<ArrowForwardIcon />} onClick={handleGetStarted} sx={{ px: 5, py: 1.5, fontSize: '1.1rem', background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)', '&:hover': { background: 'linear-gradient(135deg, #1d4ed8 0%, #6d28d9 100%)' } }}>Start Your Free Trial</Button>
        </Container>
      </motion.div>

      <Box component="footer" sx={{ py: 4, backgroundColor: theme.palette.background.paper, borderTop: `1px solid ${theme.palette.divider}` }}>
        <Container maxWidth="lg">
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap', gap: 2 }}>
            <Typography variant="h6" sx={{ fontWeight: 700, background: 'linear-gradient(135deg, #2563eb 0%, #7c3aed 100%)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', backgroundClip: 'text' }}>Collabris</Typography>
            <Typography variant="body2" color="text.secondary">© {new Date().getFullYear()} Collabris. All rights reserved.</Typography>
          </Box>
        </Container>
      </Box>
    </Box>
  );
};

// A helper hook for consistent theme usage
const useAppTheme = () => useTheme();

export default Landing;
</file>

<file path="frontend/src/services/apiClient.ts">
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import { config } from '../config/environment';
import { ApiResponse, ApiError } from '../types';

class ApiClient {
  private instance: AxiosInstance;

  constructor() {
    this.instance = axios.create({
      baseURL: '/',
      timeout: 15000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    // Request interceptor to add auth token
    this.instance.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('token');
        if (token && config.headers) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );

    // Response interceptor for error handling
    this.instance.interceptors.response.use(
      (response: AxiosResponse) => {
        return response;
      },
      (error: AxiosError) => {
        if (error.response) {
          const { status, data } = error.response;
          
          // Handle specific error cases
          if (status === 401) {
            // Unauthorized - token might be expired
            localStorage.removeItem('token');
            window.location.href = '/login';
            return Promise.reject(new Error('Session expired. Please login again.'));
          }
          
          if (status === 403) {
            return Promise.reject(new Error('Access denied. Insufficient permissions.'));
          }
          
          if (status === 404) {
            return Promise.reject(new Error('Resource not found.'));
          }
          
          if (status >= 500) {
            return Promise.reject(new Error('Server error. Please try again later.'));
          }
          
          // Extract error message from response
          const errorMessage = (data as any)?.message || (data as any)?.error || 'An error occurred';
          return Promise.reject(new Error(errorMessage));
        }
        
        if (error.request) {
          return Promise.reject(new Error('Network error. Please check your connection.'));
        }
        
        return Promise.reject(new Error('Request failed. Please try again.'));
      }
    );
  }

  public async get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.get<T>(url, config);
    return response.data;
  }

  public async post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.post<T>(url, data, config);
    return response.data;
  }

  public async put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.put<T>(url, data, config);
    return response.data;
  }

  public async patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.patch<T>(url, data, config);
    return response.data;
  }

  public async delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.delete<T>(url, config);
    return response.data;
  }

  public async upload<T = any>(url: string, formData: FormData, onProgress?: (progress: number) => void): Promise<T> {
    const response = await this.instance.post<T>(url, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
          onProgress(progress);
        }
      },
    });
    return response.data;
  }

  // Method to update auth token
  public setAuthToken(token: string): void {
    if (token) {
      this.instance.defaults.headers.common['Authorization'] = `Bearer ${token}`;
    } else {
      delete this.instance.defaults.headers.common['Authorization'];
    }
  }

  // Method to clear auth token
  public clearAuthToken(): void {
    delete this.instance.defaults.headers.common['Authorization'];
  }

  // Get raw axios instance for advanced usage
  public getInstance(): AxiosInstance {
    return this.instance;
  }
}

const apiClient = new ApiClient();
export default apiClient;
</file>

<file path="frontend/src/services/authService.ts">
import apiClient from './apiClient';
import { endpoints } from '../config/environment';
import { LoginRequest, SignupRequest, AuthResponse, User } from '../types';

export const login = async (credentials: LoginRequest): Promise<AuthResponse> => {
  const response = await apiClient.post(endpoints.auth.signin, credentials);
  return response;
};

export const signup = async (userData: SignupRequest): Promise<{ message: string }> => {
  const response = await apiClient.post(endpoints.auth.signup, userData);
  return response;
};

export const getCurrentUser = async (): Promise<User> => {
  const response = await apiClient.get('/api/users/me'); 
  return response;
};

export const verifyEmail = async (data: { code: string }): Promise<{ message: string }> => {
    return apiClient.post('/api/auth/verify-email', data);
};

export const resendVerificationEmail = async (data: { email: string }): Promise<{ message: string }> => {
    return apiClient.post('/api/auth/resend-verification', data);
};

export const forgotPassword = async (data: { email: string }): Promise<{ message: string }> => {
    return apiClient.post('/api/auth/forgot-password', data);
};

export const verifyResetCode = async (data: { email: string, code: string }): Promise<{ message: string }> => {
    return apiClient.post('/api/auth/verify-reset-code', data);
};

export const resetPassword = async (data: { email: string, code: string, newPassword: string }): Promise<{ message: string }> => {
    return apiClient.post('/api/auth/reset-password', data);
};


export const updateProfile = async (userData: Partial<User>): Promise<User> => {
  const response = await apiClient.put('/api/users/me', userData);
  return response;
};

export const uploadAvatar = async (file: File): Promise<string> => {
  const formData = new FormData();
  formData.append('avatar', file);
  
  const response = await apiClient.upload('/api/users/me/avatar', formData);
  return response.avatarUrl || response.url;
};

export const changePassword = async (currentPassword: string, newPassword: string): Promise<{ message: string }> => {
  const response = await apiClient.put('/api/users/me/password', {
    currentPassword,
    newPassword,
  });
  return response;
};

export const logout = (): void => {
  localStorage.removeItem('token');
  apiClient.clearAuthToken();
};
</file>

<file path="frontend/src/services/projectService.ts">
import apiClient from './apiClient';
import { endpoints } from '../config/environment';
import { Project, ProjectRequest, User, PaginationParams, PaginatedResponse } from '../types';

export const getAllProjects = async (params?: PaginationParams): Promise<PaginatedResponse<Project>> => {
  const queryParams = new URLSearchParams();
  if (params?.page) queryParams.append('page', params.page.toString());
  if (params?.size) queryParams.append('size', params.size.toString());
  if (params?.sort) queryParams.append('sort', params.sort);
  if (params?.direction) queryParams.append('direction', params.direction);

  const url = `${endpoints.projects.getAll}?${queryParams.toString()}`;
  const response = await apiClient.get<PaginatedResponse<Project>>(url);
  return response;
};

export const getProjectById = async (id: number): Promise<Project> => {
  const response = await apiClient.get<Project>(endpoints.projects.getById(id));
  return response;
};

export const createProject = async (projectData: ProjectRequest): Promise<Project> => {
  const response = await apiClient.post<Project>(endpoints.projects.create, projectData);
  return response;
};

export const updateProject = async (id: number, projectData: Partial<ProjectRequest>): Promise<Project> => {
  const response = await apiClient.put<Project>(endpoints.projects.update(id), projectData);
  return response;
};

export const deleteProject = async (id: number): Promise<void> => {
  await apiClient.delete(endpoints.projects.delete(id));
};

export const addProjectMember = async (projectId: number, userId: number): Promise<void> => {
  await apiClient.post(endpoints.projects.addMember(projectId, userId));
};

export const removeProjectMember = async (projectId: number, userId: number): Promise<void> => {
  await apiClient.delete(endpoints.projects.removeMember(projectId, userId));
};

export const getProjectMembers = async (projectId: number): Promise<User[]> => {
  const response = await apiClient.get<User[]>(`/api/projects/${projectId}/members`);
  return response;
};

export const getUserProjects = async (userId?: number): Promise<Project[]> => {
  const url = userId ? `/api/projects/user/${userId}` : '/api/projects/my-projects';
  const response = await apiClient.get<Project[]>(url);
  return response;
};

export const getProjectsByTeam = async (teamId: number): Promise<Project[]> => {
  const response = await apiClient.get<Project[]>(`/api/projects/team/${teamId}`);
  return response;
};

export const searchProjects = async (query: string, params?: PaginationParams): Promise<PaginatedResponse<Project>> => {
  const queryParams = new URLSearchParams();
  queryParams.append('q', query);
  if (params?.page) queryParams.append('page', params.page.toString());
  if (params?.size) queryParams.append('size', params.size.toString());

  const url = `${endpoints.projects.getAll}/search?${queryParams.toString()}`;
  const response = await apiClient.get<PaginatedResponse<Project>>(url);
  return response;
};

export const getProjectStats = async (): Promise<{
  totalProjects: number;
  activeProjects: number;
  completedProjects: number;
  overdue: number;
  projectsByStatus: { status: string; count: number }[];
  projectsByPriority: { priority: string; count: number }[];
}> => {
  const response = await apiClient.get('/api/projects/stats');
  return response;
};

export const updateProjectProgress = async (id: number, progress: number): Promise<Project> => {
  const response = await apiClient.patch<Project>(`/api/projects/${id}/progress`, { progress });
  return response;
};

export const bulkUpdateProjects = async (projectIds: number[], updates: Partial<ProjectRequest>): Promise<void> => {
  await apiClient.put('/api/projects/bulk', { projectIds, updates });
};

export const archiveProject = async (id: number): Promise<void> => {
  await apiClient.patch(`/api/projects/${id}/archive`);
};

export const restoreProject = async (id: number): Promise<void> => {
  await apiClient.patch(`/api/projects/${id}/restore`);
};

export const getProjectAnalytics = async (id: number): Promise<{
  tasksCompleted: number;
  totalTasks: number;
  timeSpent: number;
  teamProductivity: { userId: number; productivity: number }[];
  milestones: { name: string; date: string; completed: boolean }[];
}> => {
  const response = await apiClient.get(`/api/projects/${id}/analytics`);
  return response;
};
</file>

<file path="frontend/src/services/teamService.ts">
import apiClient from './apiClient';
import { endpoints } from '../config/environment';
import { Team, TeamRequest, User, PaginationParams, PaginatedResponse } from '../types';

export const getAllTeams = async (params?: PaginationParams): Promise<PaginatedResponse<Team>> => {
  const queryParams = new URLSearchParams();
  if (params?.page) queryParams.append('page', params.page.toString());
  if (params?.size) queryParams.append('size', params.size.toString());
  if (params?.sort) queryParams.append('sort', params.sort);
  if (params?.direction) queryParams.append('direction', params.direction);

  const url = `${endpoints.teams.getAll}?${queryParams.toString()}`;
  const response = await apiClient.get<PaginatedResponse<Team>>(url);
  return response;
};

export const getTeamById = async (id: number): Promise<Team> => {
  const response = await apiClient.get<Team>(endpoints.teams.getById(id));
  return response;
};

export const createTeam = async (teamData: TeamRequest): Promise<Team> => {
  const response = await apiClient.post<Team>(endpoints.teams.create, teamData);
  return response;
};

export const updateTeam = async (id: number, teamData: Partial<TeamRequest>): Promise<Team> => {
  const response = await apiClient.put<Team>(endpoints.teams.update(id), teamData);
  return response;
};

export const deleteTeam = async (id: number): Promise<void> => {
  await apiClient.delete(endpoints.teams.delete(id));
};

export const addTeamMember = async (teamId: number, userId: number): Promise<void> => {
  await apiClient.post(endpoints.teams.addMember(teamId, userId));
};

export const removeTeamMember = async (teamId: number, userId: number): Promise<void> => {
  await apiClient.delete(endpoints.teams.removeMember(teamId, userId));
};

export const getTeamMembers = async (teamId: number): Promise<User[]> => {
  const response = await apiClient.get<User[]>(`/api/teams/${teamId}/members`);
  return response;
};

export const getUserTeams = async (userId?: number): Promise<Team[]> => {
  const url = userId ? `/api/teams/user/${userId}` : '/api/teams/my-teams';
  const response = await apiClient.get<Team[]>(url);
  return response;
};

export const searchTeams = async (query: string, params?: PaginationParams): Promise<PaginatedResponse<Team>> => {
  const queryParams = new URLSearchParams();
  queryParams.append('q', query);
  if (params?.page) queryParams.append('page', params.page.toString());
  if (params?.size) queryParams.append('size', params.size.toString());

  const url = `${endpoints.teams.getAll}/search?${queryParams.toString()}`;
  const response = await apiClient.get<PaginatedResponse<Team>>(url);
  return response;
};

export const getTeamStats = async (): Promise<{
  totalTeams: number;
  averageTeamSize: number;
  teamsCreatedThisMonth: number;
  teamsBySize: { size: string; count: number }[];
}> => {
  const response = await apiClient.get('/api/teams/stats');
  return response;
};

export const bulkAddMembers = async (teamId: number, userIds: number[]): Promise<void> => {
  await apiClient.post(`/api/teams/${teamId}/members/bulk`, { userIds });
};

export const bulkRemoveMembers = async (teamId: number, userIds: number[]): Promise<void> => {
  await apiClient.delete(`/api/teams/${teamId}/members/bulk`, { data: { userIds } });
};
</file>

<file path="frontend/src/store/store.ts">
import { configureStore } from '@reduxjs/toolkit';
import { useDispatch, useSelector, TypedUseSelectorHook } from 'react-redux';
import authReducer from './slices/authSlice';
import themeReducer from './slices/themeSlice';
import uiReducer from './slices/uiSlice';
import userReducer from './slices/userSlice'; // Import the new reducer

export const store = configureStore({
  reducer: {
    auth: authReducer,
    theme: themeReducer,
    ui: uiReducer,
    user: userReducer, // Add the user reducer to the store
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: false,
    }),
  devTools: process.env.NODE_ENV !== 'production',
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

export default store;
</file>

<file path="frontend/vite.config.ts">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        secure: false,
      },
      '/ws': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        ws: true,
      },
    },
  },
  optimizeDeps: {
    exclude: ['lucide-react'],
  },
});
</file>

<file path="backend/src/main/java/com/collabris/config/WebSecurityConfig.java">
// File Path: backend/src/main/java/com/collabris/config/WebSecurityConfig.java
package com.collabris.config;

import com.collabris.security.jwt.AuthEntryPointJwt;
import com.collabris.security.jwt.AuthTokenFilter;
import com.collabris.security.services.UserDetailsServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity; // <-- IMPORTED
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableMethodSecurity // <-- THIS ANNOTATION ENABLES @PreAuthorize FOR LATER USE
public class WebSecurityConfig {

    @Autowired
    UserDetailsServiceImpl userDetailsService;

    @Autowired
    private AuthEntryPointJwt unauthorizedHandler;

    @Bean
    public AuthTokenFilter authenticationJwtTokenFilter() {
        return new AuthTokenFilter();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth ->
                        auth.requestMatchers("/api/auth/**").permitAll()
                                .requestMatchers("/api/test/**").permitAll()
                                // Added new paths for Swagger/OpenAPI to be publicly accessible
                                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**", "/ws/**").permitAll()
                                .anyRequest().authenticated()
                );

        http.authenticationProvider(authenticationProvider());
        http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
</file>

<file path="backend/src/main/java/com/collabris/entity/VerificationToken.java">
// backend/src/main/java/com/collabris/entity/VerificationToken.java
package com.collabris.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "verification_tokens")
public class VerificationToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // --- MODIFICATION: Changed fetch type to EAGER to fix session errors ---
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "code", nullable = false, length = 6)
    private String code;

    @Enumerated(EnumType.STRING)
    @Column(name = "token_type", nullable = false)
    private TokenType tokenType;

    @Column(name = "expires_at", nullable = false)
    private LocalDateTime expiresAt;

    @Column(name = "used_at")
    private LocalDateTime usedAt;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    public enum TokenType {
        EMAIL_VERIFICATION,
        PASSWORD_RESET
    }

    public VerificationToken() {}

    public VerificationToken(User user, String code, TokenType tokenType) {
        this.user = user;
        this.code = code;
        this.tokenType = tokenType;
        this.createdAt = LocalDateTime.now();
        this.expiresAt = LocalDateTime.now().plusMinutes(10); // 10-minute expiry for security
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public User getUser() { return user; }
    public void setUser(User user) { this.user = user; }
    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
    public TokenType getTokenType() { return tokenType; }
    public void setTokenType(TokenType tokenType) { this.tokenType = tokenType; }
    public LocalDateTime getExpiresAt() { return expiresAt; }
    public void setExpiresAt(LocalDateTime expiresAt) { this.expiresAt = expiresAt; }
    public LocalDateTime getUsedAt() { return usedAt; }
    public void setUsedAt(LocalDateTime usedAt) { this.usedAt = usedAt; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiresAt);
    }

    public boolean isUsed() {
        return usedAt != null;
    }

    public void markAsUsed() {
        this.usedAt = LocalDateTime.now();
    }
}
</file>

<file path="frontend/src/pages/Auth/Register.tsx">
// File path: frontend/src/pages/Auth/Register.tsx

import React, { useState, useEffect } from 'react';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Typography,
  Link,
  Alert,
  InputAdornment,
  IconButton,
  Divider,
  useTheme,
  alpha,
} from '@mui/material';
import {
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon,
  PersonOutline as UserIcon,
  EmailOutlined as EmailIcon,
  LockOutlined as PasswordIcon,
} from '@mui/icons-material';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup'; // <-- FIX: Corrected typo from 'yyp'
import { useAppDispatch, useAppSelector } from '../../store/store';
// FIX: Changed import from 'registerUser' to 'signup' to match authSlice.ts
import { signup, clearError, selectIsLoading, selectAuthError } from '../../store/slices/authSlice'; 
import { SignupRequest } from '../../types';

const signupSchema = yup.object().shape({
  firstName: yup.string().required('First name is required'),
  lastName: yup.string().required('Last name is required'),
  username: yup.string().required('Username is required'),
  email: yup.string().email('Enter a valid email').required('Email is required'),
  password: yup.string().min(8, 'Password must be at least 8 characters').required('Password is required'),
});

const Register: React.FC = () => {
  const [showPassword, setShowPassword] = useState(false);
  const theme = useTheme();
  const navigate = useNavigate();
  const dispatch = useAppDispatch();

  const isLoading = useAppSelector(selectIsLoading);
  const error = useAppSelector(selectAuthError);

  const {
    control,
    handleSubmit,
    formState: { errors },
  } = useForm<SignupRequest>({
    resolver: yupResolver(signupSchema),
    defaultValues: {
      firstName: '',
      lastName: '',
      username: '',
      email: '',
      password: '',
    },
  });

  useEffect(() => {
    dispatch(clearError());
  }, [dispatch]);

  const onSubmit = async (data: SignupRequest) => {
    try {
      // FIX: Dispatch the correctly named 'signup' thunk
      await dispatch(signup(data)).unwrap();
      navigate('/verify-email', { state: { email: data.email }, replace: true });
    } catch (err) {
      // Error is handled by authSlice and displayed in the Alert
    }
  };

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: `linear-gradient(135deg, ${theme.palette.background.default} 0%, ${alpha(
          theme.palette.secondary.main,
          0.1
        )} 100%)`,
        p: 2,
      }}
    >
      <Card
        sx={{
          maxWidth: 420,
          width: '100%',
          borderRadius: 3,
          boxShadow: '0 25px 50px -12px rgba(0,0,0,0.25)',
          backdropFilter: 'blur(20px)',
          backgroundColor: alpha(theme.palette.background.paper, 0.9),
        }}
        className="animate-fade-in"
      >
        <CardContent sx={{ p: { xs: 3, sm: 4 } }}>
          <Box textAlign="center" mb={3}>
            <Typography
              variant="h4"
              component="h1"
              sx={{ fontWeight: 700, mb: 1, color: 'secondary.main' }}
            >
              Create an Account
            </Typography>
            <Typography variant="body2" color="text.secondary">
              Join Collabris and start collaborating
            </Typography>
          </Box>

          {error && (
            <Alert severity="error" sx={{ mb: 3 }}>
              {error}
            </Alert>
          )}

          <Box component="form" onSubmit={handleSubmit(onSubmit)} noValidate>
            <Box sx={{ display: 'flex', gap: 2, mb: 2 }}>
              <Controller
                name="firstName"
                control={control}
                render={({ field }) => (
                  <TextField
                    {...field}
                    fullWidth
                    label="First Name"
                    error={!!errors.firstName}
                    helperText={errors.firstName?.message}
                  />
                )}
              />
              <Controller
                name="lastName"
                control={control}
                render={({ field }) => (
                  <TextField
                    {...field}
                    fullWidth
                    label="Last Name"
                    error={!!errors.lastName}
                    helperText={errors.lastName?.message}
                  />
                )}
              />
            </Box>

            <Controller
              name="username"
              control={control}
              render={({ field }) => (
                <TextField
                  {...field}
                  fullWidth
                  label="Username"
                  error={!!errors.username}
                  helperText={errors.username?.message}
                  sx={{ mb: 2 }}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <UserIcon color="action" />
                      </InputAdornment>
                    ),
                  }}
                />
              )}
            />

            <Controller
              name="email"
              control={control}
              render={({ field }) => (
                <TextField
                  {...field}
                  fullWidth
                  label="Email"
                  error={!!errors.email}
                  helperText={errors.email?.message}
                  sx={{ mb: 2 }}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <EmailIcon color="action" />
                      </InputAdornment>
                    ),
                  }}
                />
              )}
            />

            <Controller
              name="password"
              control={control}
              render={({ field }) => (
                <TextField
                  {...field}
                  fullWidth
                  label="Password"
                  type={showPassword ? 'text' : 'password'}
                  error={!!errors.password}
                  helperText={errors.password?.message}
                  sx={{ mb: 3 }}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <PasswordIcon color="action" />
                      </InputAdornment>
                    ),
                    endAdornment: (
                      <InputAdornment position="end">
                        <IconButton
                          onClick={() => setShowPassword(!showPassword)}
                          edge="end"
                        >
                          {showPassword ? <VisibilityOffIcon /> : <VisibilityIcon />}
                        </IconButton>
                      </InputAdornment>
                    ),
                  }}
                />
              )}
            />

            <Button
              type="submit"
              fullWidth
              variant="contained"
              size="large"
              color="secondary"
              disabled={isLoading}
              sx={{ py: 1.5, mb: 2, fontWeight: 600 }}
            >
              {isLoading ? 'Creating Account...' : 'Create Account'}
            </Button>

            <Divider sx={{ my: 2 }}>
              <Typography variant="body2" color="text.secondary">
                OR
              </Typography>
            </Divider>

            <Box textAlign="center">
              <Typography variant="body2" color="text.secondary">
                Already have an account?{' '}
                <Link component={RouterLink} to="/login" fontWeight="medium">
                  Sign in
                </Link>
              </Typography>
            </Box>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
};

export default Register;
</file>

<file path="frontend/src/pages/Profile/Profile.jsx">
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import {
  Grid,
  Card,
  CardContent,
  Typography,
  TextField,
  Button,
  Avatar,
  Box,
  Chip,
  IconButton,
} from '@mui/material';
import {
  Edit,
  Save,
  Cancel,
  PhotoCamera,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import toast from 'react-hot-toast';
import Layout from '../../components/Layout/Layout';
import { setUser } from '../../store/slices/authSlice';
import { updateUserProfile, selectUserLoading } from '../../store/slices/userSlice';
import { useAppDispatch } from '../../store/store'; // Import useAppDispatch

const schema = yup.object({
  firstName: yup.string().required('First name is required'),
  lastName: yup.string().required('Last name is required'),
  email: yup.string().email('Invalid email').required('Email is required'),
});

const Profile = () => {
  const dispatch = useAppDispatch(); // Use the typed dispatch
  const { user } = useSelector((state) => state.auth);
  const isLoading = useSelector(selectUserLoading);
  
  const [isEditing, setIsEditing] = useState(false);
  const [profileImage, setProfileImage] = useState(null);

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm({
    resolver: yupResolver(schema),
  });

  // Set default form values when user data is available
  useEffect(() => {
    if (user) {
        reset({
            firstName: user.firstName || '',
            lastName: user.lastName || '',
            email: user.email || '',
        });
    }
  }, [user, reset]);


  const handleEdit = () => {
    setIsEditing(true);
  };

  const handleCancel = () => {
    setIsEditing(false);
    reset();
  };

  const onSubmit = async (data) => {
    if (!user) return;
    try {
      const resultAction = await dispatch(updateUserProfile({ id: user.id, userData: data }));
      if (updateUserProfile.fulfilled.match(resultAction)) {
        dispatch(setUser(resultAction.payload));
        toast.success('Profile updated successfully!');
        setIsEditing(false);
      } else {
        toast.error(resultAction.payload || 'Failed to update profile');
      }
    } catch (error) {
      toast.error('An unexpected error occurred.');
    }
  };
  
  const handleImageChange = (event) => {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onloadend = () => {
            setProfileImage(reader.result);
            toast.success("Profile picture updated (preview). Upload functionality coming soon!");
        };
        reader.readAsDataURL(file);
    }
  };

  return (
    <Layout>
      <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }}>
        <Typography variant="h4" fontWeight="bold" gutterBottom>Profile Settings</Typography>
        <Typography variant="body1" color="text.secondary" sx={{ mb: 4 }}>Manage your personal information and account settings.</Typography>

        <Grid container spacing={3}>
          <Grid item xs={12} md={4}>
            <Card><CardContent sx={{ textAlign: 'center' }}>
              <Box position="relative" display="inline-block" mb={2}>
                <Avatar src={profileImage || user?.profilePicture} sx={{ width: 120, height: 120, mx: 'auto' }}>
                  {user?.username?.charAt(0).toUpperCase()}
                </Avatar>
                <IconButton component="label" sx={{ position: 'absolute', bottom: 0, right: 0, bgcolor: 'primary.main', color: 'white', '&:hover': { bgcolor: 'primary.dark' } }}>
                  <PhotoCamera />
                  <input type="file" hidden accept="image/*" onChange={handleImageChange} />
                </IconButton>
              </Box>
              <Typography variant="h6" gutterBottom>{user?.firstName} {user?.lastName}</Typography>
              <Typography variant="body2" color="text.secondary" gutterBottom>@{user?.username}</Typography>
              <Box mt={1}>
                {user?.roles?.map((role) => (
                  <Chip key={role.id} label={role.name.replace('ROLE_', '')} size="small" color={role.name === 'ROLE_ADMIN' ? 'error' : role.name === 'ROLE_MANAGER' ? 'warning' : 'primary'} />
                ))}
              </Box>
            </CardContent></Card>
          </Grid>
          <Grid item xs={12} md={8}>
            <Card><CardContent>
              <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
                <Typography variant="h6">Personal Information</Typography>
                {!isEditing ? (
                  <Button startIcon={<Edit />} onClick={handleEdit}>Edit Profile</Button>
                ) : (
                  <Box display="flex" gap={1}>
                    <Button onClick={handleCancel} color="inherit">Cancel</Button>
                    <Button startIcon={<Save />} onClick={handleSubmit(onSubmit)} variant="contained" disabled={isLoading}>{isLoading ? 'Saving...' : 'Save Changes'}</Button>
                  </Box>
                )}
              </Box>
              {isEditing ? (
                <Box component="form" onSubmit={handleSubmit(onSubmit)}>
                  <Grid container spacing={2}>
                    <Grid item xs={12} sm={6}><TextField fullWidth label="First Name" {...register('firstName')} error={!!errors.firstName} helperText={errors.firstName?.message} /></Grid>
                    <Grid item xs={12} sm={6}><TextField fullWidth label="Last Name" {...register('lastName')} error={!!errors.lastName} helperText={errors.lastName?.message} /></Grid>
                    <Grid item xs={12}><TextField fullWidth label="Email" {...register('email')} error={!!errors.email} helperText={errors.email?.message} /></Grid>
                  </Grid>
                </Box>
              ) : (
                <Grid container spacing={2} sx={{ p: 2 }}>
                  <Grid item xs={12} sm={6}><Typography variant="body2" color="text.secondary">Full Name</Typography><Typography>{user?.firstName} {user?.lastName}</Typography></Grid>
                  <Grid item xs={12} sm={6}><Typography variant="body2" color="text.secondary">Email Address</Typography><Typography>{user?.email}</Typography></Grid>
                  <Grid item xs={12} sm={6}><Typography variant="body2" color="text.secondary">Username</Typography><Typography>@{user?.username}</Typography></Grid>
                  <Grid item xs={12} sm={6}><Typography variant="body2" color="text.secondary">Member Since</Typography><Typography>{user?.createdAt ? new Date(user.createdAt).toLocaleDateString() : 'N/A'}</Typography></Grid>
                </Grid>
              )}
            </CardContent></Card>
          </Grid>
        </Grid>
      </motion.div>
    </Layout>
  );
};

export default Profile;
</file>

<file path="frontend/src/pages/Settings/Settings.jsx">
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  Grid,
  Card,
  CardContent,
  Typography,
  Switch,
  Divider,
  Box,
  Button,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  Alert,
} from '@mui/material';
import {
  DarkMode,
  Notifications,
  Security,
  Storage,
  Delete,
} from '@mui/icons-material';
import { motion } from 'framer-motion';
import Layout from '../../components/Layout/Layout';
import { toggleTheme, selectEffectiveTheme } from '../../store/slices/themeSlice';

const Settings = () => {
  const dispatch = useDispatch();
  const effectiveTheme = useSelector(selectEffectiveTheme);
  const { user } = useSelector((state) => state.auth);

  const handleThemeToggle = () => {
    dispatch(toggleTheme());
  };

  const settingsCategories = [
    {
      title: 'Appearance',
      icon: <DarkMode />,
      settings: [
        {
          label: 'Dark Mode',
          description: 'Toggle between light and dark theme',
          control: (
            <Switch
              checked={effectiveTheme === 'dark'}
              onChange={handleThemeToggle}
              color="primary"
            />
          ),
        },
      ],
    },
    {
      title: 'Notifications',
      icon: <Notifications />,
      settings: [
        {
          label: 'Email Notifications',
          description: 'Receive notifications via email',
          control: <Switch defaultChecked color="primary" />,
        },
        {
          label: 'Push Notifications',
          description: 'Receive push notifications in browser',
          control: <Switch defaultChecked color="primary" />,
        },
      ],
    },
    {
      title: 'Privacy & Security',
      icon: <Security />,
      settings: [
        {
          label: 'Two-Factor Authentication',
          description: 'Add an extra layer of security',
          control: <Button variant="outlined" size="small">Enable</Button>,
        },
      ],
    },
  ];

  return (
    <Layout>
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
      >
        <Typography variant="h4" fontWeight="bold" gutterBottom>
          Settings
        </Typography>
        <Typography variant="body1" color="text.secondary" sx={{ mb: 4 }}>
          Customize your experience and manage your preferences.
        </Typography>

        <Grid container spacing={3}>
          {settingsCategories.map((category, index) => (
            <Grid item xs={12} key={category.title}>
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: index * 0.1 }}
              >
                <Card>
                  <CardContent>
                    <Box display="flex" alignItems="center" mb={2}>
                      {category.icon}
                      <Typography variant="h6" sx={{ ml: 1 }}>
                        {category.title}
                      </Typography>
                    </Box>
                    <Divider sx={{ mb: 2 }} />
                    <List>
                      {category.settings.map((setting, settingIndex) => (
                        <ListItem key={settingIndex} divider={settingIndex < category.settings.length - 1}>
                          <ListItemText
                            primary={setting.label}
                            secondary={setting.description}
                          />
                          <ListItemSecondaryAction>
                            {setting.control}
                          </ListItemSecondaryAction>
                        </ListItem>
                      ))}
                    </List>
                  </CardContent>
                </Card>
              </motion.div>
            </Grid>
          ))}

          {/* Danger Zone */}
          <Grid item xs={12}>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.4 }}
            >
              <Card sx={{ border: '1px solid', borderColor: 'error.main' }}>
                <CardContent>
                  <Box display="flex" alignItems="center" mb={2}>
                    <Delete color="error" />
                    <Typography variant="h6" sx={{ ml: 1 }} color="error">
                      Danger Zone
                    </Typography>
                  </Box>
                  <Divider sx={{ mb: 2 }} />
                  <Alert severity="warning" sx={{ mb: 2 }}>
                    This action is irreversible. Please proceed with caution.
                  </Alert>
                  <Box>
                    <Box display="flex" justifyContent="space-between" alignItems="center">
                      <Box>
                        <Typography variant="body1" fontWeight="medium">
                          Delete Account
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                          Permanently delete your account and all data.
                        </Typography>
                      </Box>
                      <Button variant="outlined" color="error">
                        Delete My Account
                      </Button>
                    </Box>
                  </Box>
                </CardContent>
              </Card>
            </motion.div>
          </Grid>
        </Grid>
      </motion.div>
    </Layout>
  );
};

export default Settings;
</file>

<file path="frontend/src/types/index.ts">
// User types
export interface User {
  id: number;
  email: string;
  firstName: string;
  lastName: string;
  username?: string;
  avatar?: string;
  roles: Role[];
  createdAt?: string;
  updatedAt?: string;
  enabled: boolean; // Added this property
}

export interface Role {
  id: number;
  name: 'ADMIN' | 'MANAGER' | 'MEMBER' | 'ROLE_ADMIN' | 'ROLE_MANAGER' | 'ROLE_MEMBER';
  description?: string;
}

// Auth types
export interface LoginRequest {
  username: string;
  password: string;
}

export interface SignupRequest {
  username: string;
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  role?: string[];
}

export interface AuthResponse {
  token: string;
  type: string;
  id: number;
  username: string;
  email: string;
  roles: string[];
}

// Team types
export interface Team {
  id: number;
  name: string;
  description?: string;
  createdAt: string;
  updatedAt: string;
  leader?: User;
  members: User[];
  projects?: Project[];
}

export interface TeamRequest {
  name: string;
  description?: string;
  leaderId?: number;
}

// Project types
export interface Project {
  id: number;
  name: string;
  description?: string;
  status: 'PLANNING' | 'IN_PROGRESS' | 'COMPLETED' | 'ON_HOLD';
  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  startDate?: string;
  endDate?: string;
  deadline?: string;
  progress: number;
  createdAt: string;
  updatedAt: string;
  owner?: User;
  team?: Team;
  members: User[];
}

export interface ProjectRequest {
  name: string;
  description?: string;
  status?: Project['status'];
  priority?: Project['priority'];
  startDate?: string;
  endDate?: string;
  deadline?: string;
  teamId?: number;
  ownerId?: number;
}

// Chat types
export interface ChatRoom {
  id: number;
  name: string;
  description?: string;
  type: 'DIRECT' | 'GROUP' | 'TEAM' | 'PROJECT';
  createdAt: string;
  updatedAt: string;
  members: User[];
  lastMessage?: ChatMessage;
}

export interface ChatMessage {
  id: number;
  content: string;
  messageType: 'TEXT' | 'IMAGE' | 'FILE';
  timestamp: string;
  sender: User;
  chatRoom: ChatRoom;
  edited?: boolean;
  editedAt?: string;
}

export interface ChatMessageRequest {
  content: string;
  messageType: ChatMessage['messageType'];
  chatRoomId: number;
}

export interface ChatRoomRequest {
  name: string;
  description?: string;
  type: ChatRoom['type'];
  memberIds: number[];
}

// UI State types
export interface LoadingState {
  [key: string]: boolean;
}

export interface ErrorState {
  [key: string]: string | null;
}

// Theme types
export type ThemeMode = 'light' | 'dark' | 'system';

// API Response types
export interface ApiResponse<T = any> {
  data: T;
  message?: string;
  success: boolean;
}

export interface ApiError {
  message: string;
  status: number;
  details?: any;
}

// Pagination types
export interface PaginationParams {
  page?: number;
  size?: number;
  sort?: string;
  direction?: 'ASC' | 'DESC';
}

export interface PaginatedResponse<T> {
  content: T[];
  totalElements: number;
  totalPages: number;
  size: number;
  number: number;
  first: boolean;
  last: boolean;
  numberOfElements: number;
}

// Dashboard types
export interface DashboardStats {
  totalUsers?: number;
  totalTeams?: number;
  totalProjects?: number;
  activeProjects?: number;
  completedProjects?: number;
  totalMessages?: number;
  userGrowth?: number;
  projectProgress?: {
    completed: number;
    inProgress: number;
    planning: number;
    onHold: number;
  };
  recentActivities?: Activity[];
}

export interface Activity {
  id: number;
  type: 'USER_JOINED' | 'PROJECT_CREATED' | 'TEAM_CREATED' | 'MESSAGE_SENT' | 'PROJECT_COMPLETED';
  description: string;
  user?: User;
  entity?: string;
  entityId?: number;
  timestamp: string;
}

// Form types
export interface FormErrors {
  [key: string]: string | undefined;
}

// File upload types
export interface FileUpload {
  file: File;
  progress: number;
  status: 'pending' | 'uploading' | 'completed' | 'error';
  url?: string;
}

// Notification types
export interface Notification {
  id: string;
  type: 'success' | 'error' | 'warning' | 'info';
  title: string;
  message: string;
  duration?: number;
  actions?: NotificationAction[];
}

export interface NotificationAction {
  label: string;
  onClick: () => void;
  variant?: 'text' | 'outlined' | 'contained';
}

// WebSocket types
export interface WebSocketMessage {
  type: string;
  payload: any;
  timestamp: string;
}
</file>

<file path="frontend/src/store/slices/authSlice.ts">
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { User, AuthResponse, LoginRequest, SignupRequest } from '../../types';
import * as authService from '../../services/authService';

// State interface
interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  initialLoad: 'idle' | 'loading' | 'succeeded' | 'failed';
}

// Get initial state from localStorage
const getInitialState = (): AuthState => {
  const token = localStorage.getItem('token');
  return {
    user: null,
    token,
    isAuthenticated: !!token,
    isLoading: false,
    error: null,
    initialLoad: 'idle',
  };
};

const initialState: AuthState = getInitialState();

// === ASYNC THUNKS ===
export const login = createAsyncThunk(
  'auth/login',
  async (credentials: LoginRequest, { rejectWithValue }) => {
    try {
      const response = await authService.login(credentials);
      localStorage.setItem('token', response.token);
      return response;
    } catch (error: any) {
      return rejectWithValue(error.message || 'Login failed');
    }
  }
);

export const signup = createAsyncThunk(
  'auth/signup',
  async (userData: SignupRequest, { rejectWithValue }) => {
    try {
      const response = await authService.signup(userData);
      return response;
    } catch (error: any) {
      return rejectWithValue(error.message || 'Registration failed');
    }
  }
);

export const getCurrentUser = createAsyncThunk(
  'auth/getCurrentUser',
  async (_, { rejectWithValue }) => {
    if (!localStorage.getItem('token')) {
      return rejectWithValue('No token found');
    }
    try {
      const user = await authService.getCurrentUser();
      return user;
    } catch (error: any) {
      return rejectWithValue(error.message || 'Failed to fetch user');
    }
  }
);

// === SLICE ===
const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logout: (state) => {
      state.user = null;
      state.token = null;
      state.isAuthenticated = false;
      localStorage.removeItem('token');
    },
    clearError: (state) => {
      state.error = null;
    },
    setUser: (state, action: PayloadAction<User>) => {
      state.user = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder
      // LOGIN
      .addCase(login.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(login.fulfilled, (state, action: PayloadAction<AuthResponse>) => {
        state.isLoading = false;
        state.isAuthenticated = true;
        state.token = action.payload.token;

        // 🔥 FIXED HERE: manually map the AuthResponse to User
        state.user = {
          id: action.payload.id,
          email: action.payload.email,
          firstName: '',
          lastName: '',
          username: action.payload.username,
          avatar: '',
          roles: action.payload.roles.map(role => ({ id: 0, name: role as any })),
          enabled: true,
        };
      })
      .addCase(login.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })

      // SIGNUP
      .addCase(signup.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(signup.fulfilled, (state) => {
        state.isLoading = false;
      })
      .addCase(signup.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })

      // GET CURRENT USER
      .addCase(getCurrentUser.pending, (state) => {
        state.initialLoad = 'loading';
      })
      .addCase(getCurrentUser.fulfilled, (state, action) => {
        state.isAuthenticated = true;
        state.user = action.payload;
        state.initialLoad = 'succeeded';
      })
      .addCase(getCurrentUser.rejected, (state) => {
        state.isAuthenticated = false;
        state.token = null;
        state.user = null;
        localStorage.removeItem('token');
        state.initialLoad = 'failed';
      });
  },
});

// === EXPORTS ===
export const { logout, clearError, setUser } = authSlice.actions;

// === SELECTORS ===
export const selectUser = (state: { auth: AuthState }) => state.auth.user;
export const selectIsAuthenticated = (state: { auth: AuthState }) => state.auth.isAuthenticated;
export const selectIsLoading = (state: { auth: AuthState }) => state.auth.isLoading;
export const selectAuthError = (state: { auth: AuthState }) => state.auth.error;
export const selectIsAdmin = (state: { auth: AuthState }) =>
  state.auth.user?.roles.some(role => role.name === 'ROLE_ADMIN') || false;
export const selectInitialLoad = (state: { auth: AuthState }) => state.auth.initialLoad;

export default authSlice.reducer;
</file>

<file path="frontend/src/App.tsx">
// File path: frontend/src/App.tsx

import React, { useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { Provider } from 'react-redux';
import { Toaster } from 'react-hot-toast';
import { ThemeProvider, Box } from '@mui/material';
import CssBaseline from '@mui/material/CssBaseline';
import { store, useAppDispatch, useAppSelector } from './store/store';
import { useTheme } from './hooks/useTheme'; 

import { getCurrentUser, selectInitialLoad, selectIsAuthenticated } from './store/slices/authSlice';

// Components and Pages
import Landing from './pages/Landing/Landing';
import Login from './pages/Auth/Login';
import Register from './pages/Auth/Register';
import Dashboard from './pages/Dashboard/Dashboard';
import Profile from './pages/Profile/Profile';
import Settings from './pages/Settings/Settings';
import VerifyEmail from './pages/Auth/VerifyEmail';
import ProtectedRoute from './components/Auth/ProtectedRoute'; // <-- CORRECTED PATH
import LoadingSpinner from './components/Common/LoadingSpinner';

const InitialLoadingScreen = () => (
    <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100vh' }}>
        <LoadingSpinner message="Initializing Application..." />
    </Box>
);

const AppContent = () => {
    const dispatch = useAppDispatch();
    const initialLoad = useAppSelector(selectInitialLoad);
    const isAuthenticated = useAppSelector(selectIsAuthenticated);
    const [theme, themeMode] = useTheme();

    useEffect(() => {
        dispatch(getCurrentUser());
    }, [dispatch]);
    
    if (initialLoad === 'idle' || initialLoad === 'loading') {
        return <InitialLoadingScreen />;
    }

    return (
        <ThemeProvider theme={theme}>
            <CssBaseline />
            <Toaster position="bottom-right" reverseOrder={false} />
            <Router>
                <Routes>
                    <Route path="/" element={<Landing />} />
                    <Route path="/login" element={<Login />} />
                    <Route path="/register" element={<Register />} />
                    <Route path="/verify-email" element={<VerifyEmail />} />

                    <Route path="/dashboard" element={<ProtectedRoute><Dashboard /></ProtectedRoute>} />
                    <Route path="/profile" element={<ProtectedRoute><Profile /></ProtectedRoute>} />
                    <Route path="/settings" element={<ProtectedRoute><Settings /></ProtectedRoute>} />
                    
                    <Route path="*" element={<Navigate to={isAuthenticated ? "/dashboard" : "/"} />} />
                </Routes>
            </Router>
        </ThemeProvider>
    );
};

const App = () => (
    <Provider store={store}>
        <AppContent />
    </Provider>
);

export default App;
</file>

<file path="frontend/src/pages/Auth/Login.tsx">
import React, { useState, useEffect } from 'react';
import { Link as RouterLink, useNavigate, useLocation } from 'react-router-dom';
import {
    Box,
    Card,
    CardContent,
    TextField,
    Button,
    Typography,
    Link,
    Alert,
    InputAdornment,
    IconButton,
    Divider,
    useTheme,
    alpha, // <-- FIX: IMPORTED ALPHA UTILITY
} from '@mui/material';
import {
    Visibility as VisibilityIcon,
    VisibilityOff as VisibilityOffIcon,
    EmailOutlined as EmailIcon,
    LockOutlined as PasswordIcon,
} from '@mui/icons-material';
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { useAppDispatch, useAppSelector } from '../../store/store';
import { login, clearError, selectIsLoading, selectAuthError } from '../../store/slices/authSlice';
import { showSuccessNotification } from '../../store/slices/uiSlice';
import { LoginRequest } from '../../types';
// No need to import customStyles.css here if it's already in main.tsx

const loginSchema = yup.object().shape({
    username: yup.string().required('Username or Email is required'),
    password: yup.string().required('Password is required'),
});

const Login: React.FC = () => {
    const [showPassword, setShowPassword] = useState(false);
    const theme = useTheme();
    const navigate = useNavigate();
    const location = useLocation();
    const dispatch = useAppDispatch();
    
    const isLoading = useAppSelector(selectIsLoading);
    const error = useAppSelector(selectAuthError);

    const { control, handleSubmit, formState: { errors }, getValues } = useForm<LoginRequest>({
        resolver: yupResolver(loginSchema),
        defaultValues: { username: '', password: '' },
    });

    useEffect(() => {
        dispatch(clearError());
    }, [dispatch]);

    const onSubmit = async (data: LoginRequest) => {
        try {
            await dispatch(login(data)).unwrap();
            dispatch(showSuccessNotification('Welcome back!', 'You have successfully logged in.'));
            const from = (location.state as any)?.from?.pathname || '/dashboard';
            navigate(from, { replace: true });
        } catch (err: any) {
            if (err && err.message && err.message.includes('verify your email')) {
                const usernameOrEmail = getValues("username");
                navigate('/verify-email', { state: { email: usernameOrEmail } });
            }
        }
    };

    return (
        <Box
            sx={{
                minHeight: '100vh',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                background: `linear-gradient(135deg, ${theme.palette.background.default} 0%, ${alpha(theme.palette.primary.main, 0.1)} 100%)`,
                p: 2,
            }}
        >
            <Card
                sx={{
                    maxWidth: 420,
                    width: '100%',
                    borderRadius: 3,
                    boxShadow: '0 25px 50px -12px rgba(0,0,0,0.25)',
                    backdropFilter: 'blur(20px)',
                    backgroundColor: alpha(theme.palette.background.paper, 0.9),
                }}
                className="animate-fade-in" // This class comes from your existing customStyles.css
            >
                <CardContent sx={{ p: { xs: 3, sm: 4 } }}>
                    <Box textAlign="center" mb={3}>
                        <Typography variant="h4" component="h1" sx={{ fontWeight: 700, mb: 1, color: 'primary.main' }}>
                            Welcome Back
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                            Sign in to continue to Collabris
                        </Typography>
                    </Box>

                    {error && <Alert severity="error" sx={{ mb: 3 }}>{error}</Alert>}

                    <Box component="form" onSubmit={handleSubmit(onSubmit)} noValidate>
                        <Controller
                            name="username"
                            control={control}
                            render={({ field }) => (
                                <TextField
                                    {...field}
                                    fullWidth
                                    label="Username or Email"
                                    error={!!errors.username}
                                    helperText={errors.username?.message}
                                    sx={{ mb: 2 }}
                                    InputProps={{
                                        startAdornment: (
                                            <InputAdornment position="start">
                                                <EmailIcon color="action" />
                                            </InputAdornment>
                                        ),
                                    }}
                                />
                            )}
                        />
                        <Controller
                            name="password"
                            control={control}
                            render={({ field }) => (
                                <TextField
                                    {...field}
                                    fullWidth
                                    label="Password"
                                    type={showPassword ? 'text' : 'password'}
                                    error={!!errors.password}
                                    helperText={errors.password?.message}
                                    sx={{ mb: 3 }}
                                    InputProps={{
                                        startAdornment: (
                                            <InputAdornment position="start">
                                                <PasswordIcon color="action" />
                                            </InputAdornment>
                                        ),
                                        endAdornment: (
                                            <InputAdornment position="end">
                                                <IconButton onClick={() => setShowPassword(!showPassword)} edge="end">
                                                    {showPassword ? <VisibilityOffIcon /> : <VisibilityIcon />}
                                                </IconButton>
                                            </InputAdornment>
                                        ),
                                    }}
                                />
                            )}
                        />

                        <Button type="submit" fullWidth variant="contained" size="large" disabled={isLoading} sx={{ py: 1.5, mb: 2, fontWeight: 600 }}>
                            {isLoading ? 'Signing In...' : 'Sign In'}
                        </Button>
                        
                        <Divider sx={{ my: 2 }}>
                            <Typography variant="body2" color="text.secondary">
                                OR
                            </Typography>
                        </Divider>

                        <Box textAlign="center">
                            <Typography variant="body2" color="text.secondary">
                                Don't have an account?{' '}
                                <Link component={RouterLink} to="/register" fontWeight="medium">
                                    Sign up
                                </Link>
                            </Typography>
                        </Box>
                    </Box>
                </CardContent>
            </Card>
        </Box>
    );
};

export default Login;
</file>

<file path="backend/src/main/resources/application.properties">
# Database Configuration
spring.datasource.url=jdbc:postgresql://ep-aged-pine-aevx5u5z-pooler.c-2.us-east-2.aws.neon.tech:5432/neondb?sslmode=require&channel_binding=require
spring.datasource.username=neondb_owner
spring.datasource.password=npg_EKxh9oIm5FdZ
spring.datasource.driver-class-name=org.postgresql.Driver

# --- NEW HIKARI SETTINGS TO PREVENT TIMEOUTS ---
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.keepalive-time=600000
spring.datasource.hikari.idle-timeout=600000
# -----------------------------------------------

# JPA/Hibernate Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.open-in-view=false

# JWT Configuration
jwt.secret=c40031d66765c9a385adb9980ceb96dcd1bf21aba01b96978357b22a255e82f9
jwt.expiration=86400000

# Server Configuration
server.port=8080

# Swagger/OpenAPI Configuration
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method

# CORS Configuration - Update for production
cors.allowed-origins=http://localhost:5173

# Jackson Configuration
spring.jackson.serialization.fail-on-empty-beans=false

# File Upload Configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
file.upload-dir=uploads

# Email Configuration
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=sibomanaelissa71@gmail.com
spring.mail.password=wdhapdculcihbvnk
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

# App Mail Configuration
app.mail.enabled=true
app.mail.from=no-reply@collabris.com

# Logging Configuration
logging.level.com.collabris=INFO
logging.level.org.springframework.security=INFO
</file>

<file path="backend/src/main/java/com/collabris/controller/AuthController.java">
package com.collabris.controller;

import com.collabris.dto.request.*;
import com.collabris.dto.response.JwtResponse;
import com.collabris.dto.response.MessageResponse;
import com.collabris.entity.Role;
import com.collabris.entity.User;
import com.collabris.entity.VerificationToken;
import com.collabris.repository.RoleRepository;
import com.collabris.repository.UserRepository;
import com.collabris.security.jwt.JwtUtils;
import com.collabris.security.services.EmailService;
import com.collabris.security.services.UserDetailsImpl;
import com.collabris.security.services.VerificationTokenService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
public class AuthController {

    @Autowired
    AuthenticationManager authenticationManager;

    @Autowired
    UserRepository userRepository;

    @Autowired
    RoleRepository roleRepository;

    @Autowired
    PasswordEncoder encoder;

    @Autowired
    JwtUtils jwtUtils;

    @Autowired
    VerificationTokenService verificationTokenService;

    @Autowired
    EmailService emailService;

    // ========================= LOGIN ============================
    @PostMapping("/signin")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {

        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword()));

        SecurityContextHolder.getContext().setAuthentication(authentication);
        String jwt = jwtUtils.generateJwtToken(authentication);

        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();

        // if user not enabled, reject
        Optional<User> userOpt = userRepository.findByUsername(userDetails.getUsername());
        if (userOpt.isPresent() && !userOpt.get().isEnabled()) {
            return ResponseEntity
                    .badRequest()
                    .body(new MessageResponse("Error: Please verify your email before logging in."));
        }

        List<String> roles = userDetails.getAuthorities().stream()
                .map(item -> item.getAuthority())
                .collect(Collectors.toList());

        return ResponseEntity.ok(new JwtResponse(
                jwt,
                userDetails.getId(),
                userDetails.getUsername(),
                userDetails.getEmail(),
                roles));
    }

    // ========================= REGISTER ============================
    @PostMapping("/signup")
    public ResponseEntity<?> registerUser(@Valid @RequestBody SignupRequest signUpRequest) {

        if (userRepository.existsByUsername(signUpRequest.getUsername())) {
            return ResponseEntity.badRequest().body(new MessageResponse("Error: Username is already taken!"));
        }

        if (userRepository.existsByEmail(signUpRequest.getEmail())) {
            return ResponseEntity.badRequest().body(new MessageResponse("Error: Email is already in use!"));
        }

        // create new user
        User user = new User(signUpRequest.getUsername(),
                signUpRequest.getEmail(),
                encoder.encode(signUpRequest.getPassword()));

        user.setFirstName(signUpRequest.getFirstName());
        user.setLastName(signUpRequest.getLastName());
        user.setEnabled(false); // until email verification

        Set<String> strRoles = signUpRequest.getRole();
        Set<Role> roles = new HashSet<>();

        if (strRoles == null) {
            Role userRole = roleRepository.findByName(Role.ERole.MEMBER)
                    .orElseThrow(() -> new RuntimeException("Error: Role is not found."));
            roles.add(userRole);
        } else {
            strRoles.forEach(role -> {
                switch (role.toLowerCase()) {
                    case "admin" -> {
                        Role adminRole = roleRepository.findByName(Role.ERole.ADMIN)
                                .orElseThrow(() -> new RuntimeException("Error: Role is not found."));
                        roles.add(adminRole);
                    }
                    case "manager" -> {
                        Role modRole = roleRepository.findByName(Role.ERole.MANAGER)
                                .orElseThrow(() -> new RuntimeException("Error: Role is not found."));
                        roles.add(modRole);
                    }
                    default -> {
                        Role userRole = roleRepository.findByName(Role.ERole.MEMBER)
                                .orElseThrow(() -> new RuntimeException("Error: Role is not found."));
                        roles.add(userRole);
                    }
                }
            });
        }

        user.setRoles(roles);
        userRepository.save(user);

        VerificationToken token = verificationTokenService.createVerificationToken(user);
        emailService.sendVerificationEmail(user.getEmail(), token.getToken());

        return ResponseEntity.ok(new MessageResponse("User registered successfully! Please verify your email."));
    }

    // ========================= VERIFY EMAIL ============================
    @PostMapping("/verify-email")
    public ResponseEntity<?> verifyEmail(@RequestParam("token") String token) {
        VerificationToken verificationToken = verificationTokenService.findByToken(token);
        if (verificationToken == null) {
            return ResponseEntity.badRequest().body(new MessageResponse("Invalid token"));
        }

        User user = verificationToken.getUser();

        if (user.isEnabled()) {
            return ResponseEntity.badRequest().body(new MessageResponse("Account already verified."));
        }

        verificationTokenService.verifyUser(token);
        user.setEnabled(true);
        userRepository.save(user);

        return ResponseEntity.ok(new MessageResponse("Email verified successfully! You can now log in."));
    }

    // ========================= PASSWORD RESET ============================
    @PostMapping("/reset-password-request")
    public ResponseEntity<?> resetPasswordRequest(@RequestBody ResetPasswordRequest request) {
        Optional<User> userOpt = userRepository.findByEmail(request.getEmail());
        if (userOpt.isEmpty()) {
            return ResponseEntity.badRequest().body(new MessageResponse("User not found with that email."));
        }

        User user = userOpt.get();
        VerificationToken token = verificationTokenService.createVerificationToken(user);
        emailService.sendResetPasswordEmail(user.getEmail(), token.getToken());

        return ResponseEntity.ok(new MessageResponse("Password reset email sent."));
    }

    @PostMapping("/reset-password")
    public ResponseEntity<?> resetPassword(@RequestBody ResetPasswordConfirmRequest request) {
        VerificationToken verificationToken = verificationTokenService.findByToken(request.getToken());
        if (verificationToken == null) {
            return ResponseEntity.badRequest().body(new MessageResponse("Invalid or expired token."));
        }

        User user = verificationToken.getUser();
        user.setPassword(encoder.encode(request.getNewPassword()));
        userRepository.save(user);

        return ResponseEntity.ok(new MessageResponse("Password reset successful!"));
    }
}
</file>

</files>
